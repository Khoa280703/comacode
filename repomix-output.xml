This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
android/
  app/
    src/
      debug/
        AndroidManifest.xml
      main/
        kotlin/
          com/
            comacode/
              comacode/
                MainActivity.kt
        res/
          drawable/
            launch_background.xml
          drawable-v21/
            launch_background.xml
          mipmap-hdpi/
            ic_launcher.png
          mipmap-mdpi/
            ic_launcher.png
          mipmap-xhdpi/
            ic_launcher.png
          mipmap-xxhdpi/
            ic_launcher.png
          mipmap-xxxhdpi/
            ic_launcher.png
          values/
            styles.xml
          values-night/
            styles.xml
        AndroidManifest.xml
      profile/
        AndroidManifest.xml
    build.gradle.kts
  gradle/
    wrapper/
      gradle-wrapper.properties
  .gitignore
  build.gradle.kts
  gradle.properties
  settings.gradle.kts
cli_client/
  src/
    main.rs
    message_reader.rs
    raw_mode.rs
  Cargo.toml
core/
  src/
    protocol/
      codec.rs
      mod.rs
    terminal/
      mod.rs
      traits.rs
    transport/
      heartbeat.rs
      mod.rs
      reconnect.rs
      stream.rs
    types/
      command.rs
      event.rs
      message.rs
      mod.rs
      qr.rs
    auth.rs
    error.rs
    lib.rs
    streaming.rs
  Cargo.toml
hostagent/
  examples/
    test_qr.rs
  src/
    auth.rs
    cert.rs
    main.rs
    pty.rs
    quic_server.rs
    ratelimit.rs
    session.rs
    snapshot.rs
    vfs_watcher.rs
    vfs.rs
    web_ui.rs
  Cargo.toml
ios/
  Flutter/
    AppFrameworkInfo.plist
    Debug.xcconfig
    Release.xcconfig
  Frameworks/
    libmobile_bridge.a
  mobile/
    ios/
      Frameworks/
        mobile/
          ios/
            Frameworks/
              mobile_bridge/
                Info.plist
        mobile_bridge/
          Headers/
            mobile_bridge.h
          Modules/
            module.modulemap
          Info.plist
          mobile_bridge
          mobile_bridge.podspec
  Runner/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
        Icon-App-1024x1024@1x.png
        Icon-App-20x20@1x.png
        Icon-App-20x20@2x.png
        Icon-App-20x20@3x.png
        Icon-App-29x29@1x.png
        Icon-App-29x29@2x.png
        Icon-App-29x29@3x.png
        Icon-App-40x40@1x.png
        Icon-App-40x40@2x.png
        Icon-App-40x40@3x.png
        Icon-App-60x60@2x.png
        Icon-App-60x60@3x.png
        Icon-App-76x76@1x.png
        Icon-App-76x76@2x.png
        Icon-App-83.5x83.5@2x.png
      LaunchImage.imageset/
        Contents.json
        LaunchImage.png
        LaunchImage@2x.png
        LaunchImage@3x.png
        README.md
    Base.lproj/
      LaunchScreen.storyboard
      Main.storyboard
    AppDelegate.swift
    Info.plist
    Runner-Bridging-Header.h
  Runner.xcodeproj/
    project.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
        WorkspaceSettings.xcsettings
      contents.xcworkspacedata
    xcshareddata/
      xcschemes/
        Runner.xcscheme
    project.pbxproj
  Runner.xcworkspace/
    xcshareddata/
      IDEWorkspaceChecks.plist
      WorkspaceSettings.xcsettings
    contents.xcworkspacedata
  RunnerTests/
    RunnerTests.swift
  .gitignore
  Podfile
  Podfile.lock
lib/
  bridge/
    api.dart
    bridge_wrapper.dart
    bridge_wrapper.g.dart
    ffi_helpers.dart
    frb_generated.dart
    frb_generated.io.dart
    frb_generated.web.dart
    lib.dart
  core/
    storage.dart
    theme.dart
  features/
    connection/
      connection_provider.dart
      connection_providers.dart
      connection_providers.g.dart
      home_page.dart
    project/
      models/
        models.dart
        project.dart
        session_metadata.dart
      widgets/
        project_list.dart
        project_tile.dart
        session_list.dart
        session_tile.dart
        vfs_file_picker.dart
      project_picker_page.dart
      project_providers.dart
      project_storage.dart
      project.dart
      session_picker_page.dart
    qr_scanner/
      qr_scanner_page.dart
    vfs/
      widgets/
        entry_tile.dart
      vfs_notifier.dart
    vibe/
      models/
        file_attachment.dart
        output_block.dart
        output_buffer.dart
        session_status.dart
        special_key.dart
        vibe_session_state.dart
        vibe_session.dart
      services/
        haptic_service.dart
        session_manager.dart
        speech_service_provider.dart
        speech_service.dart
      widgets/
        attachment_button.dart
        dictation_button.dart
        error_dialog.dart
        file_attachment_picker.dart
        input_bar.dart
        output_parser.dart
        output_view.dart
        parsed_output_view.dart
        quick_keys_toolbar.dart
        search_overlay.dart
        session_tab_bar.dart
        tab_item.dart
        thinking_indicator.dart
      vibe_session_page.dart
      vibe_session_providers.dart
  models/
    dir_entry.dart
  main.dart
macos/
  Flutter/
    Flutter-Debug.xcconfig
    Flutter-Release.xcconfig
    GeneratedPluginRegistrant.swift
  Runner/
    Assets.xcassets/
      AppIcon.appiconset/
        app_icon_1024.png
        app_icon_128.png
        app_icon_16.png
        app_icon_256.png
        app_icon_32.png
        app_icon_512.png
        app_icon_64.png
        Contents.json
    Base.lproj/
      MainMenu.xib
    Configs/
      AppInfo.xcconfig
      Debug.xcconfig
      Release.xcconfig
      Warnings.xcconfig
    AppDelegate.swift
    DebugProfile.entitlements
    Info.plist
    MainFlutterWindow.swift
    Release.entitlements
  Runner.xcodeproj/
    project.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
    xcshareddata/
      xcschemes/
        Runner.xcscheme
    project.pbxproj
  Runner.xcworkspace/
    xcshareddata/
      IDEWorkspaceChecks.plist
    contents.xcworkspacedata
  RunnerTests/
    RunnerTests.swift
  .gitignore
  Podfile
  Podfile.lock
mobile_bridge/
  src/
    api.rs
    bridge.rs
    frb_generated.rs
    lib.rs
    quic_client.rs
  Cargo.toml
test/
  features/
    project/
      models_test.dart
      project_models_test.dart
  widget_test.dart
web/
  icons/
    Icon-192.png
    Icon-512.png
    Icon-maskable-192.png
    Icon-maskable-512.png
  favicon.png
  index.html
  manifest.json
.gitignore
.metadata
analysis_options.yaml
bridge_generated.frb.lsp.yaml
frb_config.yaml
pubspec.lock
pubspec.yaml

================================================================
Files
================================================================

================
File: android/app/src/debug/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

================
File: android/app/src/main/kotlin/com/comacode/comacode/MainActivity.kt
================
package com.comacode.comacode

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()

================
File: android/app/src/main/res/drawable/launch_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

================
File: android/app/src/main/res/drawable-v21/launch_background.xml
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

================
File: android/app/src/main/res/values/styles.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

================
File: android/app/src/main/res/values-night/styles.xml
================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

================
File: android/app/src/main/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-feature android:name="android.hardware.camera" android:required="false" />
    <application
        android:label="comacode"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

================
File: android/app/src/profile/AndroidManifest.xml
================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

================
File: android/app/build.gradle.kts
================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.comacode.comacode"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.comacode.comacode"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

================
File: android/gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-all.zip

================
File: android/.gitignore
================
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks

================
File: android/build.gradle.kts
================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}

================
File: android/gradle.properties
================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true

================
File: android/settings.gradle.kts
================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")

================
File: ios/Flutter/AppFrameworkInfo.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>

================
File: ios/Flutter/Debug.xcconfig
================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "Generated.xcconfig"

================
File: ios/Flutter/Release.xcconfig
================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "Generated.xcconfig"

================
File: ios/mobile/ios/Frameworks/mobile/ios/Frameworks/mobile_bridge/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleExecutable</key>
    <string>mobile_bridge</string>
    <key>CFBundleIdentifier</key>
    <string>com.comacode.mobile_bridge</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>mobile_bridge</string>
    <key>CFBundlePackageType</key>
    <string>FMWK</string>
</dict>
</plist>

================
File: ios/mobile/ios/Frameworks/mobile_bridge/Headers/mobile_bridge.h
================


================
File: ios/mobile/ios/Frameworks/mobile_bridge/Modules/module.modulemap
================
framework module mobile_bridge {
    header "mobile_bridge.h"
    export *
}

================
File: ios/mobile/ios/Frameworks/mobile_bridge/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleExecutable</key>
    <string>mobile_bridge</string>
    <key>CFBundleIdentifier</key>
    <string>com.comacode.mobile_bridge</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>mobile_bridge</string>
    <key>CFBundlePackageType</key>
    <string>FMWK</string>
</dict>
</plist>

================
File: ios/mobile/ios/Frameworks/mobile_bridge/mobile_bridge.podspec
================
Pod::Spec.new do |s|
  s.name             = 'mobile_bridge'
  s.version          = '0.1.0'
  s.summary          = 'Rust FFI bridge for Comacode mobile'
  s.homepage         = 'https://github.com/comacode/comacode'
  s.license          = { :type => 'MIT' }
  s.author           = { 'Comacode Team' => 'dev@comacode.com' }
  s.source           = { :path => '.' }
  s.ios.deployment_target = '13.0'
  s.vendored_libraries = 'libmobile_bridge.a'
end

================
File: ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

================
File: ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

================
File: ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.

================
File: ios/Runner/Base.lproj/LaunchScreen.storyboard
================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>

================
File: ios/Runner/Base.lproj/Main.storyboard
================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>

================
File: ios/Runner/AppDelegate.swift
================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

================
File: ios/Runner/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Comacode</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>comacode</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
	<key>NSCameraUsageDescription</key>
	<string>This app needs camera access to scan QR codes for host pairing.</string>
	<key>NSMicrophoneUsageDescription</key>
	<string>This app needs microphone access for voice input to Claude Code.</string>
	<key>NSSpeechRecognitionUsageDescription</key>
	<string>This app needs speech recognition for dictation when coding with Claude.</string>
</dict>
</plist>

================
File: ios/Runner/Runner-Bridging-Header.h
================
#import "GeneratedPluginRegistrant.h"

================
File: ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

================
File: ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>

================
File: ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

================
File: ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
               BuildableName = "Runner.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C8080294A63A400263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: ios/Runner.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		4FA4DB9E2F20DD3300AEA1B1 /* libmobile_bridge.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 4FA4DB9D2F20DD1A00AEA1B1 /* libmobile_bridge.a */; };
		7224DDFCFC6646650A29EACA /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = E9E9D914E4F2648E6B982E7B /* Pods_RunnerTests.framework */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
		FACFEE6F91227545C6B12AB4 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 9466E47862B680D5A419EF8F /* Pods_Runner.framework */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		4568C60E30682B474BBB1789 /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
		4EF49BEF74A7B837E0DD8D06 /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
		4FA4DB9D2F20DD1A00AEA1B1 /* libmobile_bridge.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libmobile_bridge.a; path = Frameworks/libmobile_bridge.a; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9466E47862B680D5A419EF8F /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		DBF809A9BE16D9F4D1D22163 /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
		E61FAF48C7EB9CAB130BDA4F /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
		E9E9D914E4F2648E6B982E7B /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		F48064BA47A737AE5F4A4372 /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
		FECB14E8CDCE3F96F840FA5F /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		034CAE489F89A868B578D398 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				7224DDFCFC6646650A29EACA /* Pods_RunnerTests.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				4FA4DB9E2F20DD3300AEA1B1 /* libmobile_bridge.a in Frameworks */,
				FACFEE6F91227545C6B12AB4 /* Pods_Runner.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		1139AFC4E080E2B590933DC3 /* Pods */ = {
			isa = PBXGroup;
			children = (
				4568C60E30682B474BBB1789 /* Pods-Runner.debug.xcconfig */,
				4EF49BEF74A7B837E0DD8D06 /* Pods-Runner.release.xcconfig */,
				FECB14E8CDCE3F96F840FA5F /* Pods-Runner.profile.xcconfig */,
				F48064BA47A737AE5F4A4372 /* Pods-RunnerTests.debug.xcconfig */,
				DBF809A9BE16D9F4D1D22163 /* Pods-RunnerTests.release.xcconfig */,
				E61FAF48C7EB9CAB130BDA4F /* Pods-RunnerTests.profile.xcconfig */,
			);
			path = Pods;
			sourceTree = "<group>";
		};
		1DCAEE256ED430593F4146C6 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				4FA4DB9D2F20DD1A00AEA1B1 /* libmobile_bridge.a */,
				9466E47862B680D5A419EF8F /* Pods_Runner.framework */,
				E9E9D914E4F2648E6B982E7B /* Pods_RunnerTests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
				1139AFC4E080E2B590933DC3 /* Pods */,
				1DCAEE256ED430593F4146C6 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				64F7AB1418F39ED671BD4DE0 /* [CP] Check Pods Manifest.lock */,
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
				034CAE489F89A868B578D398 /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				F2A3CCEEBB0F54B086D9DC16 /* [CP] Check Pods Manifest.lock */,
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				BC376A97DB0059BAFCDFD7C6 /* [CP] Copy Pods Resources */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		64F7AB1418F39ED671BD4DE0 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
		BC376A97DB0059BAFCDFD7C6 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Copy Pods Resources";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
		F2A3CCEEBB0F54B086D9DC16 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEAD_CODE_STRIPPING = NO;
				DEVELOPMENT_TEAM = DH5T224RD8;
				ENABLE_BITCODE = NO;
				FRAMEWORK_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-l\"c++\"",
					"-l\"sqlite3\"",
					"-l\"z\"",
					"-framework",
					"\"AVFoundation\"",
					"-framework",
					"\"Accelerate\"",
					"-framework",
					"\"CoreGraphics\"",
					"-framework",
					"\"CoreImage\"",
					"-framework",
					"\"CoreMedia\"",
					"-framework",
					"\"CoreTelephony\"",
					"-framework",
					"\"CoreVideo\"",
					"-framework",
					"\"FBLPromises\"",
					"-framework",
					"\"Foundation\"",
					"-framework",
					"\"GTMSessionFetcher\"",
					"-framework",
					"\"GoogleDataTransport\"",
					"-framework",
					"\"GoogleToolboxForMac\"",
					"-framework",
					"\"GoogleUtilities\"",
					"-framework",
					"\"GoogleUtilitiesComponents\"",
					"-framework",
					"\"LocalAuthentication\"",
					"-framework",
					"\"MLImage\"",
					"-framework",
					"\"MLKitBarcodeScanning\"",
					"-framework",
					"\"MLKitCommon\"",
					"-framework",
					"\"MLKitVision\"",
					"-framework",
					"\"Security\"",
					"-framework",
					"\"SystemConfiguration\"",
					"-framework",
					"\"UIKit\"",
					"-framework",
					"\"connectivity_plus\"",
					"-framework",
					"\"flutter_secure_storage\"",
					"-framework",
					"\"integration_test\"",
					"-framework",
					"\"mobile_scanner\"",
					"-framework",
					"\"nanopb\"",
					"-framework",
					"\"package_info_plus\"",
					"-framework",
					"\"path_provider_foundation\"",
					"-framework",
					"\"permission_handler_apple\"",
					"-framework",
					"\"shared_preferences_foundation\"",
					"-framework",
					"\"wakelock_plus\"",
					"-force_load",
					"$(SRCROOT)/Frameworks/libmobile_bridge.a",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = F48064BA47A737AE5F4A4372 /* Pods-RunnerTests.debug.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = DBF809A9BE16D9F4D1D22163 /* Pods-RunnerTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = E61FAF48C7EB9CAB130BDA4F /* Pods-RunnerTests.profile.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEAD_CODE_STRIPPING = NO;
				DEVELOPMENT_TEAM = DH5T224RD8;
				ENABLE_BITCODE = NO;
				FRAMEWORK_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-l\"c++\"",
					"-l\"sqlite3\"",
					"-l\"z\"",
					"-framework",
					"\"AVFoundation\"",
					"-framework",
					"\"Accelerate\"",
					"-framework",
					"\"CoreGraphics\"",
					"-framework",
					"\"CoreImage\"",
					"-framework",
					"\"CoreMedia\"",
					"-framework",
					"\"CoreTelephony\"",
					"-framework",
					"\"CoreVideo\"",
					"-framework",
					"\"FBLPromises\"",
					"-framework",
					"\"Foundation\"",
					"-framework",
					"\"GTMSessionFetcher\"",
					"-framework",
					"\"GoogleDataTransport\"",
					"-framework",
					"\"GoogleToolboxForMac\"",
					"-framework",
					"\"GoogleUtilities\"",
					"-framework",
					"\"GoogleUtilitiesComponents\"",
					"-framework",
					"\"LocalAuthentication\"",
					"-framework",
					"\"MLImage\"",
					"-framework",
					"\"MLKitBarcodeScanning\"",
					"-framework",
					"\"MLKitCommon\"",
					"-framework",
					"\"MLKitVision\"",
					"-framework",
					"\"Security\"",
					"-framework",
					"\"SystemConfiguration\"",
					"-framework",
					"\"UIKit\"",
					"-framework",
					"\"connectivity_plus\"",
					"-framework",
					"\"flutter_secure_storage\"",
					"-framework",
					"\"integration_test\"",
					"-framework",
					"\"mobile_scanner\"",
					"-framework",
					"\"nanopb\"",
					"-framework",
					"\"package_info_plus\"",
					"-framework",
					"\"path_provider_foundation\"",
					"-framework",
					"\"permission_handler_apple\"",
					"-framework",
					"\"shared_preferences_foundation\"",
					"-framework",
					"\"wakelock_plus\"",
					"-force_load",
					"$(SRCROOT)/Frameworks/libmobile_bridge.a",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEAD_CODE_STRIPPING = NO;
				DEVELOPMENT_TEAM = DH5T224RD8;
				ENABLE_BITCODE = NO;
				FRAMEWORK_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				OTHER_LDFLAGS = (
					"$(inherited)",
					"-ObjC",
					"-l\"c++\"",
					"-l\"sqlite3\"",
					"-l\"z\"",
					"-framework",
					"\"AVFoundation\"",
					"-framework",
					"\"Accelerate\"",
					"-framework",
					"\"CoreGraphics\"",
					"-framework",
					"\"CoreImage\"",
					"-framework",
					"\"CoreMedia\"",
					"-framework",
					"\"CoreTelephony\"",
					"-framework",
					"\"CoreVideo\"",
					"-framework",
					"\"FBLPromises\"",
					"-framework",
					"\"Foundation\"",
					"-framework",
					"\"GTMSessionFetcher\"",
					"-framework",
					"\"GoogleDataTransport\"",
					"-framework",
					"\"GoogleToolboxForMac\"",
					"-framework",
					"\"GoogleUtilities\"",
					"-framework",
					"\"GoogleUtilitiesComponents\"",
					"-framework",
					"\"LocalAuthentication\"",
					"-framework",
					"\"MLImage\"",
					"-framework",
					"\"MLKitBarcodeScanning\"",
					"-framework",
					"\"MLKitCommon\"",
					"-framework",
					"\"MLKitVision\"",
					"-framework",
					"\"Security\"",
					"-framework",
					"\"SystemConfiguration\"",
					"-framework",
					"\"UIKit\"",
					"-framework",
					"\"connectivity_plus\"",
					"-framework",
					"\"flutter_secure_storage\"",
					"-framework",
					"\"integration_test\"",
					"-framework",
					"\"mobile_scanner\"",
					"-framework",
					"\"nanopb\"",
					"-framework",
					"\"package_info_plus\"",
					"-framework",
					"\"path_provider_foundation\"",
					"-framework",
					"\"permission_handler_apple\"",
					"-framework",
					"\"shared_preferences_foundation\"",
					"-framework",
					"\"wakelock_plus\"",
					"-force_load",
					"$(SRCROOT)/Frameworks/libmobile_bridge.a",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}

================
File: ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

================
File: ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>

================
File: ios/Runner.xcworkspace/contents.xcworkspacedata
================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>

================
File: ios/RunnerTests/RunnerTests.swift
================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}

================
File: ios/.gitignore
================
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3

================
File: ios/Podfile
================
# Uncomment this line to define a global platform for your project
platform :ios, '13.0'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure flutter pub get is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Generated.xcconfig, then run flutter pub get"
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  use_frameworks! :linkage => :static
  # mobile_bridge static library linked manually

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)

    # Fix: Xcode 15+ requires iOS 12.0+, set all Pods to 13.0 minimum
    target.build_configurations.each do |config|
      if config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'].to_f < 13.0
        config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '13.0'
      end
    end
  end
end

================
File: ios/Podfile.lock
================
PODS:
  - connectivity_plus (0.0.1):
    - Flutter
  - Flutter (1.0.0)
  - flutter_secure_storage (6.0.0):
    - Flutter
  - GoogleDataTransport (9.4.1):
    - GoogleUtilities/Environment (~> 7.7)
    - nanopb (< 2.30911.0, >= 2.30908.0)
    - PromisesObjC (< 3.0, >= 1.2)
  - GoogleMLKit/BarcodeScanning (4.0.0):
    - GoogleMLKit/MLKitCore
    - MLKitBarcodeScanning (~> 3.0.0)
  - GoogleMLKit/MLKitCore (4.0.0):
    - MLKitCommon (~> 9.0.0)
  - GoogleToolboxForMac/DebugUtils (2.3.2):
    - GoogleToolboxForMac/Defines (= 2.3.2)
  - GoogleToolboxForMac/Defines (2.3.2)
  - GoogleToolboxForMac/Logger (2.3.2):
    - GoogleToolboxForMac/Defines (= 2.3.2)
  - "GoogleToolboxForMac/NSData+zlib (2.3.2)":
    - GoogleToolboxForMac/Defines (= 2.3.2)
  - "GoogleToolboxForMac/NSDictionary+URLArguments (2.3.2)":
    - GoogleToolboxForMac/DebugUtils (= 2.3.2)
    - GoogleToolboxForMac/Defines (= 2.3.2)
    - "GoogleToolboxForMac/NSString+URLArguments (= 2.3.2)"
  - "GoogleToolboxForMac/NSString+URLArguments (2.3.2)"
  - GoogleUtilities/Environment (7.13.3):
    - GoogleUtilities/Privacy
    - PromisesObjC (< 3.0, >= 1.2)
  - GoogleUtilities/Logger (7.13.3):
    - GoogleUtilities/Environment
    - GoogleUtilities/Privacy
  - GoogleUtilities/Privacy (7.13.3)
  - GoogleUtilities/UserDefaults (7.13.3):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - GoogleUtilitiesComponents (1.1.0):
    - GoogleUtilities/Logger
  - GTMSessionFetcher/Core (2.3.0)
  - haptic_feedback (0.4.2):
    - Flutter
  - integration_test (0.0.1):
    - Flutter
  - MLImage (1.0.0-beta4)
  - MLKitBarcodeScanning (3.0.0):
    - MLKitCommon (~> 9.0)
    - MLKitVision (~> 5.0)
  - MLKitCommon (9.0.0):
    - GoogleDataTransport (~> 9.0)
    - GoogleToolboxForMac/Logger (~> 2.1)
    - "GoogleToolboxForMac/NSData+zlib (~> 2.1)"
    - "GoogleToolboxForMac/NSDictionary+URLArguments (~> 2.1)"
    - GoogleUtilities/UserDefaults (~> 7.0)
    - GoogleUtilitiesComponents (~> 1.0)
    - GTMSessionFetcher/Core (< 3.0, >= 1.1)
  - MLKitVision (5.0.0):
    - GoogleToolboxForMac/Logger (~> 2.1)
    - "GoogleToolboxForMac/NSData+zlib (~> 2.1)"
    - GTMSessionFetcher/Core (< 3.0, >= 1.1)
    - MLImage (= 1.0.0-beta4)
    - MLKitCommon (~> 9.0)
  - mobile_scanner (3.5.6):
    - Flutter
    - GoogleMLKit/BarcodeScanning (~> 4.0.0)
  - nanopb (2.30910.0):
    - nanopb/decode (= 2.30910.0)
    - nanopb/encode (= 2.30910.0)
  - nanopb/decode (2.30910.0)
  - nanopb/encode (2.30910.0)
  - package_info_plus (0.4.5):
    - Flutter
  - path_provider_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - permission_handler_apple (9.3.0):
    - Flutter
  - PromisesObjC (2.4.0)
  - shared_preferences_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - speech_to_text (0.0.1):
    - Flutter
    - Try
  - Try (2.1.1)
  - wakelock_plus (0.0.1):
    - Flutter

DEPENDENCIES:
  - connectivity_plus (from `.symlinks/plugins/connectivity_plus/ios`)
  - Flutter (from `Flutter`)
  - flutter_secure_storage (from `.symlinks/plugins/flutter_secure_storage/ios`)
  - haptic_feedback (from `.symlinks/plugins/haptic_feedback/ios`)
  - integration_test (from `.symlinks/plugins/integration_test/ios`)
  - mobile_scanner (from `.symlinks/plugins/mobile_scanner/ios`)
  - package_info_plus (from `.symlinks/plugins/package_info_plus/ios`)
  - path_provider_foundation (from `.symlinks/plugins/path_provider_foundation/darwin`)
  - permission_handler_apple (from `.symlinks/plugins/permission_handler_apple/ios`)
  - shared_preferences_foundation (from `.symlinks/plugins/shared_preferences_foundation/darwin`)
  - speech_to_text (from `.symlinks/plugins/speech_to_text/ios`)
  - wakelock_plus (from `.symlinks/plugins/wakelock_plus/ios`)

SPEC REPOS:
  trunk:
    - GoogleDataTransport
    - GoogleMLKit
    - GoogleToolboxForMac
    - GoogleUtilities
    - GoogleUtilitiesComponents
    - GTMSessionFetcher
    - MLImage
    - MLKitBarcodeScanning
    - MLKitCommon
    - MLKitVision
    - nanopb
    - PromisesObjC
    - Try

EXTERNAL SOURCES:
  connectivity_plus:
    :path: ".symlinks/plugins/connectivity_plus/ios"
  Flutter:
    :path: Flutter
  flutter_secure_storage:
    :path: ".symlinks/plugins/flutter_secure_storage/ios"
  haptic_feedback:
    :path: ".symlinks/plugins/haptic_feedback/ios"
  integration_test:
    :path: ".symlinks/plugins/integration_test/ios"
  mobile_scanner:
    :path: ".symlinks/plugins/mobile_scanner/ios"
  package_info_plus:
    :path: ".symlinks/plugins/package_info_plus/ios"
  path_provider_foundation:
    :path: ".symlinks/plugins/path_provider_foundation/darwin"
  permission_handler_apple:
    :path: ".symlinks/plugins/permission_handler_apple/ios"
  shared_preferences_foundation:
    :path: ".symlinks/plugins/shared_preferences_foundation/darwin"
  speech_to_text:
    :path: ".symlinks/plugins/speech_to_text/ios"
  wakelock_plus:
    :path: ".symlinks/plugins/wakelock_plus/ios"

SPEC CHECKSUMS:
  connectivity_plus: cb623214f4e1f6ef8fe7403d580fdad517d2f7dd
  Flutter: cabc95a1d2626b1b06e7179b784ebcf0c0cde467
  flutter_secure_storage: 1ed9476fba7e7a782b22888f956cce43e2c62f13
  GoogleDataTransport: 6c09b596d841063d76d4288cc2d2f42cc36e1e2a
  GoogleMLKit: 2bd0dc6253c4d4f227aad460f69215a504b2980e
  GoogleToolboxForMac: 8bef7c7c5cf7291c687cf5354f39f9db6399ad34
  GoogleUtilities: ea963c370a38a8069cc5f7ba4ca849a60b6d7d15
  GoogleUtilitiesComponents: 679b2c881db3b615a2777504623df6122dd20afe
  GTMSessionFetcher: 3a63d75eecd6aa32c2fc79f578064e1214dfdec2
  haptic_feedback: 6d9ff6a70a5ca4ef470fbc5903c9c6c8d495d861
  integration_test: 4a889634ef21a45d28d50d622cf412dc6d9f586e
  MLImage: 7bb7c4264164ade9bf64f679b40fb29c8f33ee9b
  MLKitBarcodeScanning: 04e264482c5f3810cb89ebc134ef6b61e67db505
  MLKitCommon: c1b791c3e667091918d91bda4bba69a91011e390
  MLKitVision: 8baa5f46ee3352614169b85250574fde38c36f49
  mobile_scanner: b67191637a5ea7ba15652ca208069d2bae1900ab
  nanopb: 438bc412db1928dac798aa6fd75726007be04262
  package_info_plus: af8e2ca6888548050f16fa2f1938db7b5a5df499
  path_provider_foundation: bb55f6dbba17d0dccd6737fe6f7f34fbd0376880
  permission_handler_apple: 4ed2196e43d0651e8ff7ca3483a069d469701f2d
  PromisesObjC: f5707f49cb48b9636751c5b2e7d227e43fba9f47
  shared_preferences_foundation: 7036424c3d8ec98dfe75ff1667cb0cd531ec82bb
  speech_to_text: ae2abc312e619ff1c53e675a9fc4d785a15c03bb
  Try: 5ef669ae832617b3cee58cb2c6f99fb767a4ff96
  wakelock_plus: e29112ab3ef0b318e58cfa5c32326458be66b556

PODFILE CHECKSUM: 2f99dc2f0ee276da0f7fd2b7d049823c38cfbcf6

COCOAPODS: 1.16.2

================
File: lib/bridge/api.dart
================
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_client`, `init_crypto_provider`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Connect to remote host
///
/// This is the main FFI entry point for Flutter app.
/// Call this after scanning QR code to get connection parameters.
///
/// # Arguments
/// * `host` - Server IP address
/// * `port` - QUIC server port
/// * `auth_token` - Authentication token from QR scan
/// * `fingerprint` - Certificate fingerprint for TOFU verification
///
/// # Behavior
/// - If already connected: Returns error (call disconnect first)
/// - On success: Stores client for subsequent operations
Future<void> connectToHost({
  required String host,
  required int port,
  required String authToken,
  required String fingerprint,
}) => RustLib.instance.api.crateApiConnectToHost(
  host: host,
  port: port,
  authToken: authToken,
  fingerprint: fingerprint,
);

/// Receive next terminal event from server
///
/// Call this in a loop to stream terminal output.
/// Returns when a new event is available.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<TerminalEvent> receiveTerminalEvent() =>
    RustLib.instance.api.crateApiReceiveTerminalEvent();

/// Send command to remote terminal
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> sendTerminalCommand({required String command}) =>
    RustLib.instance.api.crateApiSendTerminalCommand(command: command);

/// Send raw input bytes to remote terminal (pure passthrough)
///
/// Phase 08: Send raw keystrokes directly to PTY without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
///
/// # Arguments
/// * `data` - Raw bytes from stdin (including control chars like 0x03 for Ctrl+C)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> sendRawInput({required List<int> data}) =>
    RustLib.instance.api.crateApiSendRawInput(data: data);

/// Resize PTY (for screen rotation support)
///
/// Phase 06: Send resize event to update PTY size on server.
/// Call this when device orientation changes.
///
/// # Arguments
/// * `rows` - Number of rows (characters per column)
/// * `cols` - Number of columns (characters per row)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> resizePty({required int rows, required int cols}) =>
    RustLib.instance.api.crateApiResizePty(rows: rows, cols: cols);

/// Disconnect from host
///
/// Clears the client, allowing reconnect.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> disconnectFromHost() =>
    RustLib.instance.api.crateApiDisconnectFromHost();

/// Check if connected
///
/// Returns false if client not initialized or disconnected.
Future<bool> isConnected() => RustLib.instance.api.crateApiIsConnected();

/// Create a new terminal command
TerminalCommand createCommand({required String text}) =>
    RustLib.instance.api.crateApiCreateCommand(text: text);

/// Get command ID
BigInt getCommandId({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiGetCommandId(cmd: cmd);

/// Get command text
String getCommandText({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiGetCommandText(cmd: cmd);

/// Get command timestamp
BigInt getCommandTimestamp({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiGetCommandTimestamp(cmd: cmd);

/// Encode terminal command to bytes for network transmission
Future<Uint8List> encodeCommand({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiEncodeCommand(cmd: cmd);

/// Encode raw input bytes for network transmission (pure passthrough)
///
/// Phase 08: Encode raw keystrokes without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
Future<Uint8List> encodeInput({required List<int> data}) =>
    RustLib.instance.api.crateApiEncodeInput(data: data);

/// Encode ping message
Future<Uint8List> encodePing() => RustLib.instance.api.crateApiEncodePing();

/// Encode resize message
Future<Uint8List> encodeResize({required int rows, required int cols}) =>
    RustLib.instance.api.crateApiEncodeResize(rows: rows, cols: cols);

/// Decode network message from bytes
Future<String> decodeMessage({required List<int> data}) =>
    RustLib.instance.api.crateApiDecodeMessage(data: data);

/// Create terminal config with custom size
TerminalConfig createTerminalConfig({required int rows, required int cols}) =>
    RustLib.instance.api.crateApiCreateTerminalConfig(rows: rows, cols: cols);

/// Parse QR payload JSON string
Future<QrPayload> parseQrPayload({required String json}) =>
    RustLib.instance.api.crateApiParseQrPayload(json: json);

/// Get QR payload fields
String getQrIp({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrIp(payload: payload);

int getQrPort({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrPort(payload: payload);

String getQrFingerprint({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrFingerprint(payload: payload);

String getQrToken({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrToken(payload: payload);

int getQrProtocolVersion({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrProtocolVersion(payload: payload);

/// Create output event from bytes
TerminalEvent eventOutput({required List<int> data}) =>
    RustLib.instance.api.crateApiEventOutput(data: data);

/// Create output event from string
TerminalEvent eventOutputStr({required String s}) =>
    RustLib.instance.api.crateApiEventOutputStr(s: s);

/// Get event data (for Output events)
Uint8List getEventData({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiGetEventData(event: event);

/// Get event error message (for Error events)
String getEventErrorMessage({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiGetEventErrorMessage(event: event);

/// Get event exit code (for Exit events)
int getEventExitCode({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiGetEventExitCode(event: event);

/// Check if event is Output
bool isEventOutput({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiIsEventOutput(event: event);

/// Check if event is Error
bool isEventError({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiIsEventError(event: event);

/// Check if event is Exit
bool isEventExit({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiIsEventExit(event: event);

/// Request directory listing from server
///
/// Sends ListDir message. Server responds with multiple DirChunk messages.
/// Call receive_dir_chunk() in a loop to receive all chunks.
///
/// # Arguments
/// * `path` - Absolute path to list (e.g., "/tmp", "/home/user")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestListDir({required String path}) =>
    RustLib.instance.api.crateApiRequestListDir(path: path);

/// Receive next directory chunk from server (NON-BLOCKING)
///
/// Returns a chunk with entries. Call repeatedly until has_more is false.
/// Returns None if no chunks available yet (server still processing).
///
/// # Returns
/// * `Some((chunk_index, entries, has_more))` - Chunk received
/// * `None` - No chunks available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<(int, List<DirEntry>, bool)?> receiveDirChunk() =>
    RustLib.instance.api.crateApiReceiveDirChunk();

/// Stream directory entries incrementally (zero-polling API)
///
/// This is the RECOMMENDED method for directory listing.
/// Returns a Stream&lt;List&lt;VfsEntry&gt;&gt; that emits chunks as they arrive.
///
/// Usage in Dart:
/// ```dart
/// final stream = streamListDir(path: '/');
/// await for (final chunk in stream) {
///   entries.addAll(chunk);
/// }
/// ```
///
/// # Implementation
/// Uses internal polling (20ms interval, 3s timeout) but exposed as
/// clean Stream API to Dart. Each chunk is emitted as it arrives.
Stream<List<DirEntry>> streamListDir({required String path}) =>
    RustLib.instance.api.crateApiStreamListDir(path: path);

/// Get entry name
String getDirEntryName({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryName(entry: entry);

/// Get entry path
String getDirEntryPath({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryPath(entry: entry);

/// Check if entry is a directory
bool isDirEntryDir({required DirEntry entry}) =>
    RustLib.instance.api.crateApiIsDirEntryDir(entry: entry);

/// Check if entry is a symlink
bool isDirEntrySymlink({required DirEntry entry}) =>
    RustLib.instance.api.crateApiIsDirEntrySymlink(entry: entry);

/// Get entry size (bytes)
BigInt? getDirEntrySize({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntrySize(entry: entry);

/// Get entry modified timestamp (Unix epoch seconds)
BigInt? getDirEntryModified({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryModified(entry: entry);

/// Get entry permissions string
String? getDirEntryPermissions({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryPermissions(entry: entry);

/// Request server to watch a directory for changes
///
/// Server will push FileEvent messages when files are created/modified/deleted.
/// Call receive_file_event() in a loop to receive watcher events.
///
/// # Arguments
/// * `path` - Absolute path to watch (e.g., "/tmp", "/home/user/project")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestWatchDir({required String path}) =>
    RustLib.instance.api.crateApiRequestWatchDir(path: path);

/// Request server to stop watching a directory
///
/// # Arguments
/// * `watcher_id` - ID of the watcher to stop (returned in WatchStarted event)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestUnwatchDir({required String watcherId}) =>
    RustLib.instance.api.crateApiRequestUnwatchDir(watcherId: watcherId);

/// Receive next file watcher event from server (NON-BLOCKING)
///
/// Returns watcher events (FileEvent, WatchStarted, WatchError).
/// Call repeatedly in a loop to process all events.
/// Returns None if no events available yet.
///
/// # Returns
/// * `Some(FileWatcherEventData)` - Event received
/// * `None` - No events available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<FileWatcherEventData?> receiveFileEvent() =>
    RustLib.instance.api.crateApiReceiveFileEvent();

/// Get file event buffer length (for monitoring)
///
/// Returns number of buffered events waiting to be processed.
Future<BigInt> fileEventBufferLen() =>
    RustLib.instance.api.crateApiFileEventBufferLen();

/// Simple add function for testing FFI
int add({required int a, required int b}) =>
    RustLib.instance.api.crateApiAdd(a: a, b: b);

/// Greeting function for testing FFI
String greet({required String name}) =>
    RustLib.instance.api.crateApiGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>
abstract class DirEntry implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>
abstract class QrPayload implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>
abstract class TerminalCommand implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>
abstract class TerminalEvent implements RustOpaqueInterface {}

/// File watcher event data (for Dart)
class FileWatcherEventData {
  /// Event type: "file", "started", or "error"
  final String eventType;

  /// Watcher ID (for started/error events)
  final String watcherId;

  /// File path (for file events)
  final String path;

  /// File event type: "created", "modified", "deleted", "renamed"
  final String fileEventType;

  /// Old name (for rename events only)
  final String oldName;

  /// Event timestamp (Unix epoch seconds)
  final BigInt timestamp;

  /// Error message (for error events only)
  final String error;

  const FileWatcherEventData({
    required this.eventType,
    required this.watcherId,
    required this.path,
    required this.fileEventType,
    required this.oldName,
    required this.timestamp,
    required this.error,
  });

  static Future<FileWatcherEventData> default_() =>
      RustLib.instance.api.crateApiFileWatcherEventDataDefault();

  @override
  int get hashCode =>
      eventType.hashCode ^
      watcherId.hashCode ^
      path.hashCode ^
      fileEventType.hashCode ^
      oldName.hashCode ^
      timestamp.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileWatcherEventData &&
          runtimeType == other.runtimeType &&
          eventType == other.eventType &&
          watcherId == other.watcherId &&
          path == other.path &&
          fileEventType == other.fileEventType &&
          oldName == other.oldName &&
          timestamp == other.timestamp &&
          error == other.error;
}

/// Terminal configuration for Flutter
class TerminalConfig {
  final int rows;
  final int cols;
  final String shell;

  const TerminalConfig({
    required this.rows,
    required this.cols,
    required this.shell,
  });

  static Future<TerminalConfig> default_() =>
      RustLib.instance.api.crateApiTerminalConfigDefault();

  @override
  int get hashCode => rows.hashCode ^ cols.hashCode ^ shell.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TerminalConfig &&
          runtimeType == other.runtimeType &&
          rows == other.rows &&
          cols == other.cols &&
          shell == other.shell;
}

================
File: lib/bridge/bridge_wrapper.dart
================
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:riverpod/riverpod.dart';
import 'ffi_helpers.dart';
import '../models/dir_entry.dart';
import 'api.dart' as frb_api;

part 'bridge_wrapper.g.dart';

/// Riverpod provider cho BridgeWrapper
///
/// Phase 06: Refactor from static methods to provider pattern
///  d test v integrate vi Riverpod state management
@riverpod
BridgeWrapper bridgeWrapper(Ref ref) {
  return BridgeWrapper();
}

/// Flutter Rust Bridge wrapper
///
/// Wrapper around FRB-generated functions with error handling
/// v instance methods (khng static)  d test/mock
class BridgeWrapper {
  /// Connect to remote host
  ///
  /// Uses QUIC protocol vi TOFU fingerprint verification
  Future<void> connect({
    required String host,
    required int port,
    required String token,
    required String fingerprint,
  }) async {
    try {
      await frb_api.connectToHost(
        host: host,
        port: port,
        authToken: token,
        fingerprint: fingerprint,
      );
    } catch (e) {
      throw Exception('Connection failed: $e');
    }
  }

  /// Send command to remote terminal
  Future<void> sendCommand(String command) async {
    try {
      debugPrint(' [BridgeWrapper] sendCommand called: "$command"');
      await frb_api.sendTerminalCommand(command: command);
      debugPrint(' [BridgeWrapper] sendCommand completed');
    } catch (e) {
      debugPrint(' [BridgeWrapper] sendCommand error: $e');
      throw Exception('Send command failed: $e');
    }
  }

  /// Resize PTY (for screen rotation support)
  ///
  /// Phase 06: Critical for screen rotation
  /// Send resize event to server  update PTY size
  Future<void> resizePty({required int rows, required int cols}) async {
    try {
      await frb_api.resizePty(rows: rows, cols: cols);
    } catch (e) {
      throw Exception('Resize failed: $e');
    }
  }

  /// Receive next terminal event from server
  ///
  /// Call ny trong loop  stream terminal output
  Future<TerminalEvent> receiveEvent() async {
    try {
      return await frb_api.receiveTerminalEvent();
    } catch (e) {
      throw Exception('Receive event failed: $e');
    }
  }

  /// Disconnect from host
  Future<void> disconnect() async {
    try {
      await frb_api.disconnectFromHost();
    } catch (e) {
      throw Exception('Disconnect failed: $e');
    }
  }

  /// Check if connected
  Future<bool> isConnected() async {
    try {
      return await frb_api.isConnected();
    } catch (e) {
      return false;
    }
  }

  // ===== VFS (Virtual File System) Methods =====

  /// List directory entries from remote server using Stream API
  ///
  /// Phase VFS-Fix: Stream now properly awaits all data before emitting.
  /// The Rust side collects all entries, then sends single chunk.
  /// This fixes the race condition where onDone fired before onData.
  ///
  /// Returns a Stream that emits a single chunk with all entries.
  Stream<List<VfsEntry>> listDirectory(String path) {
    debugPrint(' [BridgeWrapper] listDirectory: $path');
    // Map DirEntry  VfsEntry
    return frb_api.streamListDir(path: path).map(
      (dirEntries) => dirEntries.map((e) => VfsEntry.fromFrb(e)).toList(),
    );
  }

  /// Parse QR payload from JSON string
  ///
  /// Parses QR code content to get connection details
  Future<QrPayload> parseQrPayload(String json) async {
    try {
      return await frb_api.parseQrPayload(json: json);
    } catch (e) {
      throw Exception('Invalid QR payload: $e');
    }
  }

  // ===== Session Management (Phase 05) =====
  // Note: FRB bindings not regenerated yet, using placeholder implementation
  // TODO: Replace with actual FRB calls when bindings are updated

  /// Create new session on backend
  Future<void> createSession({
    required String projectPath,
    required String sessionId,
  }) async {
    debugPrint(' [BridgeWrapper] createSession: $sessionId at $projectPath');
    // TODO: Call FRB when bindings regenerated
    // await frb_api.createSession(projectPath: projectPath, sessionId: sessionId);
  }

  /// Check if session exists (for re-attach)
  Future<bool> checkSession(String sessionId) async {
    debugPrint(' [BridgeWrapper] checkSession: $sessionId');
    // TODO: Call FRB when bindings regenerated
    // return await frb_api.checkSession(sessionId: sessionId);
    return false; // Placeholder
  }

  /// Switch active session
  Future<void> switchSession(String sessionId) async {
    debugPrint(' [BridgeWrapper] switchSession: $sessionId');
    // TODO: Call FRB when bindings regenerated
    // await frb_api.switchSession(sessionId: sessionId);
  }

  /// Close session
  Future<void> closeSession(String sessionId) async {
    debugPrint(' [BridgeWrapper] closeSession: $sessionId');
    // TODO: Call FRB when bindings regenerated
    // await frb_api.closeSession(sessionId: sessionId);
  }

  /// List all active sessions
  Future<List<String>> listSessions() async {
    debugPrint(' [BridgeWrapper] listSessions');
    // TODO: Call FRB when bindings regenerated
    // return await frb_api.listSessions();
    return []; // Placeholder
  }
}

================
File: lib/bridge/bridge_wrapper.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'bridge_wrapper.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$bridgeWrapperHash() => r'a0c7f1aeee7528c85832e4d53b5ece635d7c8860';

/// Riverpod provider cho BridgeWrapper
///
/// Phase 06: Refactor from static methods to provider pattern
///  d test v integrate vi Riverpod state management
///
/// Copied from [bridgeWrapper].
@ProviderFor(bridgeWrapper)
final bridgeWrapperProvider = AutoDisposeProvider<BridgeWrapper>.internal(
  bridgeWrapper,
  name: r'bridgeWrapperProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$bridgeWrapperHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef BridgeWrapperRef = AutoDisposeProviderRef<BridgeWrapper>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package

================
File: lib/bridge/ffi_helpers.dart
================
/// FFI helper functions for VFS and terminal events
///
/// These are convenience wrappers around the generated FFI methods.
/// Generated by flutter_rust_bridge v2.11.1.
///
/// Note: Most helper functions are now available directly from api.dart
/// This file provides compatibility layer with positional parameters.

library;

import 'api.dart' show DirEntry, TerminalEvent, QrPayload;
import 'api.dart' as frb_api;

// Export FFI types for convenience
export 'api.dart' show DirEntry, TerminalEvent, QrPayload;
export 'frb_generated.dart' show RustLib;

// ===== DirEntry Helpers =====

/// Get directory entry name
String getDirEntryName(DirEntry entry) => frb_api.getDirEntryName(entry: entry);

/// Get directory entry path
String getDirEntryPath(DirEntry entry) => frb_api.getDirEntryPath(entry: entry);

/// Check if entry is a directory
bool isDirEntryDir(DirEntry entry) => frb_api.isDirEntryDir(entry: entry);

/// Check if entry is a symlink
bool isDirEntrySymlink(DirEntry entry) =>
    frb_api.isDirEntrySymlink(entry: entry);

/// Get directory entry size
int? getDirEntrySize(DirEntry entry) =>
    frb_api.getDirEntrySize(entry: entry)?.toInt();

/// Get directory entry modified time
int? getDirEntryModified(DirEntry entry) =>
    frb_api.getDirEntryModified(entry: entry)?.toInt();

/// Get directory entry permissions
String? getDirEntryPermissions(DirEntry entry) =>
    frb_api.getDirEntryPermissions(entry: entry);

// ===== TerminalEvent Helpers =====

/// Check if event is output
bool isEventOutput(TerminalEvent event) => frb_api.isEventOutput(event: event);

/// Check if event is error
bool isEventError(TerminalEvent event) => frb_api.isEventError(event: event);

/// Check if event is exit
bool isEventExit(TerminalEvent event) => frb_api.isEventExit(event: event);

/// Get event data
List<int> getEventData(TerminalEvent event) =>
    frb_api.getEventData(event: event);

/// Get event error message
String getEventErrorMessage(TerminalEvent event) =>
    frb_api.getEventErrorMessage(event: event);

/// Get event exit code
int getEventExitCode(TerminalEvent event) =>
    frb_api.getEventExitCode(event: event);

// ===== QrPayload Helpers =====

/// Get QR IP address
String getQrIp(QrPayload payload) => frb_api.getQrIp(payload: payload);

/// Get QR port
int getQrPort(QrPayload payload) => frb_api.getQrPort(payload: payload);

/// Get QR token
String getQrToken(QrPayload payload) => frb_api.getQrToken(payload: payload);

/// Get QR fingerprint
String getQrFingerprint(QrPayload payload) =>
    frb_api.getQrFingerprint(payload: payload);

================
File: lib/bridge/frb_generated.dart
================
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1828486424;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'mobile_bridge',
        ioDirectory: '../crates/mobile_bridge/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  int crateApiAdd({required int a, required int b});

  Future<void> crateApiConnectToHost({
    required String host,
    required int port,
    required String authToken,
    required String fingerprint,
  });

  TerminalCommand crateApiCreateCommand({required String text});

  TerminalConfig crateApiCreateTerminalConfig({
    required int rows,
    required int cols,
  });

  Future<String> crateApiDecodeMessage({required List<int> data});

  Future<void> crateApiDisconnectFromHost();

  Future<Uint8List> crateApiEncodeCommand({required TerminalCommand cmd});

  Future<Uint8List> crateApiEncodeInput({required List<int> data});

  Future<Uint8List> crateApiEncodePing();

  Future<Uint8List> crateApiEncodeResize({
    required int rows,
    required int cols,
  });

  TerminalEvent crateApiEventOutput({required List<int> data});

  TerminalEvent crateApiEventOutputStr({required String s});

  Future<BigInt> crateApiFileEventBufferLen();

  Future<FileWatcherEventData> crateApiFileWatcherEventDataDefault();

  BigInt crateApiGetCommandId({required TerminalCommand cmd});

  String crateApiGetCommandText({required TerminalCommand cmd});

  BigInt crateApiGetCommandTimestamp({required TerminalCommand cmd});

  BigInt? crateApiGetDirEntryModified({required DirEntry entry});

  String crateApiGetDirEntryName({required DirEntry entry});

  String crateApiGetDirEntryPath({required DirEntry entry});

  String? crateApiGetDirEntryPermissions({required DirEntry entry});

  BigInt? crateApiGetDirEntrySize({required DirEntry entry});

  Uint8List crateApiGetEventData({required TerminalEvent event});

  String crateApiGetEventErrorMessage({required TerminalEvent event});

  int crateApiGetEventExitCode({required TerminalEvent event});

  String crateApiGetQrFingerprint({required QrPayload payload});

  String crateApiGetQrIp({required QrPayload payload});

  int crateApiGetQrPort({required QrPayload payload});

  int crateApiGetQrProtocolVersion({required QrPayload payload});

  String crateApiGetQrToken({required QrPayload payload});

  String crateApiGreet({required String name});

  Future<bool> crateApiIsConnected();

  bool crateApiIsDirEntryDir({required DirEntry entry});

  bool crateApiIsDirEntrySymlink({required DirEntry entry});

  bool crateApiIsEventError({required TerminalEvent event});

  bool crateApiIsEventExit({required TerminalEvent event});

  bool crateApiIsEventOutput({required TerminalEvent event});

  Future<QrPayload> crateApiParseQrPayload({required String json});

  Future<(int, List<DirEntry>, bool)?> crateApiReceiveDirChunk();

  Future<FileWatcherEventData?> crateApiReceiveFileEvent();

  Future<TerminalEvent> crateApiReceiveTerminalEvent();

  Future<void> crateApiRequestListDir({required String path});

  Future<void> crateApiRequestUnwatchDir({required String watcherId});

  Future<void> crateApiRequestWatchDir({required String path});

  Future<void> crateApiResizePty({required int rows, required int cols});

  Future<void> crateApiSendRawInput({required List<int> data});

  Future<void> crateApiSendTerminalCommand({required String command});

  Stream<List<DirEntry>> crateApiStreamListDir({required String path});

  Future<TerminalConfig> crateApiTerminalConfigDefault();

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DirEntry;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DirEntry;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_DirEntryPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_QrPayload;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_QrPayload;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_QrPayloadPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_TerminalCommand;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_TerminalCommand;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_TerminalCommandPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_TerminalEvent;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_TerminalEvent;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_TerminalEventPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  int crateApiAdd({required int a, required int b}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(a, serializer);
          sse_encode_i_32(b, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiAddConstMeta,
        argValues: [a, b],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiAddConstMeta =>
      const TaskConstMeta(debugName: "add", argNames: ["a", "b"]);

  @override
  Future<void> crateApiConnectToHost({
    required String host,
    required int port,
    required String authToken,
    required String fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(host, serializer);
          sse_encode_u_16(port, serializer);
          sse_encode_String(authToken, serializer);
          sse_encode_String(fingerprint, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiConnectToHostConstMeta,
        argValues: [host, port, authToken, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConnectToHostConstMeta => const TaskConstMeta(
    debugName: "connect_to_host",
    argNames: ["host", "port", "authToken", "fingerprint"],
  );

  @override
  TerminalCommand crateApiCreateCommand({required String text}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(text, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCreateCommandConstMeta,
        argValues: [text],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCreateCommandConstMeta =>
      const TaskConstMeta(debugName: "create_command", argNames: ["text"]);

  @override
  TerminalConfig crateApiCreateTerminalConfig({
    required int rows,
    required int cols,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_16(rows, serializer);
          sse_encode_u_16(cols, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_terminal_config,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCreateTerminalConfigConstMeta,
        argValues: [rows, cols],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCreateTerminalConfigConstMeta =>
      const TaskConstMeta(
        debugName: "create_terminal_config",
        argNames: ["rows", "cols"],
      );

  @override
  Future<String> crateApiDecodeMessage({required List<int> data}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(data, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 5,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiDecodeMessageConstMeta,
        argValues: [data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDecodeMessageConstMeta =>
      const TaskConstMeta(debugName: "decode_message", argNames: ["data"]);

  @override
  Future<void> crateApiDisconnectFromHost() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiDisconnectFromHostConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDisconnectFromHostConstMeta =>
      const TaskConstMeta(debugName: "disconnect_from_host", argNames: []);

  @override
  Future<Uint8List> crateApiEncodeCommand({required TerminalCommand cmd}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
            cmd,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 7,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiEncodeCommandConstMeta,
        argValues: [cmd],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEncodeCommandConstMeta =>
      const TaskConstMeta(debugName: "encode_command", argNames: ["cmd"]);

  @override
  Future<Uint8List> crateApiEncodeInput({required List<int> data}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(data, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 8,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiEncodeInputConstMeta,
        argValues: [data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEncodeInputConstMeta =>
      const TaskConstMeta(debugName: "encode_input", argNames: ["data"]);

  @override
  Future<Uint8List> crateApiEncodePing() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiEncodePingConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEncodePingConstMeta =>
      const TaskConstMeta(debugName: "encode_ping", argNames: []);

  @override
  Future<Uint8List> crateApiEncodeResize({
    required int rows,
    required int cols,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_16(rows, serializer);
          sse_encode_u_16(cols, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiEncodeResizeConstMeta,
        argValues: [rows, cols],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEncodeResizeConstMeta => const TaskConstMeta(
    debugName: "encode_resize",
    argNames: ["rows", "cols"],
  );

  @override
  TerminalEvent crateApiEventOutput({required List<int> data}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(data, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEventOutputConstMeta,
        argValues: [data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEventOutputConstMeta =>
      const TaskConstMeta(debugName: "event_output", argNames: ["data"]);

  @override
  TerminalEvent crateApiEventOutputStr({required String s}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(s, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiEventOutputStrConstMeta,
        argValues: [s],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiEventOutputStrConstMeta =>
      const TaskConstMeta(debugName: "event_output_str", argNames: ["s"]);

  @override
  Future<BigInt> crateApiFileEventBufferLen() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 13,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiFileEventBufferLenConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFileEventBufferLenConstMeta =>
      const TaskConstMeta(debugName: "file_event_buffer_len", argNames: []);

  @override
  Future<FileWatcherEventData> crateApiFileWatcherEventDataDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_file_watcher_event_data,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiFileWatcherEventDataDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiFileWatcherEventDataDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "file_watcher_event_data_default",
        argNames: [],
      );

  @override
  BigInt crateApiGetCommandId({required TerminalCommand cmd}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
            cmd,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetCommandIdConstMeta,
        argValues: [cmd],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetCommandIdConstMeta =>
      const TaskConstMeta(debugName: "get_command_id", argNames: ["cmd"]);

  @override
  String crateApiGetCommandText({required TerminalCommand cmd}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
            cmd,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetCommandTextConstMeta,
        argValues: [cmd],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetCommandTextConstMeta =>
      const TaskConstMeta(debugName: "get_command_text", argNames: ["cmd"]);

  @override
  BigInt crateApiGetCommandTimestamp({required TerminalCommand cmd}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
            cmd,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetCommandTimestampConstMeta,
        argValues: [cmd],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetCommandTimestampConstMeta =>
      const TaskConstMeta(
        debugName: "get_command_timestamp",
        argNames: ["cmd"],
      );

  @override
  BigInt? crateApiGetDirEntryModified({required DirEntry entry}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
            entry,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetDirEntryModifiedConstMeta,
        argValues: [entry],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetDirEntryModifiedConstMeta =>
      const TaskConstMeta(
        debugName: "get_dir_entry_modified",
        argNames: ["entry"],
      );

  @override
  String crateApiGetDirEntryName({required DirEntry entry}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
            entry,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetDirEntryNameConstMeta,
        argValues: [entry],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetDirEntryNameConstMeta =>
      const TaskConstMeta(debugName: "get_dir_entry_name", argNames: ["entry"]);

  @override
  String crateApiGetDirEntryPath({required DirEntry entry}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
            entry,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetDirEntryPathConstMeta,
        argValues: [entry],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetDirEntryPathConstMeta =>
      const TaskConstMeta(debugName: "get_dir_entry_path", argNames: ["entry"]);

  @override
  String? crateApiGetDirEntryPermissions({required DirEntry entry}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
            entry,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetDirEntryPermissionsConstMeta,
        argValues: [entry],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetDirEntryPermissionsConstMeta =>
      const TaskConstMeta(
        debugName: "get_dir_entry_permissions",
        argNames: ["entry"],
      );

  @override
  BigInt? crateApiGetDirEntrySize({required DirEntry entry}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
            entry,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetDirEntrySizeConstMeta,
        argValues: [entry],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetDirEntrySizeConstMeta =>
      const TaskConstMeta(debugName: "get_dir_entry_size", argNames: ["entry"]);

  @override
  Uint8List crateApiGetEventData({required TerminalEvent event}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
            event,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetEventDataConstMeta,
        argValues: [event],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetEventDataConstMeta =>
      const TaskConstMeta(debugName: "get_event_data", argNames: ["event"]);

  @override
  String crateApiGetEventErrorMessage({required TerminalEvent event}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
            event,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetEventErrorMessageConstMeta,
        argValues: [event],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetEventErrorMessageConstMeta =>
      const TaskConstMeta(
        debugName: "get_event_error_message",
        argNames: ["event"],
      );

  @override
  int crateApiGetEventExitCode({required TerminalEvent event}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
            event,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_i_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetEventExitCodeConstMeta,
        argValues: [event],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetEventExitCodeConstMeta => const TaskConstMeta(
    debugName: "get_event_exit_code",
    argNames: ["event"],
  );

  @override
  String crateApiGetQrFingerprint({required QrPayload payload}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
            payload,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetQrFingerprintConstMeta,
        argValues: [payload],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetQrFingerprintConstMeta => const TaskConstMeta(
    debugName: "get_qr_fingerprint",
    argNames: ["payload"],
  );

  @override
  String crateApiGetQrIp({required QrPayload payload}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
            payload,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetQrIpConstMeta,
        argValues: [payload],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetQrIpConstMeta =>
      const TaskConstMeta(debugName: "get_qr_ip", argNames: ["payload"]);

  @override
  int crateApiGetQrPort({required QrPayload payload}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
            payload,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_16,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetQrPortConstMeta,
        argValues: [payload],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetQrPortConstMeta =>
      const TaskConstMeta(debugName: "get_qr_port", argNames: ["payload"]);

  @override
  int crateApiGetQrProtocolVersion({required QrPayload payload}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
            payload,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetQrProtocolVersionConstMeta,
        argValues: [payload],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetQrProtocolVersionConstMeta =>
      const TaskConstMeta(
        debugName: "get_qr_protocol_version",
        argNames: ["payload"],
      );

  @override
  String crateApiGetQrToken({required QrPayload payload}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
            payload,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGetQrTokenConstMeta,
        argValues: [payload],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGetQrTokenConstMeta =>
      const TaskConstMeta(debugName: "get_qr_token", argNames: ["payload"]);

  @override
  String crateApiGreet({required String name}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGreetConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGreetConstMeta =>
      const TaskConstMeta(debugName: "greet", argNames: ["name"]);

  @override
  Future<bool> crateApiIsConnected() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsConnectedConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsConnectedConstMeta =>
      const TaskConstMeta(debugName: "is_connected", argNames: []);

  @override
  bool crateApiIsDirEntryDir({required DirEntry entry}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
            entry,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsDirEntryDirConstMeta,
        argValues: [entry],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsDirEntryDirConstMeta =>
      const TaskConstMeta(debugName: "is_dir_entry_dir", argNames: ["entry"]);

  @override
  bool crateApiIsDirEntrySymlink({required DirEntry entry}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
            entry,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsDirEntrySymlinkConstMeta,
        argValues: [entry],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsDirEntrySymlinkConstMeta => const TaskConstMeta(
    debugName: "is_dir_entry_symlink",
    argNames: ["entry"],
  );

  @override
  bool crateApiIsEventError({required TerminalEvent event}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
            event,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsEventErrorConstMeta,
        argValues: [event],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsEventErrorConstMeta =>
      const TaskConstMeta(debugName: "is_event_error", argNames: ["event"]);

  @override
  bool crateApiIsEventExit({required TerminalEvent event}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
            event,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsEventExitConstMeta,
        argValues: [event],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsEventExitConstMeta =>
      const TaskConstMeta(debugName: "is_event_exit", argNames: ["event"]);

  @override
  bool crateApiIsEventOutput({required TerminalEvent event}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
            event,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiIsEventOutputConstMeta,
        argValues: [event],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiIsEventOutputConstMeta =>
      const TaskConstMeta(debugName: "is_event_output", argNames: ["event"]);

  @override
  Future<QrPayload> crateApiParseQrPayload({required String json}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(json, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiParseQrPayloadConstMeta,
        argValues: [json],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiParseQrPayloadConstMeta =>
      const TaskConstMeta(debugName: "parse_qr_payload", argNames: ["json"]);

  @override
  Future<(int, List<DirEntry>, bool)?> crateApiReceiveDirChunk() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiReceiveDirChunkConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiReceiveDirChunkConstMeta =>
      const TaskConstMeta(debugName: "receive_dir_chunk", argNames: []);

  @override
  Future<FileWatcherEventData?> crateApiReceiveFileEvent() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 40,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_file_watcher_event_data,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiReceiveFileEventConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiReceiveFileEventConstMeta =>
      const TaskConstMeta(debugName: "receive_file_event", argNames: []);

  @override
  Future<TerminalEvent> crateApiReceiveTerminalEvent() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 41,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiReceiveTerminalEventConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiReceiveTerminalEventConstMeta =>
      const TaskConstMeta(debugName: "receive_terminal_event", argNames: []);

  @override
  Future<void> crateApiRequestListDir({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 42,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiRequestListDirConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRequestListDirConstMeta =>
      const TaskConstMeta(debugName: "request_list_dir", argNames: ["path"]);

  @override
  Future<void> crateApiRequestUnwatchDir({required String watcherId}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(watcherId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 43,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiRequestUnwatchDirConstMeta,
        argValues: [watcherId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRequestUnwatchDirConstMeta => const TaskConstMeta(
    debugName: "request_unwatch_dir",
    argNames: ["watcherId"],
  );

  @override
  Future<void> crateApiRequestWatchDir({required String path}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 44,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiRequestWatchDirConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiRequestWatchDirConstMeta =>
      const TaskConstMeta(debugName: "request_watch_dir", argNames: ["path"]);

  @override
  Future<void> crateApiResizePty({required int rows, required int cols}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_16(rows, serializer);
          sse_encode_u_16(cols, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 45,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiResizePtyConstMeta,
        argValues: [rows, cols],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiResizePtyConstMeta =>
      const TaskConstMeta(debugName: "resize_pty", argNames: ["rows", "cols"]);

  @override
  Future<void> crateApiSendRawInput({required List<int> data}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(data, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 46,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiSendRawInputConstMeta,
        argValues: [data],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSendRawInputConstMeta =>
      const TaskConstMeta(debugName: "send_raw_input", argNames: ["data"]);

  @override
  Future<void> crateApiSendTerminalCommand({required String command}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(command, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 47,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiSendTerminalCommandConstMeta,
        argValues: [command],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSendTerminalCommandConstMeta =>
      const TaskConstMeta(
        debugName: "send_terminal_command",
        argNames: ["command"],
      );

  @override
  Stream<List<DirEntry>> crateApiStreamListDir({required String path}) {
    final sink = RustStreamSink<List<DirEntry>>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_String(path, serializer);
            sse_encode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
              sink,
              serializer,
            );
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 48,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_String,
          ),
          constMeta: kCrateApiStreamListDirConstMeta,
          argValues: [path, sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiStreamListDirConstMeta => const TaskConstMeta(
    debugName: "stream_list_dir",
    argNames: ["path", "sink"],
  );

  @override
  Future<TerminalConfig> crateApiTerminalConfigDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 49,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_terminal_config,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiTerminalConfigDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiTerminalConfigDefaultConstMeta =>
      const TaskConstMeta(debugName: "terminal_config_default", argNames: []);

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_DirEntry => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_DirEntry => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_QrPayload => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_QrPayload => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_TerminalCommand => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_TerminalCommand => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_TerminalEvent => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_TerminalEvent => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  DirEntry
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DirEntryImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  QrPayload
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return QrPayloadImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TerminalCommand
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TerminalCommandImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TerminalEvent
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TerminalEventImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DirEntry
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DirEntryImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  QrPayload
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return QrPayloadImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TerminalCommand
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TerminalCommandImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TerminalEvent
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TerminalEventImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DirEntry
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DirEntryImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  QrPayload
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return QrPayloadImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TerminalCommand
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TerminalCommandImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TerminalEvent
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TerminalEventImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<List<DirEntry>>
  dco_decode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  FileWatcherEventData dco_decode_box_autoadd_file_watcher_event_data(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_file_watcher_event_data(raw);
  }

  @protected
  (int, List<DirEntry>, bool)
  dco_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as (int, List<DirEntry>, bool);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  FileWatcherEventData dco_decode_file_watcher_event_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return FileWatcherEventData(
      eventType: dco_decode_String(arr[0]),
      watcherId: dco_decode_String(arr[1]),
      path: dco_decode_String(arr[2]),
      fileEventType: dco_decode_String(arr[3]),
      oldName: dco_decode_String(arr[4]),
      timestamp: dco_decode_u_64(arr[5]),
      error: dco_decode_String(arr[6]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<DirEntry>
  dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry,
        )
        .toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  FileWatcherEventData? dco_decode_opt_box_autoadd_file_watcher_event_data(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_file_watcher_event_data(raw);
  }

  @protected
  (int, List<DirEntry>, bool)?
  dco_decode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
            raw,
          );
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  (int, List<DirEntry>, bool)
  dco_decode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_32(arr[0]),
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        arr[1],
      ),
      dco_decode_bool(arr[2]),
    );
  }

  @protected
  TerminalConfig dco_decode_terminal_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return TerminalConfig(
      rows: dco_decode_u_16(arr[0]),
      cols: dco_decode_u_16(arr[1]),
      shell: dco_decode_String(arr[2]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  DirEntry
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DirEntryImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  QrPayload
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return QrPayloadImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  TerminalCommand
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TerminalCommandImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  TerminalEvent
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TerminalEventImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  DirEntry
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DirEntryImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  QrPayload
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return QrPayloadImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  TerminalCommand
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TerminalCommandImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  TerminalEvent
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TerminalEventImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  DirEntry
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DirEntryImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  QrPayload
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return QrPayloadImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  TerminalCommand
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TerminalCommandImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  TerminalEvent
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TerminalEventImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  RustStreamSink<List<DirEntry>>
  sse_decode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  FileWatcherEventData sse_decode_box_autoadd_file_watcher_event_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_file_watcher_event_data(deserializer));
  }

  @protected
  (int, List<DirEntry>, bool)
  sse_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
      deserializer,
    ));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  FileWatcherEventData sse_decode_file_watcher_event_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_eventType = sse_decode_String(deserializer);
    var var_watcherId = sse_decode_String(deserializer);
    var var_path = sse_decode_String(deserializer);
    var var_fileEventType = sse_decode_String(deserializer);
    var var_oldName = sse_decode_String(deserializer);
    var var_timestamp = sse_decode_u_64(deserializer);
    var var_error = sse_decode_String(deserializer);
    return FileWatcherEventData(
      eventType: var_eventType,
      watcherId: var_watcherId,
      path: var_path,
      fileEventType: var_fileEventType,
      oldName: var_oldName,
      timestamp: var_timestamp,
      error: var_error,
    );
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<DirEntry>
  sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DirEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FileWatcherEventData? sse_decode_opt_box_autoadd_file_watcher_event_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_file_watcher_event_data(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (int, List<DirEntry>, bool)?
  sse_decode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
        deserializer,
      ));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (int, List<DirEntry>, bool)
  sse_decode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_32(deserializer);
    var var_field1 =
        sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
          deserializer,
        );
    var var_field2 = sse_decode_bool(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  TerminalConfig sse_decode_terminal_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_rows = sse_decode_u_16(deserializer);
    var var_cols = sse_decode_u_16(deserializer);
    var var_shell = sse_decode_String(deserializer);
    return TerminalConfig(rows: var_rows, cols: var_cols, shell: var_shell);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as DirEntryImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as QrPayloadImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TerminalCommandImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TerminalEventImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as DirEntryImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as QrPayloadImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TerminalCommandImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TerminalEventImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as DirEntryImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as QrPayloadImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TerminalCommandImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as TerminalEventImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    RustStreamSink<List<DirEntry>> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_file_watcher_event_data(
    FileWatcherEventData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_file_watcher_event_data(self, serializer);
  }

  @protected
  void
  sse_encode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
      self,
      serializer,
    );
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_file_watcher_event_data(
    FileWatcherEventData self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.eventType, serializer);
    sse_encode_String(self.watcherId, serializer);
    sse_encode_String(self.path, serializer);
    sse_encode_String(self.fileEventType, serializer);
    sse_encode_String(self.oldName, serializer);
    sse_encode_u_64(self.timestamp, serializer);
    sse_encode_String(self.error, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void
  sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    List<DirEntry> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        item,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(
      self is Uint8List ? self : Uint8List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_file_watcher_event_data(
    FileWatcherEventData? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_file_watcher_event_data(self, serializer);
    }
  }

  @protected
  void
  sse_encode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool)? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
        self,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void
  sse_encode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.$1, serializer);
    sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
      self.$2,
      serializer,
    );
    sse_encode_bool(self.$3, serializer);
  }

  @protected
  void sse_encode_terminal_config(
    TerminalConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.rows, serializer);
    sse_encode_u_16(self.cols, serializer);
    sse_encode_String(self.shell, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class DirEntryImpl extends RustOpaque implements DirEntry {
  // Not to be used by end users
  DirEntryImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DirEntryImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_DirEntry,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_DirEntry,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_DirEntryPtr,
  );
}

@sealed
class QrPayloadImpl extends RustOpaque implements QrPayload {
  // Not to be used by end users
  QrPayloadImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  QrPayloadImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_QrPayload,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_QrPayload,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_QrPayloadPtr,
  );
}

@sealed
class TerminalCommandImpl extends RustOpaque implements TerminalCommand {
  // Not to be used by end users
  TerminalCommandImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  TerminalCommandImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_TerminalCommand,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_TerminalCommand,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_TerminalCommandPtr,
  );
}

@sealed
class TerminalEventImpl extends RustOpaque implements TerminalEvent {
  // Not to be used by end users
  TerminalEventImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  TerminalEventImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_TerminalEvent,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_TerminalEvent,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_TerminalEventPtr,
  );
}

================
File: lib/bridge/frb_generated.io.dart
================
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:ffi' as ffi;
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_io.dart';

abstract class RustLibApiImplPlatform extends BaseApiImpl<RustLibWire> {
  RustLibApiImplPlatform({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_DirEntryPtr => wire
      ._rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntryPtr;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_QrPayloadPtr => wire
      ._rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayloadPtr;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_TerminalCommandPtr => wire
      ._rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommandPtr;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_TerminalEventPtr => wire
      ._rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEventPtr;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw);

  @protected
  DirEntry
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  QrPayload
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  );

  @protected
  TerminalCommand
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  );

  @protected
  TerminalEvent
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  );

  @protected
  DirEntry
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  QrPayload
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  );

  @protected
  TerminalCommand
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  );

  @protected
  TerminalEvent
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  );

  @protected
  DirEntry
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  QrPayload
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  );

  @protected
  TerminalCommand
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  );

  @protected
  TerminalEvent
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  );

  @protected
  RustStreamSink<List<DirEntry>>
  dco_decode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    dynamic raw,
  );

  @protected
  String dco_decode_String(dynamic raw);

  @protected
  bool dco_decode_bool(dynamic raw);

  @protected
  FileWatcherEventData dco_decode_box_autoadd_file_watcher_event_data(
    dynamic raw,
  );

  @protected
  (int, List<DirEntry>, bool)
  dco_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  );

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw);

  @protected
  FileWatcherEventData dco_decode_file_watcher_event_data(dynamic raw);

  @protected
  int dco_decode_i_32(dynamic raw);

  @protected
  List<DirEntry>
  dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw);

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw);

  @protected
  String? dco_decode_opt_String(dynamic raw);

  @protected
  FileWatcherEventData? dco_decode_opt_box_autoadd_file_watcher_event_data(
    dynamic raw,
  );

  @protected
  (int, List<DirEntry>, bool)?
  dco_decode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  );

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw);

  @protected
  (int, List<DirEntry>, bool)
  dco_decode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  );

  @protected
  TerminalConfig dco_decode_terminal_config(dynamic raw);

  @protected
  int dco_decode_u_16(dynamic raw);

  @protected
  int dco_decode_u_32(dynamic raw);

  @protected
  BigInt dco_decode_u_64(dynamic raw);

  @protected
  int dco_decode_u_8(dynamic raw);

  @protected
  void dco_decode_unit(dynamic raw);

  @protected
  BigInt dco_decode_usize(dynamic raw);

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer);

  @protected
  DirEntry
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  QrPayload
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  );

  @protected
  TerminalCommand
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  );

  @protected
  TerminalEvent
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  );

  @protected
  DirEntry
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  QrPayload
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  );

  @protected
  TerminalCommand
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  );

  @protected
  TerminalEvent
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  );

  @protected
  DirEntry
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  QrPayload
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  );

  @protected
  TerminalCommand
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  );

  @protected
  TerminalEvent
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  );

  @protected
  RustStreamSink<List<DirEntry>>
  sse_decode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    SseDeserializer deserializer,
  );

  @protected
  String sse_decode_String(SseDeserializer deserializer);

  @protected
  bool sse_decode_bool(SseDeserializer deserializer);

  @protected
  FileWatcherEventData sse_decode_box_autoadd_file_watcher_event_data(
    SseDeserializer deserializer,
  );

  @protected
  (int, List<DirEntry>, bool)
  sse_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  );

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  FileWatcherEventData sse_decode_file_watcher_event_data(
    SseDeserializer deserializer,
  );

  @protected
  int sse_decode_i_32(SseDeserializer deserializer);

  @protected
  List<DirEntry>
  sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer);

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer);

  @protected
  FileWatcherEventData? sse_decode_opt_box_autoadd_file_watcher_event_data(
    SseDeserializer deserializer,
  );

  @protected
  (int, List<DirEntry>, bool)?
  sse_decode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  );

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  (int, List<DirEntry>, bool)
  sse_decode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  );

  @protected
  TerminalConfig sse_decode_terminal_config(SseDeserializer deserializer);

  @protected
  int sse_decode_u_16(SseDeserializer deserializer);

  @protected
  int sse_decode_u_32(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer);

  @protected
  int sse_decode_u_8(SseDeserializer deserializer);

  @protected
  void sse_decode_unit(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer);

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    RustStreamSink<List<DirEntry>> self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_String(String self, SseSerializer serializer);

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_file_watcher_event_data(
    FileWatcherEventData self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool) self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_file_watcher_event_data(
    FileWatcherEventData self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer);

  @protected
  void
  sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    List<DirEntry> self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_file_watcher_event_data(
    FileWatcherEventData? self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool)? self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer);

  @protected
  void
  sse_encode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool) self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_terminal_config(
    TerminalConfig self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer);

  @protected
  void sse_encode_unit(void self, SseSerializer serializer);

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer);
}

// Section: wire_class

class RustLibWire implements BaseWire {
  factory RustLibWire.fromExternalLibrary(ExternalLibrary lib) =>
      RustLibWire(lib.ffiDynamicLibrary);

  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RustLibWire(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
      ptr,
    );
  }

  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry',
      );
  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry =
      _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntryPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
      ptr,
    );
  }

  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry',
      );
  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry =
      _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntryPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
      ptr,
    );
  }

  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayloadPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload',
      );
  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload =
      _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayloadPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
      ptr,
    );
  }

  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayloadPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload',
      );
  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload =
      _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayloadPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
      ptr,
    );
  }

  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand',
      );
  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand =
      _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommandPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
      ptr,
    );
  }

  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand',
      );
  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand =
      _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommandPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
      ptr,
    );
  }

  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent',
      );
  late final _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent =
      _rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEventPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
      ptr,
    );
  }

  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEventPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent',
      );
  late final _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent =
      _rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEventPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

================
File: lib/bridge/frb_generated.web.dart
================
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

// Static analysis wrongly picks the IO variant, thus ignore this
// ignore_for_file: argument_type_not_assignable

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_web.dart';

abstract class RustLibApiImplPlatform extends BaseApiImpl<RustLibWire> {
  RustLibApiImplPlatform({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_DirEntryPtr => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_QrPayloadPtr => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_TerminalCommandPtr => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_TerminalEventPtr => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw);

  @protected
  DirEntry
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  QrPayload
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  );

  @protected
  TerminalCommand
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  );

  @protected
  TerminalEvent
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  );

  @protected
  DirEntry
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  QrPayload
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  );

  @protected
  TerminalCommand
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  );

  @protected
  TerminalEvent
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  );

  @protected
  DirEntry
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  QrPayload
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    dynamic raw,
  );

  @protected
  TerminalCommand
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    dynamic raw,
  );

  @protected
  TerminalEvent
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    dynamic raw,
  );

  @protected
  RustStreamSink<List<DirEntry>>
  dco_decode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    dynamic raw,
  );

  @protected
  String dco_decode_String(dynamic raw);

  @protected
  bool dco_decode_bool(dynamic raw);

  @protected
  FileWatcherEventData dco_decode_box_autoadd_file_watcher_event_data(
    dynamic raw,
  );

  @protected
  (int, List<DirEntry>, bool)
  dco_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  );

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw);

  @protected
  FileWatcherEventData dco_decode_file_watcher_event_data(dynamic raw);

  @protected
  int dco_decode_i_32(dynamic raw);

  @protected
  List<DirEntry>
  dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    dynamic raw,
  );

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw);

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw);

  @protected
  String? dco_decode_opt_String(dynamic raw);

  @protected
  FileWatcherEventData? dco_decode_opt_box_autoadd_file_watcher_event_data(
    dynamic raw,
  );

  @protected
  (int, List<DirEntry>, bool)?
  dco_decode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  );

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw);

  @protected
  (int, List<DirEntry>, bool)
  dco_decode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    dynamic raw,
  );

  @protected
  TerminalConfig dco_decode_terminal_config(dynamic raw);

  @protected
  int dco_decode_u_16(dynamic raw);

  @protected
  int dco_decode_u_32(dynamic raw);

  @protected
  BigInt dco_decode_u_64(dynamic raw);

  @protected
  int dco_decode_u_8(dynamic raw);

  @protected
  void dco_decode_unit(dynamic raw);

  @protected
  BigInt dco_decode_usize(dynamic raw);

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer);

  @protected
  DirEntry
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  QrPayload
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  );

  @protected
  TerminalCommand
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  );

  @protected
  TerminalEvent
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  );

  @protected
  DirEntry
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  QrPayload
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  );

  @protected
  TerminalCommand
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  );

  @protected
  TerminalEvent
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  );

  @protected
  DirEntry
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  QrPayload
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    SseDeserializer deserializer,
  );

  @protected
  TerminalCommand
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    SseDeserializer deserializer,
  );

  @protected
  TerminalEvent
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    SseDeserializer deserializer,
  );

  @protected
  RustStreamSink<List<DirEntry>>
  sse_decode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    SseDeserializer deserializer,
  );

  @protected
  String sse_decode_String(SseDeserializer deserializer);

  @protected
  bool sse_decode_bool(SseDeserializer deserializer);

  @protected
  FileWatcherEventData sse_decode_box_autoadd_file_watcher_event_data(
    SseDeserializer deserializer,
  );

  @protected
  (int, List<DirEntry>, bool)
  sse_decode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  );

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  FileWatcherEventData sse_decode_file_watcher_event_data(
    SseDeserializer deserializer,
  );

  @protected
  int sse_decode_i_32(SseDeserializer deserializer);

  @protected
  List<DirEntry>
  sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    SseDeserializer deserializer,
  );

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer);

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer);

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer);

  @protected
  FileWatcherEventData? sse_decode_opt_box_autoadd_file_watcher_event_data(
    SseDeserializer deserializer,
  );

  @protected
  (int, List<DirEntry>, bool)?
  sse_decode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  );

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer);

  @protected
  (int, List<DirEntry>, bool)
  sse_decode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    SseDeserializer deserializer,
  );

  @protected
  TerminalConfig sse_decode_terminal_config(SseDeserializer deserializer);

  @protected
  int sse_decode_u_16(SseDeserializer deserializer);

  @protected
  int sse_decode_u_32(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer);

  @protected
  int sse_decode_u_8(SseDeserializer deserializer);

  @protected
  void sse_decode_unit(SseDeserializer deserializer);

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer);

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    DirEntry self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    QrPayload self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    TerminalCommand self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    TerminalEvent self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_StreamSink_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry_Sse(
    RustStreamSink<List<DirEntry>> self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_String(String self, SseSerializer serializer);

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer);

  @protected
  void sse_encode_box_autoadd_file_watcher_event_data(
    FileWatcherEventData self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool) self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_file_watcher_event_data(
    FileWatcherEventData self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer);

  @protected
  void
  sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    List<DirEntry> self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_list_prim_u_8_loose(List<int> self, SseSerializer serializer);

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer);

  @protected
  void sse_encode_opt_box_autoadd_file_watcher_event_data(
    FileWatcherEventData? self,
    SseSerializer serializer,
  );

  @protected
  void
  sse_encode_opt_box_autoadd_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool)? self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer);

  @protected
  void
  sse_encode_record_u_32_list_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_dir_entry_bool(
    (int, List<DirEntry>, bool) self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_terminal_config(
    TerminalConfig self,
    SseSerializer serializer,
  );

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer);

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer);

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer);

  @protected
  void sse_encode_unit(void self, SseSerializer serializer);

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer);
}

// Section: wire_class

class RustLibWire implements BaseWire {
  RustLibWire.fromExternalLibrary(ExternalLibrary lib);

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    int ptr,
  ) => wasmModule
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        ptr,
      );

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    int ptr,
  ) => wasmModule
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        ptr,
      );

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    int ptr,
  ) => wasmModule
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
        ptr,
      );

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    int ptr,
  ) => wasmModule
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
        ptr,
      );

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    int ptr,
  ) => wasmModule
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
        ptr,
      );

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    int ptr,
  ) => wasmModule
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
        ptr,
      );

  void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    int ptr,
  ) => wasmModule
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
        ptr,
      );

  void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    int ptr,
  ) => wasmModule
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
        ptr,
      );
}

@JS('wasm_bindgen')
external RustLibWasmModule get wasmModule;

@JS()
@anonymous
extension type RustLibWasmModule._(JSObject _) implements JSObject {
  external void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    int ptr,
  );

  external void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
    int ptr,
  );

  external void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    int ptr,
  );

  external void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
    int ptr,
  );

  external void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    int ptr,
  );

  external void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
    int ptr,
  );

  external void
  rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    int ptr,
  );

  external void
  rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
    int ptr,
  );
}

================
File: lib/bridge/lib.dart
================
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>
abstract class QrPayload implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>
abstract class TerminalCommand implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>
abstract class TerminalEvent implements RustOpaqueInterface {}

================
File: lib/core/storage.dart
================
import 'dart:convert';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

/// QR Payload model for host pairing
///
/// Matches the Rust QrPayload struct format
class QrPayload {
  final String ip;
  final int port;
  final String fingerprint;
  final String token;
  final int protocolVersion;

  QrPayload({
    required this.ip,
    required this.port,
    required this.fingerprint,
    required this.token,
    required this.protocolVersion,
  });

  /// Parse QR payload from JSON string
  factory QrPayload.fromJson(String jsonStr) {
    final json = jsonDecode(jsonStr) as Map<String, dynamic>;
    return QrPayload(
      ip: json['ip'] as String,
      port: json['port'] as int,
      fingerprint: json['fingerprint'] as String,
      token: json['token'] as String,
      protocolVersion: json['protocol_version'] as int? ?? 1,
    );
  }

  /// Convert to JSON
  String toJson() {
    return jsonEncode({
      'ip': ip,
      'port': port,
      'fingerprint': fingerprint,
      'token': token,
      'protocol_version': protocolVersion,
    });
  }

  /// Display name for this host
  String get displayName => 'Host at $ip:$port';

  /// Unique key for storage
  String get storageKey => 'host_$fingerprint';
}

/// Secure storage wrapper for Comacode
///
/// Phase 04: Mobile App
/// Uses flutter_secure_storage for TOFU credential persistence
class AppStorage {
  static const _storage = FlutterSecureStorage(
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
    ),
  );

  /// Save verified host (TOFU - auto-trust)
  ///
  /// After successful connection, save credentials for auto-reconnect
  ///
  /// SECURITY NOTE: Token expiry is not implemented in Phase 06.
  /// Future enhancement: Add token expiry time to QrPayload and check
  /// before reconnecting. Consider credential rotation mechanism.
  static Future<void> saveHost(QrPayload payload) async {
    try {
      await _storage.write(key: payload.storageKey, value: payload.toJson());
      // Mark as last used
      await _storage.write(key: 'last_host', value: payload.fingerprint);
    } catch (e) {
      throw Exception('Failed to save host: $e');
    }
  }

  /// Save host from JSON string (Phase 06: for FRB integration)
  static Future<void> saveHostString(String jsonStr) async {
    try {
      final payload = QrPayload.fromJson(jsonStr);
      await saveHost(payload);
    } catch (e) {
      throw Exception('Failed to save host: $e');
    }
  }

  /// Get last connected host
  ///
  /// Returns the most recently used host for auto-reconnect
  static Future<QrPayload?> getLastHost() async {
    try {
      final fp = await _storage.read(key: 'last_host');
      if (fp == null) return null;

      final jsonStr = await _storage.read(key: 'host_$fp');
      if (jsonStr == null) return null;

      return QrPayload.fromJson(jsonStr);
    } catch (e) {
      return null;
    }
  }

  /// Get all saved hosts
  static Future<List<QrPayload>> getAllHosts() async {
    try {
      final allKeys = await _storage.readAll();
      final hosts = <QrPayload>[];

      for (final key in allKeys.keys) {
        if (key.startsWith('host_')) {
          final jsonStr = allKeys[key];
          if (jsonStr != null) {
            try {
              hosts.add(QrPayload.fromJson(jsonStr));
            } catch (_) {
              // Skip invalid entries
            }
          }
        }
      }

      return hosts;
    } catch (e) {
      return [];
    }
  }

  /// Delete specific host
  static Future<void> deleteHost(String fingerprint) async {
    await _storage.delete(key: 'host_$fingerprint');

    // If this was the last host, clear that reference
    final lastHost = await _storage.read(key: 'last_host');
    if (lastHost == fingerprint) {
      await _storage.delete(key: 'last_host');
    }
  }

  /// Clear all saved hosts
  static Future<void> clearAll() async {
    await _storage.deleteAll();
  }

  /// Check if any hosts are saved
  static Future<bool> hasHosts() async {
    final allKeys = await _storage.readAll();
    return allKeys.keys.any((key) => key.startsWith('host_'));
  }

  /// Save preference
  static Future<void> setPref(String key, String value) async {
    await _storage.write(key: 'pref_$key', value: value);
  }

  /// Get preference
  static Future<String?> getPref(String key) async {
    return await _storage.read(key: 'pref_$key');
  }

  /// Delete preference
  static Future<void> deletePref(String key) async {
    await _storage.delete(key: 'pref_$key');
  }
}

================
File: lib/core/theme.dart
================
import 'package:flutter/material.dart';

/// Catppuccin Mocha color palette
///
/// Phase 04: Mobile App
/// https://catppuccin.com/
class CatppuccinMocha {
  // Base colors
  static const base = Color(0xFF1E1E2E);      // Dark background
  static const mantle = Color(0xFF181825);    // Darker background
  static const crust = Color(0xFF11111B);     // Darkest background

  // Surface colors
  static const surface = Color(0xFF313244);   // Card/surface background
  static const surface0 = Color(0xFF45475A);  // Surface 0
  static const surface1 = Color(0xFF585B70);  // Surface 1

  // Text colors
  static const text = Color(0xFFCDD6F4);      // Primary text
  static const subtext1 = Color(0xFFBAC2DE);  // Secondary text
  static const subtext0 = Color(0xFFA6ADC8);  // Tertiary text
  static const overlay2 = Color(0xFF9399B2);  // Overlay 2
  static const overlay1 = Color(0xFF7F849C);  // Overlay 1
  static const overlay0 = Color(0xFF6C7086);  // Overlay 0

  // Accent colors
  static const primary = Color(0xFFCBA6F7);   // Mauve (primary)
  static const secondary = Color(0xFF89B4FA); // Blue
  static const tertiary = Color(0xFFF5C2E7);  // Pink

  // Functional colors
  static const blue = Color(0xFF89B4FA);      // Info
  static const lavender = Color(0xFFB4BEFE);  // Accent
  static const sapphire = Color(0xFF74C7EC);  // Accent 2
  static const sky = Color(0xFF89Dceb);       // Accent 3
  static const teal = Color(0xFF94E2D5);      // Accent 4
  static const green = Color(0xFFA6E3A1);     // Success
  static const yellow = Color(0xFFF9E2AF);    // Warning
  static const peach = Color(0xFFfab387);     // Warning 2
  static const maroon = Color(0xFFEBA0AC);    // Error 2
  static const red = Color(0xFFF38BA8);       // Error
  static const mauve = Color(0xFFCBA6F7);     // Purple
  static const flamingo = Color(0xFFF2CDCD);  // Pink 2
  static const rosewater = Color(0xFFF5E0DC); // Pink 3

  // Transparent overlay
  static const overlay1Opacity = 0.16;

  /// Light theme (not used for MVP, but defined for completeness)
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorScheme: const ColorScheme.light(
        primary: lavender,
        secondary: blue,
        surface: surface,
        error: red,
        onPrimary: base,
        onSecondary: base,
        onSurface: text,
        onError: base,
      ),
      scaffoldBackgroundColor: base,
      appBarTheme: const AppBarTheme(
        backgroundColor: base,
        foregroundColor: text,
        elevation: 0,
      ),
    );
  }

  /// Dark theme (primary for Comacode)
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: const ColorScheme.dark(
        primary: mauve,
        secondary: blue,
        surface: surface,
        error: red,
        onPrimary: base,
        onSecondary: base,
        onSurface: text,
        onError: base,
      ),
      scaffoldBackgroundColor: base,
      appBarTheme: const AppBarTheme(
        backgroundColor: mantle,
        foregroundColor: text,
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: const CardThemeData(
        color: surface,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: mauve,
          foregroundColor: base,
          elevation: 0,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: mauve,
          side: const BorderSide(color: mauve, width: 1),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: mauve,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: surface,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: mauve, width: 2),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: red, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      ),
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: mauve,
        foregroundColor: base,
        elevation: 0,
      ),
      bottomNavigationBarTheme: const BottomNavigationBarThemeData(
        backgroundColor: mantle,
        selectedItemColor: mauve,
        unselectedItemColor: overlay1,
        type: BottomNavigationBarType.fixed,
        elevation: 0,
      ),
      dividerTheme: const DividerThemeData(
        color: surface0,
        thickness: 1,
      ),
      iconTheme: const IconThemeData(
        color: text,
      ),
      snackBarTheme: SnackBarThemeData(
        backgroundColor: surface,
        contentTextStyle: const TextStyle(color: text),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  /// Terminal-specific colors
  static const terminalBackground = Color(0xFF1E1E2E);
  static const terminalForeground = Color(0xFFCDD6F4);
  static const terminalCursor = Color(0xFFCBA6F7);

  /// ANSI color palette for terminal
  static const ansiBlack = Color(0xFF45475A);
  static const ansiRed = Color(0xFFF38BA8);
  static const ansiGreen = Color(0xFFA6E3A1);
  static const ansiYellow = Color(0xFFF9E2AF);
  static const ansiBlue = Color(0xFF89B4FA);
  static const ansiMagenta = Color(0xFFCBA6F7);
  static const ansiCyan = Color(0xFF94E2D5);
  static const ansiWhite = Color(0xFFBAC2DE);

  static const ansiBrightBlack = Color(0xFF585B70);
  static const ansiBrightRed = Color(0xFFEBA0AC);
  static const ansiBrightGreen = Color(0xFF94E2D5);
  static const ansiBrightYellow = Color(0xFFFAB387);
  static const ansiBrightBlue = Color(0xFF89DCEB);
  static const ansiBrightMagenta = Color(0xFFF5C2E7);
  static const ansiBrightCyan = Color(0xFF89Dceb);
  static const ansiBrightWhite = Color(0xFFA6ADC8);
}

================
File: lib/features/connection/connection_provider.dart
================
import 'package:flutter/foundation.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import '../../core/storage.dart';

/// Connection state for Comacode
///
/// Phase 04: Mobile App
/// Manages QUIC connection state with TOFU auto-trust
class ConnectionProvider extends ChangeNotifier {
  bool _isConnected = false;
  bool _isConnecting = false;
  QrPayload? _currentHost;
  String? _error;
  final List<String> _terminalOutput = [];

  // Getters
  bool get isConnected => _isConnected;
  bool get isConnecting => _isConnecting;
  QrPayload? get currentHost => _currentHost;
  String? get error => _error;
  List<String> get terminalOutput => List.unmodifiable(_terminalOutput);

  /// Check if has any saved hosts
  Future<bool> hasSavedHosts() async {
    return await AppStorage.hasHosts();
  }

  /// Connect using scanned/saved payload (auto-trust TOFU)
  ///
  /// Flow:
  /// 1. Parse QR string to QrPayload
  /// 2. Call Rust Bridge to connect
  /// 3. If successful, persist credentials (TOFU)
  /// 4. Enable wakelock
  Future<void> connectWithQrString(String qrJson) async {
    try {
      _setConnecting(true);
      _clearError();

      // Parse QR payload
      final payload = QrPayload.fromJson(qrJson);

      // TODO: Call Rust Bridge here when implemented
      // For now, simulate connection
      await Future.delayed(const Duration(milliseconds: 500));

      // Simulate success (stub implementation)
      // In real implementation:
      // await ComacodeBridge.connect(
      //   host: payload.ip,
      //   port: payload.port,
      //   token: payload.token,
      //   fingerprint: payload.fingerprint,
      // );

      // If successful, persist credentials (TOFU)
      await AppStorage.saveHost(payload);

      _isConnected = true;
      _currentHost = payload;

      // Keep screen on during session
      await WakelockPlus.enable();

      _addTerminalOutput('Connected to ${payload.ip}:${payload.port}');
      _addTerminalOutput('Certificate fingerprint: ${payload.fingerprint}');
      _addTerminalOutput('\$ '); // Shell prompt

      notifyListeners();
    } catch (e) {
      _error = e.toString();
      _isConnected = false;
      _currentHost = null;
      notifyListeners();
      rethrow;
    } finally {
      _setConnecting(false);
    }
  }

  /// Auto-reconnect to last host
  Future<void> reconnectLast() async {
    final last = await AppStorage.getLastHost();
    if (last != null) {
      await connectWithQrString(last.toJson());
    } else {
      throw Exception('No saved host found');
    }
  }

  /// Disconnect from host
  Future<void> disconnect() async {
    _isConnected = false;
    _currentHost = null;

    // Disable wakelock
    await WakelockPlus.disable();

    // Clear terminal output
    _terminalOutput.clear();

    notifyListeners();
  }

  /// Send command to terminal
  void sendCommand(String command) {
    if (!_isConnected) {
      _error = 'Not connected';
      notifyListeners();
      return;
    }

    // Add command to output
    _addTerminalOutput(command);

    // TODO: Send via Rust Bridge
    // In real implementation:
    // await ComacodeBridge.sendCommand(command);

    // Echo the command (simulated)
    _addTerminalOutput('\$ ');
  }

  /// Add line to terminal output
  void _addTerminalOutput(String line) {
    _terminalOutput.add(line);
    notifyListeners();
  }

  /// Clear terminal output
  void clearTerminal() {
    _terminalOutput.clear();
    _addTerminalOutput('\$ ');
    notifyListeners();
  }

  /// Set connecting state
  void _setConnecting(bool connecting) {
    _isConnecting = connecting;
    notifyListeners();
  }

  /// Clear error
  void _clearError() {
    _error = null;
    notifyListeners();
  }

  /// Get display name for current host
  String? get hostDisplayName => _currentHost?.displayName;
}

================
File: lib/features/connection/connection_providers.dart
================
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../bridge/bridge_wrapper.dart';
import '../../bridge/ffi_helpers.dart';
import '../../core/storage.dart' as storage;
import 'package:wakelock_plus/wakelock_plus.dart';

part 'connection_providers.g.dart';

/// Connection status enum
enum ConnectionStatus {
  disconnected,
  connecting,
  connected,
  error,
}

/// Connection model with current state
class ConnectionModel {
  final ConnectionStatus status;
  final storage.QrPayload? currentHost; // Dart model from storage.dart
  final String? errorMessage;

  const ConnectionModel({
    required this.status,
    this.currentHost,
    this.errorMessage,
  });

  factory ConnectionModel.disconnected() {
    return const ConnectionModel(status: ConnectionStatus.disconnected);
  }

  factory ConnectionModel.connecting() {
    return const ConnectionModel(status: ConnectionStatus.connecting);
  }

  factory ConnectionModel.connected(storage.QrPayload host) {
    return ConnectionModel(
      status: ConnectionStatus.connected,
      currentHost: host,
    );
  }

  factory ConnectionModel.error(String message) {
    return ConnectionModel(
      status: ConnectionStatus.error,
      errorMessage: message,
    );
  }

  bool get isConnected => status == ConnectionStatus.connected;
  bool get isConnecting => status == ConnectionStatus.connecting;
  bool get isDisconnected => status == ConnectionStatus.disconnected;
  bool get hasError => status == ConnectionStatus.error;

  String? get hostDisplayName => currentHost?.displayName;
}

/// Terminal output state
class TerminalOutputModel {
  final List<String> lines;

  const TerminalOutputModel({required this.lines});

  factory TerminalOutputModel.initial() {
    return const TerminalOutputModel(lines: []);
  }

  TerminalOutputModel copyWith({List<String>? lines}) {
    return TerminalOutputModel(lines: lines ?? this.lines);
  }

  int get length => lines.length;
}

/// Riverpod provider for connection state
///
/// Phase 06: Refactor t ChangeNotifier sang Riverpod
/// Dng @riverpod annotation vi code generation
@riverpod
class ConnectionState extends _$ConnectionState {
  @override
  ConnectionModel build() {
    return ConnectionModel.disconnected();
  }

  /// Connect using QR payload
  ///
  /// Flow:
  /// 1. Set connecting state
  /// 2. Parse QR string to Dart QrPayload (for storage/UI)
  /// 3. Parse QR string to FRB QrPayload (for connection)
  /// 4. Call Rust Bridge to connect
  /// 5. If success, persist credentials (TOFU)
  /// 6. Enable wakelock
  Future<void> connect(String qrJson) async {
    state = ConnectionModel.connecting();

    try {
      // Parse to Dart model first (for storage and UI)
      final dartPayload = storage.QrPayload.fromJson(qrJson);

      // Parse to FRB opaque type
      final bridge = ref.read(bridgeWrapperProvider);
      final frbPayload = await bridge.parseQrPayload(qrJson);

      // Connect via Rust Bridge using FRB API getters
      await bridge.connect(
        host: getQrIp(frbPayload),
        port: getQrPort(frbPayload),
        token: getQrToken(frbPayload),
        fingerprint: getQrFingerprint(frbPayload),
      );

      // Persist credentials (TOFU) - use Dart model
      await storage.AppStorage.saveHost(dartPayload);

      // Enable wakelock (keep screen on during session)
      await WakelockPlus.enable();

      state = ConnectionModel.connected(dartPayload);
    } catch (e) {
      state = ConnectionModel.error(e.toString());
      rethrow;
    }
  }

  /// Auto-reconnect to last saved host
  Future<void> reconnectLast() async {
    final last = await storage.AppStorage.getLastHost();
    if (last != null) {
      await connect(last.toJson());
    } else {
      state = ConnectionModel.error('No saved host found');
      throw Exception('No saved host found');
    }
  }

  /// Disconnect from host
  Future<void> disconnect() async {
    try {
      final bridge = ref.read(bridgeWrapperProvider);
      await bridge.disconnect();
    } catch (_) {
      // Ignore disconnect errors
    } finally {
      // Disable wakelock
      await WakelockPlus.disable();

      // Reset state
      state = ConnectionModel.disconnected();
    }
  }

  /// Send command to terminal
  Future<void> sendCommand(String command) async {
    if (!state.isConnected) {
      state = ConnectionModel.error('Not connected');
      return;
    }

    try {
      final bridge = ref.read(bridgeWrapperProvider);
      await bridge.sendCommand(command);
    } catch (e) {
      state = ConnectionModel.error(e.toString());
    }
  }

  /// Check if has any saved hosts
  Future<bool> hasSavedHosts() async {
    return await storage.AppStorage.hasHosts();
  }
}

/// Riverpod provider for terminal output
///
/// Stores terminal output lines
@riverpod
class TerminalOutput extends _$TerminalOutput {
  @override
  TerminalOutputModel build() {
    return TerminalOutputModel.initial();
  }

  /// Add line to terminal output
  void addLine(String line) {
    final newLines = [...state.lines, line];
    state = state.copyWith(lines: newLines);
  }

  /// Add multiple lines at once
  void addLines(List<String> lines) {
    final newLines = [...state.lines, ...lines];
    state = state.copyWith(lines: newLines);
  }

  /// Clear terminal output
  void clear() {
    state = const TerminalOutputModel(lines: []);
  }
}

================
File: lib/features/connection/connection_providers.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'connection_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$connectionStateHash() => r'e39aecd7230d189403ecbdbf500b09d61ce9f28c';

/// Riverpod provider for connection state
///
/// Phase 06: Refactor t ChangeNotifier sang Riverpod
/// Dng @riverpod annotation vi code generation
///
/// Copied from [ConnectionState].
@ProviderFor(ConnectionState)
final connectionStateProvider =
    AutoDisposeNotifierProvider<ConnectionState, ConnectionModel>.internal(
      ConnectionState.new,
      name: r'connectionStateProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$connectionStateHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

typedef _$ConnectionState = AutoDisposeNotifier<ConnectionModel>;
String _$terminalOutputHash() => r'2de553c7ef0d3a03b6e25f03cdd55ff34ae504dd';

/// Riverpod provider for terminal output
///
/// Stores terminal output lines
///
/// Copied from [TerminalOutput].
@ProviderFor(TerminalOutput)
final terminalOutputProvider =
    AutoDisposeNotifierProvider<TerminalOutput, TerminalOutputModel>.internal(
      TerminalOutput.new,
      name: r'terminalOutputProvider',
      debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$terminalOutputHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

typedef _$TerminalOutput = AutoDisposeNotifier<TerminalOutputModel>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package

================
File: lib/features/connection/home_page.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../qr_scanner/qr_scanner_page.dart';
import '../project/project_picker_page.dart';
import 'connection_providers.dart';
import '../../core/storage.dart';
import '../../core/theme.dart';

/// Home page for connection selection
///
/// Phase 06: Refactor to Riverpod
/// Shows saved hosts and options to connect
class HomePage extends ConsumerStatefulWidget {
  const HomePage({super.key});

  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage> {
  @override
  Widget build(BuildContext context) {
    final connectionState = ref.watch(connectionStateProvider);

    // Auto-navigate to Project Picker if already connected
    if (connectionState.isConnected) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const ProjectPickerPage()),
        );
      });
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Comacode'),
        backgroundColor: CatppuccinMocha.mantle,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              // TODO: Show settings
            },
          ),
        ],
      ),
      body: _buildContent(context),
    );
  }

  Widget _buildContent(BuildContext context) {
    return FutureBuilder<bool>(
      future: ref.read(connectionStateProvider.notifier).hasSavedHosts(),
      builder: (context, snapshot) {
        final hasHosts = snapshot.data ?? false;

        return SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Logo/Icon
              Center(
                child: Container(
                  width: 100,
                  height: 100,
                  decoration: BoxDecoration(
                    color: CatppuccinMocha.surface,
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    Icons.qr_code_scanner,
                    size: 48,
                    color: CatppuccinMocha.mauve,
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Title
              const Text(
                'Vibe Coding',
                textAlign: TextAlign.center,
                style: TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: CatppuccinMocha.text,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Scan QR code to start Vibe Coding session',
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: CatppuccinMocha.subtext0,
                  fontSize: 14,
                ),
              ),
              const SizedBox(height: 32),

              // Primary action: Scan QR
              _buildPrimaryButton(
                context,
                icon: Icons.qr_code_scanner,
                label: 'Scan QR Code',
                description: 'Scan QR from host terminal',
                onTap: () => _navigateToScan(context),
              ),
              const SizedBox(height: 16),

              // Vibe Coding button (new!)
              _buildVibeButton(context),

              const SizedBox(height: 16),

              // Secondary action: Manual connect
              _buildSecondaryButton(
                context,
                icon: Icons.edit,
                label: 'Manual Connect',
                description: 'Enter connection details manually',
                onTap: () => _navigateToManual(context),
              ),

              // Saved hosts section
              if (hasHosts) ...[
                const SizedBox(height: 32),
                const Divider(color: CatppuccinMocha.surface0),
                const SizedBox(height: 16),
                _buildSavedHostsSection(context),
              ],
            ],
          ),
        );
      },
    );
  }

  Widget _buildPrimaryButton(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String description,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(16),
      child: Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          color: CatppuccinMocha.surface,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
            color: CatppuccinMocha.mauve.withValues(alpha: 0.3),
            width: 2,
          ),
        ),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: const BoxDecoration(
                color: CatppuccinMocha.mauve,
                shape: BoxShape.circle,
              ),
              child: Icon(
                icon,
                color: CatppuccinMocha.crust,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: CatppuccinMocha.text,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    description,
                    style: TextStyle(
                      color: CatppuccinMocha.subtext0,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
            Icon(
              Icons.chevron_right,
              color: CatppuccinMocha.subtext0,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildVibeButton(BuildContext context) {
    return InkWell(
      onTap: () => _navigateToVibe(context),
      borderRadius: BorderRadius.circular(16),
      child: Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [
              CatppuccinMocha.mauve.withValues(alpha: 0.2),
              CatppuccinMocha.blue.withValues(alpha: 0.2),
            ],
          ),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(
            color: CatppuccinMocha.mauve.withValues(alpha: 0.5),
            width: 2,
          ),
        ),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: [CatppuccinMocha.mauve, CatppuccinMocha.blue],
                ),
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.smart_toy,
                color: CatppuccinMocha.crust,
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Vibe Coding',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: CatppuccinMocha.text,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Chat-style interface for Claude Code CLI',
                    style: TextStyle(
                      color: CatppuccinMocha.subtext0,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
            Icon(
              Icons.chevron_right,
              color: CatppuccinMocha.subtext0,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSecondaryButton(
    BuildContext context, {
    required IconData icon,
    required String label,
    required String description,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: CatppuccinMocha.surface,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Row(
          children: [
            Icon(
              icon,
              color: CatppuccinMocha.subtext0,
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w500,
                      color: CatppuccinMocha.text,
                    ),
                  ),
                  const SizedBox(height: 2),
                  Text(
                    description,
                    style: TextStyle(
                      color: CatppuccinMocha.subtext0,
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
            Icon(
              Icons.chevron_right,
              color: CatppuccinMocha.subtext0,
              size: 20,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSavedHostsSection(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              'Saved Hosts',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: CatppuccinMocha.text,
              ),
            ),
            const Spacer(),
            TextButton(
              onPressed: () => _clearAllHosts(context),
              child: Text(
                'Clear All',
                style: TextStyle(color: CatppuccinMocha.red),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        _buildSavedHostsList(context),
      ],
    );
  }

  Widget _buildSavedHostsList(BuildContext context) {
    return FutureBuilder<List<QrPayload>>(
      future: AppStorage.getAllHosts(),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return const Center(
            child: CircularProgressIndicator(),
          );
        }

        final hosts = snapshot.data!;
        if (hosts.isEmpty) {
          return const SizedBox.shrink();
        }

        return Column(
          children: hosts.map((host) {
            return _buildHostTile(context, host);
          }).toList(),
        );
      },
    );
  }

  Widget _buildHostTile(BuildContext context, QrPayload host) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: CatppuccinMocha.surface,
        borderRadius: BorderRadius.circular(12),
      ),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: CatppuccinMocha.surface1,
          foregroundColor: CatppuccinMocha.mauve,
          child: const Icon(Icons.computer),
        ),
        title: Text(
          host.displayName,
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        subtitle: Text(
          'Saved host', // Don't display fingerprint for security (shoulder surfing)
          style: TextStyle(
            color: CatppuccinMocha.subtext0,
            fontSize: 12,
          ),
        ),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: Icon(
                Icons.connect_without_contact,
                color: CatppuccinMocha.green,
              ),
              onPressed: () => _connectToSaved(context, host),
              tooltip: 'Connect',
            ),
            IconButton(
              icon: Icon(
                Icons.delete_outline,
                color: CatppuccinMocha.red,
              ),
              onPressed: () => _deleteHost(context, host),
              tooltip: 'Delete',
            ),
          ],
        ),
      ),
    );
  }

  void _navigateToScan(BuildContext context) {
    Navigator.of(context).push(
      MaterialPageRoute(builder: (_) => const QrScannerPage()),
    );
  }

  void _navigateToVibe(BuildContext context) {
    // Phase 06: Navigate to Project Picker first (not direct to Vibe Session)
    // User will select project/session, then navigate to VibeSessionPage
    Navigator.of(context).push(
      MaterialPageRoute(builder: (_) => const ProjectPickerPage()),
    );
  }

  void _navigateToManual(BuildContext context) {
    // TODO: Implement manual connect page
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Manual connect coming soon')),
    );
  }

  void _connectToSaved(BuildContext context, QrPayload host) async {
    try {
      await ref.read(connectionStateProvider.notifier).connect(host.toJson());
      if (context.mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const ProjectPickerPage()),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Connection failed: $e'),
            backgroundColor: CatppuccinMocha.red,
          ),
        );
      }
    }
  }

  void _deleteHost(BuildContext context, QrPayload host) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: CatppuccinMocha.surface,
        title: Text(
          'Delete Host',
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        content: Text(
          'Remove this saved host?',
          style: TextStyle(color: CatppuccinMocha.subtext0),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text(
              'Delete',
              style: TextStyle(color: CatppuccinMocha.red),
            ),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      // Disconnect if deleting the currently connected host
      final connectionState = ref.read(connectionStateProvider);
      if (connectionState.isConnected &&
          connectionState.currentHost?.fingerprint == host.fingerprint) {
        await ref.read(connectionStateProvider.notifier).disconnect();
      }

      await AppStorage.deleteHost(host.fingerprint);
      // Trigger rebuild to refresh hosts list
      setState(() {});
    }
  }

  void _clearAllHosts(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: CatppuccinMocha.surface,
        title: Text(
          'Clear All Hosts',
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        content: Text(
          'Remove all saved hosts?',
          style: TextStyle(color: CatppuccinMocha.subtext0),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text(
              'Clear All',
              style: TextStyle(color: CatppuccinMocha.red),
            ),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await AppStorage.clearAll();
      // Trigger rebuild to refresh hosts list
      setState(() {});
    }
  }
}

================
File: lib/features/project/models/models.dart
================
// Barrel export for project models
export 'project.dart';
export 'session_metadata.dart';

================
File: lib/features/project/models/project.dart
================
import 'package:uuid/uuid.dart';

import 'session_metadata.dart';

/// Project model (local storage only)
///
/// Phase 01: Project & Session Management
/// Per-connection project storage with session list
class Project {
  final String id; // UUID
  final String name; // e.g. "my-app", "api-server"
  final String path; // e.g. "/Users/dev/my-app"
  final DateTime createdAt;
  final DateTime lastAccessed;
  final List<SessionMetadata> sessions;

  const Project({
    required this.id,
    required this.name,
    required this.path,
    required this.createdAt,
    required this.lastAccessed,
    this.sessions = const [],
  });

  /// Create new project with UUID
  factory Project.create({
    required String name,
    required String path,
  }) {
    final now = DateTime.now();
    return Project(
      id: const Uuid().v4(),
      name: name,
      path: path,
      createdAt: now,
      lastAccessed: now,
    );
  }

  /// Copy with modified fields
  Project copyWith({
    String? id,
    String? name,
    String? path,
    DateTime? createdAt,
    DateTime? lastAccessed,
    List<SessionMetadata>? sessions,
  }) {
    return Project(
      id: id ?? this.id,
      name: name ?? this.name,
      path: path ?? this.path,
      createdAt: createdAt ?? this.createdAt,
      lastAccessed: lastAccessed ?? this.lastAccessed,
      sessions: sessions ?? this.sessions,
    );
  }

  /// Update last accessed time
  Project touch() {
    return copyWith(lastAccessed: DateTime.now());
  }

  /// Add session to project
  Project addSession(SessionMetadata session) {
    return copyWith(sessions: [...sessions, session]);
  }

  /// Remove session from project
  Project removeSession(String sessionId) {
    return copyWith(
      sessions: sessions.where((s) => s.id != sessionId).toList(),
    );
  }

  /// Update session in project
  Project updateSession(SessionMetadata updated) {
    return copyWith(
      sessions: sessions
          .map((s) => s.id == updated.id ? updated : s)
          .toList(),
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'path': path,
      'createdAt': createdAt.toIso8601String(),
      'lastAccessed': lastAccessed.toIso8601String(),
      'sessions': sessions.map((s) => s.toJson()).toList(),
    };
  }

  /// Create from JSON
  factory Project.fromJson(Map<String, dynamic> json) {
    return Project(
      id: json['id'] as String,
      name: json['name'] as String,
      path: json['path'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      lastAccessed: DateTime.parse(json['lastAccessed'] as String),
      sessions: (json['sessions'] as List<dynamic>?)
              ?.map((s) => SessionMetadata.fromJson(s as Map<String, dynamic>))
              .toList() ??
          const [],
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Project &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() =>
      'Project(id: $id, name: $name, path: $path, sessions: ${sessions.length})';
}

================
File: lib/features/project/models/session_metadata.dart
================
import 'package:uuid/uuid.dart';

/// Session metadata (lightweight, no Terminal)
///
/// Phase 01: Project & Session Management
/// Stores session info for local persistence - PTY is ephemeral
class SessionMetadata {
  final String id;
  final String name; // e.g. "Session 1", "Fix login bug"
  final DateTime createdAt;

  const SessionMetadata({
    required this.id,
    required this.name,
    required this.createdAt,
  });

  /// Create new session with UUID
  factory SessionMetadata.create({required String name}) {
    return SessionMetadata(
      id: const Uuid().v4(),
      name: name,
      createdAt: DateTime.now(),
    );
  }

  /// Copy with modified fields
  SessionMetadata copyWith({
    String? id,
    String? name,
    DateTime? createdAt,
  }) {
    return SessionMetadata(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  /// Create from JSON
  factory SessionMetadata.fromJson(Map<String, dynamic> json) {
    return SessionMetadata(
      id: json['id'] as String,
      name: json['name'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionMetadata &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'SessionMetadata(id: $id, name: $name)';
}

================
File: lib/features/project/widgets/project_list.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/theme.dart';
import '../models/models.dart';
import '../project_providers.dart';
import 'project_tile.dart';

/// List of projects for current connection
class ProjectList extends ConsumerWidget {
  const ProjectList({
    required this.fingerprint,
    required this.onProjectTap,
    super.key,
  });

  final String fingerprint;
  final Function(Project) onProjectTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final projectsAsync = ref.watch(projectsProvider(fingerprint));

    return projectsAsync.when(
      data: (projects) {
        if (projects.isEmpty) {
          return const _EmptyState();
        }

        return ListView.builder(
          padding: const EdgeInsets.all(16),
          itemCount: projects.length,
          itemBuilder: (context, index) {
            final project = projects[index];
            return ProjectTile(
              project: project,
              onTap: () => onProjectTap(project),
              onDelete: () => _handleDeleteProject(context, ref, project),
            );
          },
        );
      },
      loading: () => const Center(
        child: CircularProgressIndicator(),
      ),
      error: (e, _) => Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 48,
              color: CatppuccinMocha.red,
            ),
            const SizedBox(height: 16),
            Text(
              'Error loading projects',
              style: TextStyle(
                fontSize: 16,
                color: CatppuccinMocha.text,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              e.toString(),
              style: TextStyle(
                color: CatppuccinMocha.subtext0,
                fontSize: 12,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  void _handleDeleteProject(
    BuildContext context,
    WidgetRef ref,
    Project project,
  ) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: CatppuccinMocha.surface,
        title: Text(
          'Delete Project',
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        content: Text(
          'Delete "${project.name}"? This will not delete files on disk.',
          style: TextStyle(color: CatppuccinMocha.subtext0),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(
              'Cancel',
              style: TextStyle(color: CatppuccinMocha.subtext0),
            ),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text(
              'Delete',
              style: TextStyle(color: CatppuccinMocha.red),
            ),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      await ref
          .read(projectNotifierProvider(fingerprint).notifier)
          .deleteProject(project.id);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Project "${project.name}" deleted'),
            backgroundColor: CatppuccinMocha.green,
          ),
        );
      }
    }
  }
}

class _EmptyState extends StatelessWidget {
  const _EmptyState();

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.folder_open,
            size: 64,
            color: CatppuccinMocha.overlay1,
          ),
          const SizedBox(height: 16),
          Text(
            'No projects yet',
            style: TextStyle(
              fontSize: 18,
              color: CatppuccinMocha.text,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Create a project to start coding',
            style: TextStyle(
              color: CatppuccinMocha.subtext0,
            ),
          ),
          const SizedBox(height: 24),
          Icon(
            Icons.arrow_upward,
            size: 24,
            color: CatppuccinMocha.mauve,
          ),
          const SizedBox(height: 8),
          Text(
            'Tap + to create a project',
            style: TextStyle(
              color: CatppuccinMocha.subtext0,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }
}

================
File: lib/features/project/widgets/project_tile.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';
import '../models/models.dart';

/// Single project item tile
class ProjectTile extends StatelessWidget {
  final Project project;
  final VoidCallback onTap;
  final VoidCallback onDelete;

  const ProjectTile({
    required this.project,
    required this.onTap,
    required this.onDelete,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      decoration: BoxDecoration(
        color: CatppuccinMocha.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: CatppuccinMocha.surface0,
          width: 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Folder icon
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: CatppuccinMocha.mauve.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  Icons.folder,
                  color: CatppuccinMocha.mauve,
                  size: 24,
                ),
              ),
              const SizedBox(width: 16),
              // Project info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      project.name,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: CatppuccinMocha.text,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      project.path,
                      style: const TextStyle(
                        fontSize: 12,
                        color: CatppuccinMocha.subtext0,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Icon(
                          Icons.layers,
                          size: 12,
                          color: CatppuccinMocha.overlay1,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          '${project.sessions.length} session${project.sessions.length == 1 ? '' : 's'}',
                          style: const TextStyle(
                            fontSize: 11,
                            color: CatppuccinMocha.overlay1,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Icon(
                          Icons.access_time,
                          size: 12,
                          color: CatppuccinMocha.overlay1,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          _formatLastAccessed(project.lastAccessed),
                          style: const TextStyle(
                            fontSize: 11,
                            color: CatppuccinMocha.overlay1,
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              // Chevron
              Icon(
                Icons.chevron_right,
                color: CatppuccinMocha.subtext0,
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatLastAccessed(DateTime dateTime) {
    final now = DateTime.now();
    final diff = now.difference(dateTime);

    if (diff.inMinutes < 1) return 'Just now';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
    if (diff.inHours < 24) return '${diff.inHours}h ago';
    if (diff.inDays < 7) return '${diff.inDays}d ago';
    return '${dateTime.month}/${dateTime.day}';
  }
}

================
File: lib/features/project/widgets/session_list.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';
import '../models/models.dart';
import 'session_tile.dart';

/// List of sessions within a project
class SessionList extends StatelessWidget {
  final Project project;
  final Function(SessionMetadata) onSessionTap;
  final Function(SessionMetadata) onDelete;

  const SessionList({
    required this.project,
    required this.onSessionTap,
    required this.onDelete,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    if (project.sessions.isEmpty) {
      return _EmptyState(project: project);
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: project.sessions.length,
      itemBuilder: (context, index) {
        final session = project.sessions[index];
        return SessionTile(
          session: session,
          onTap: () => onSessionTap(session),
          onDelete: () => onDelete(session),
        );
      },
    );
  }
}

class _EmptyState extends StatelessWidget {
  final Project project;

  const _EmptyState({required this.project});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.terminal_outlined,
            size: 64,
            color: CatppuccinMocha.overlay1,
          ),
          const SizedBox(height: 16),
          Text(
            'No sessions yet',
            style: TextStyle(
              fontSize: 18,
              color: CatppuccinMocha.text,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Create a new session to start coding',
            style: TextStyle(
              color: CatppuccinMocha.subtext0,
            ),
          ),
          const SizedBox(height: 24),
          Icon(
            Icons.add_circle_outline,
            size: 24,
            color: CatppuccinMocha.green,
          ),
          const SizedBox(height: 8),
          Text(
            'Tap + to create a session',
            style: TextStyle(
              color: CatppuccinMocha.subtext0,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }
}

================
File: lib/features/project/widgets/session_tile.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';
import '../models/models.dart';

/// Single session item tile
class SessionTile extends StatelessWidget {
  final SessionMetadata session;
  final VoidCallback onTap;
  final VoidCallback onDelete;

  const SessionTile({
    required this.session,
    required this.onTap,
    required this.onDelete,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: CatppuccinMocha.surface,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: CatppuccinMocha.surface0,
          width: 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        onLongPress: onDelete,
        borderRadius: BorderRadius.circular(8),
        child: Padding(
          padding: const EdgeInsets.all(12),
          child: Row(
            children: [
              // Terminal icon
              Container(
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: CatppuccinMocha.green.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(6),
                ),
                child: Icon(
                  Icons.terminal,
                  color: CatppuccinMocha.green,
                  size: 18,
                ),
              ),
              const SizedBox(width: 12),
              // Session info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      session.name,
                      style: const TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                        color: CatppuccinMocha.text,
                      ),
                    ),
                    const SizedBox(height: 2),
                    Text(
                      _formatCreatedAt(session.createdAt),
                      style: const TextStyle(
                        fontSize: 11,
                        color: CatppuccinMocha.overlay1,
                      ),
                    ),
                  ],
                ),
              ),
              // Chevron
              Icon(
                Icons.chevron_right,
                color: CatppuccinMocha.subtext0,
                size: 18,
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatCreatedAt(DateTime dateTime) {
    final now = DateTime.now();
    final diff = now.difference(dateTime);

    if (diff.inMinutes < 1) return 'Just now';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
    if (diff.inHours < 24) return '${diff.inHours}h ago';
    return '${dateTime.month}/${dateTime.day}';
  }
}

================
File: lib/features/project/widgets/vfs_file_picker.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/theme.dart';
import '../../vfs/vfs_notifier.dart';
import '../../vfs/widgets/entry_tile.dart';

/// VFS File Picker for project directory selection
///
/// Phase 02: Project & Session Management
/// Returns selected directory path to caller
class VfsFilePicker extends ConsumerWidget {
  const VfsFilePicker({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final vfsState = ref.watch(vfsProvider);
    final notifier = ref.read(vfsProvider.notifier);

    return Scaffold(
      backgroundColor: CatppuccinMocha.base,
      appBar: AppBar(
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Select Directory'),
            Text(
              vfsState.currentPath,
              style: TextStyle(
                fontSize: 12,
                color: CatppuccinMocha.subtext0,
              ),
            ),
          ],
        ),
        backgroundColor: CatppuccinMocha.mantle,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            if (vfsState.isAtRoot) {
              Navigator.pop(context);
            } else {
              notifier.navigateUp();
            }
          },
        ),
        actions: [
          TextButton.icon(
            icon: const Icon(Icons.check),
            label: const Text('Select'),
            onPressed: () => Navigator.pop(context, vfsState.currentPath),
          ),
        ],
      ),
      body: vfsState.isLoading
          ? const Center(
              child: CircularProgressIndicator(),
            )
          : vfsState.error != null
              ? Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.error_outline,
                        size: 48,
                        color: CatppuccinMocha.red,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Error loading directory',
                        style: TextStyle(
                          color: CatppuccinMocha.text,
                        ),
                      ),
                      const SizedBox(height: 8),
                      Text(
                        vfsState.error!,
                        style: TextStyle(
                          color: CatppuccinMocha.subtext0,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 16),
                      TextButton.icon(
                        icon: const Icon(Icons.refresh),
                        label: const Text('Retry'),
                        onPressed: () => notifier.refresh(),
                      ),
                    ],
                  ),
                )
              : vfsState.entries.isEmpty
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(
                            Icons.folder_open,
                            size: 48,
                            color: CatppuccinMocha.overlay1,
                          ),
                          const SizedBox(height: 16),
                          Text(
                            'Empty directory',
                            style: TextStyle(
                              color: CatppuccinMocha.subtext0,
                            ),
                          ),
                        ],
                      ),
                    )
                  : ListView.builder(
                      padding: const EdgeInsets.all(16),
                      itemCount: vfsState.entries.length,
                      itemBuilder: (context, index) {
                        final entry = vfsState.entries[index];
                        return EntryTile(
                          key: ValueKey(entry.path),
                          entry: entry,
                          onTap: () {
                            if (entry.isDir) {
                              notifier.navigateDown(entry.path);
                            }
                          },
                        );
                      },
                    ),
    );
  }
}

================
File: lib/features/project/project_picker_page.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../connection/connection_providers.dart';
import '../../core/theme.dart';
import 'models/models.dart';
import 'project_providers.dart';
import 'session_picker_page.dart';
import 'widgets/project_list.dart';
import 'widgets/vfs_file_picker.dart';

/// Project Picker Screen
///
/// Phase 02: Project & Session Management
/// Shown after successful connection, before Vibe Session
class ProjectPickerPage extends ConsumerStatefulWidget {
  const ProjectPickerPage({super.key});

  @override
  ConsumerState<ProjectPickerPage> createState() => _ProjectPickerPageState();
}

class _ProjectPickerPageState extends ConsumerState<ProjectPickerPage> {
  @override
  Widget build(BuildContext context) {
    final connectionState = ref.watch(connectionStateProvider);
    final fingerprint = connectionState.currentHost?.fingerprint ?? '';

    if (fingerprint.isEmpty) {
      return Scaffold(
        backgroundColor: CatppuccinMocha.base,
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.error_outline,
                size: 64,
                color: CatppuccinMocha.red,
              ),
              const SizedBox(height: 16),
              Text(
                'Not connected',
                style: TextStyle(
                  fontSize: 18,
                  color: CatppuccinMocha.text,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Please connect to a host first',
                style: TextStyle(
                  color: CatppuccinMocha.subtext0,
                ),
              ),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: CatppuccinMocha.base,
      appBar: AppBar(
        title: const Text('Select Project'),
        backgroundColor: CatppuccinMocha.mantle,
        actions: [
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () => _showCreateProjectDialog(context, fingerprint),
            tooltip: 'Add Project',
          ),
        ],
      ),
      body: ProjectList(
        fingerprint: fingerprint,
        onProjectTap: (project) => _showSessions(context, project),
      ),
    );
  }

  void _showCreateProjectDialog(BuildContext context, String fingerprint) {
    final nameController = TextEditingController();
    final pathController = TextEditingController();
    bool isCreating = false;

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) => AlertDialog(
          backgroundColor: CatppuccinMocha.surface,
          title: Text(
            'New Project',
            style: TextStyle(color: CatppuccinMocha.text),
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Name field
              TextField(
                controller: nameController,
                style: TextStyle(color: CatppuccinMocha.text),
                decoration: InputDecoration(
                  labelText: 'Project Name',
                  hintText: 'e.g., my-app',
                  labelStyle: TextStyle(color: CatppuccinMocha.subtext0),
                  hintStyle: TextStyle(color: CatppuccinMocha.overlay0),
                  filled: true,
                  fillColor: CatppuccinMocha.surface0,
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide.none,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // Path field with Browse button
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: pathController,
                      style: TextStyle(color: CatppuccinMocha.text),
                      decoration: InputDecoration(
                        labelText: 'Project Path',
                        hintText: 'e.g., /Users/dev/my-app',
                        labelStyle: TextStyle(color: CatppuccinMocha.subtext0),
                        hintStyle: TextStyle(color: CatppuccinMocha.overlay0),
                        filled: true,
                        fillColor: CatppuccinMocha.surface0,
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide.none,
                        ),
                      ),
                      enabled: false, // Use Browse button
                    ),
                  ),
                  const SizedBox(width: 8),
                  TextButton.icon(
                    icon: const Icon(Icons.folder_open),
                    label: const Text('Browse'),
                    onPressed: () async {
                      // Use VFS FilePicker (reuse existing VfsNotifier)
                      final selectedPath = await Navigator.push<String>(
                        context,
                        MaterialPageRoute(
                            builder: (_) => const VfsFilePicker()),
                      );
                      if (selectedPath != null) {
                        setDialogState(() {
                          pathController.text = selectedPath;
                        });
                      }
                    },
                  ),
                ],
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(
                'Cancel',
                style: TextStyle(color: CatppuccinMocha.subtext0),
              ),
            ),
            TextButton(
              onPressed: isCreating
                  ? null
                  : () async {
                      final name = nameController.text.trim();
                      final path = pathController.text.trim();

                      // Validate inputs
                      if (name.isEmpty || path.isEmpty) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Please fill all fields')),
                        );
                        return;
                      }

                      // Validate project name (no special chars, max 100)
                      if (!_isValidProjectName(name)) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text(
                              'Invalid name. Use letters, numbers, -, _ only',
                            ),
                            backgroundColor: CatppuccinMocha.red,
                          ),
                        );
                        return;
                      }

                      // Validate path (absolute, no .. traversal)
                      if (!_isValidPath(path)) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Invalid path. Must be absolute path'),
                            backgroundColor: CatppuccinMocha.red,
                          ),
                        );
                        return;
                      }

                      setDialogState(() => isCreating = true);

                      final project = Project.create(
                        name: name,
                        path: path,
                      );

                      await ref
                          .read(projectNotifierProvider(fingerprint).notifier)
                          .addProject(project);

                      if (context.mounted) {
                        Navigator.pop(context);
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('Project "$name" created'),
                            backgroundColor: CatppuccinMocha.green,
                          ),
                        );
                      }
                    },
              child: isCreating
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: CatppuccinMocha.mauve,
                      ),
                    )
                  : const Text('Create'),
            ),
          ],
        ),
      ),
    );
  }

  bool _isValidProjectName(String name) {
    // Allow letters, numbers, hyphen, underscore; max 100 chars
    if (name.length > 100) return false;
    final validPattern = RegExp(r'^[a-zA-Z0-9_-]+$');
    return validPattern.hasMatch(name);
  }

  bool _isValidPath(String path) {
    // Must be absolute path (starts with / on Unix, ~ for home)
    if (!path.startsWith('/') && !path.startsWith('~')) {
      return false;
    }
    // No path traversal attempts
    if (path.contains('..')) {
      return false;
    }
    return true;
  }

  void _showSessions(BuildContext context, Project project) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => SessionPickerPage(project: project),
      ),
    );
  }
}

================
File: lib/features/project/project_providers.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import 'models/models.dart';
import 'project_storage.dart';

/// Provider for projects per connection
final projectsProvider =
    FutureProvider.family<List<Project>, String>((ref, fingerprint) async {
  return ProjectStorage.loadProjects(fingerprint);
});

/// Notifier for project CRUD operations
class ProjectNotifier extends StateNotifier<List<Project>> {
  final String _fingerprint;

  ProjectNotifier(this._fingerprint) : super([]) {
    _loadProjects();
  }

  Future<void> _loadProjects() async {
    try {
      final projects = await ProjectStorage.loadProjects(_fingerprint);
      state = projects;
    } catch (e) {
      state = [];
    }
  }

  Future<void> addProject(Project project) async {
    await ProjectStorage.addProject(_fingerprint, project);
    await _loadProjects();
  }

  Future<void> updateProject(Project project) async {
    await ProjectStorage.updateProject(_fingerprint, project);
    await _loadProjects();
  }

  Future<void> deleteProject(String projectId) async {
    await ProjectStorage.deleteProject(_fingerprint, projectId);
    await _loadProjects();
  }

  Future<void> addSession(String projectId, SessionMetadata session) async {
    await ProjectStorage.addSession(_fingerprint, projectId, session);
    await _loadProjects();
  }

  Future<void> removeSession(String projectId, String sessionId) async {
    await ProjectStorage.removeSession(_fingerprint, projectId, sessionId);
    await _loadProjects();
  }
}

/// Provider for project notifier
final projectNotifierProvider =
    StateNotifierProvider.family<ProjectNotifier, List<Project>, String>(
        (ref, fingerprint) {
  return ProjectNotifier(fingerprint);
});

/// Current UUID generator
const uuidGenerator = Uuid();

================
File: lib/features/project/project_storage.dart
================
import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';

import 'models/models.dart';

/// Local storage for projects per connection
///
/// Phase 01: Project & Session Management
/// Storage key pattern: "projects_{connectionFingerprint}"
class ProjectStorage {
  static const String _keyPrefix = 'projects_';

  /// Get storage key for connection
  static String _key(String fingerprint) => '$_keyPrefix$fingerprint';

  /// Save all projects for specific connection
  static Future<void> saveProjects(
    String fingerprint,
    List<Project> projects,
  ) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = _key(fingerprint);
      final jsonData = jsonEncode(
        projects.map((p) => p.toJson()).toList(),
      );
      await prefs.setString(key, jsonData);
    } catch (e) {
      throw ProjectStorageException('Failed to save projects: $e');
    }
  }

  /// Load all projects for specific connection
  static Future<List<Project>> loadProjects(String fingerprint) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = _key(fingerprint);
      final jsonData = prefs.getString(key);

      if (jsonData == null) return const [];

      final List<dynamic> jsonList = jsonDecode(jsonData);
      return jsonList
          .map((json) =>
              Project.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      throw ProjectStorageException('Failed to load projects: $e');
    }
  }

  /// Add new project to storage
  static Future<void> addProject(
    String fingerprint,
    Project project,
  ) async {
    try {
      final projects = await loadProjects(fingerprint);
      final updated = [...projects, project];
      await saveProjects(fingerprint, updated);
    } catch (e) {
      throw ProjectStorageException('Failed to add project: $e');
    }
  }

  /// Update existing project
  static Future<void> updateProject(
    String fingerprint,
    Project project,
  ) async {
    try {
      final projects = await loadProjects(fingerprint);
      final index = projects.indexWhere((p) => p.id == project.id);
      if (index >= 0) {
        final updated = List<Project>.from(projects);
        updated[index] = project;
        await saveProjects(fingerprint, updated);
      }
    } catch (e) {
      throw ProjectStorageException('Failed to update project: $e');
    }
  }

  /// Delete project from storage
  static Future<void> deleteProject(
    String fingerprint,
    String projectId,
  ) async {
    try {
      final projects = await loadProjects(fingerprint);
      final updated = projects.where((p) => p.id != projectId).toList();
      await saveProjects(fingerprint, updated);
    } catch (e) {
      throw ProjectStorageException('Failed to delete project: $e');
    }
  }

  /// Clear all projects for a connection
  static Future<void> clearProjects(String fingerprint) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_key(fingerprint));
    } catch (e) {
      throw ProjectStorageException('Failed to clear projects: $e');
    }
  }

  /// Check if any projects exist for connection
  static Future<bool> hasProjects(String fingerprint) async {
    try {
      final projects = await loadProjects(fingerprint);
      return projects.isNotEmpty;
    } catch (e) {
      return false;
    }
  }

  /// Add session to project
  static Future<void> addSession(
    String fingerprint,
    String projectId,
    SessionMetadata session,
  ) async {
    try {
      final projects = await loadProjects(fingerprint);
      final index = projects.indexWhere((p) => p.id == projectId);
      if (index >= 0) {
        final updatedProject = projects[index].addSession(session);
        final updated = List<Project>.from(projects);
        updated[index] = updatedProject;
        await saveProjects(fingerprint, updated);
      }
    } catch (e) {
      throw ProjectStorageException('Failed to add session: $e');
    }
  }

  /// Remove session from project
  static Future<void> removeSession(
    String fingerprint,
    String projectId,
    String sessionId,
  ) async {
    try {
      final projects = await loadProjects(fingerprint);
      final index = projects.indexWhere((p) => p.id == projectId);
      if (index >= 0) {
        final updatedProject = projects[index].removeSession(sessionId);
        final updated = List<Project>.from(projects);
        updated[index] = updatedProject;
        await saveProjects(fingerprint, updated);
      }
    } catch (e) {
      throw ProjectStorageException('Failed to remove session: $e');
    }
  }
}

/// Exception for ProjectStorage errors
class ProjectStorageException implements Exception {
  final String message;
  ProjectStorageException(this.message);

  @override
  String toString() => 'ProjectStorageException: $message';
}

================
File: lib/features/project/project.dart
================
// Barrel export for project feature
export 'models/models.dart';
export 'project_storage.dart';
export 'project_providers.dart';
export 'project_picker_page.dart';
export 'session_picker_page.dart';
export 'widgets/project_list.dart';
export 'widgets/project_tile.dart';
export 'widgets/session_list.dart';
export 'widgets/session_tile.dart';
export 'widgets/vfs_file_picker.dart';

================
File: lib/features/project/session_picker_page.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/theme.dart';
import '../connection/connection_providers.dart';
import '../vibe/vibe_session_page.dart';
import 'models/models.dart';
import 'project_providers.dart';
import 'widgets/session_list.dart';

/// Session Picker Screen
///
/// Phase 03: Project & Session Management
/// Shows recent sessions + option to create new one
class SessionPickerPage extends ConsumerStatefulWidget {
  final Project project;

  const SessionPickerPage({
    required this.project,
    super.key,
  });

  @override
  ConsumerState<SessionPickerPage> createState() => _SessionPickerPageState();
}

class _SessionPickerPageState extends ConsumerState<SessionPickerPage> {
  @override
  Widget build(BuildContext context) {
    final connectionState = ref.watch(connectionStateProvider);
    final fingerprint = connectionState.currentHost?.fingerprint ?? '';

    return Scaffold(
      backgroundColor: CatppuccinMocha.base,
      appBar: AppBar(
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Select Session', style: TextStyle(fontSize: 18)),
            Text(
              widget.project.name,
              style: TextStyle(
                fontSize: 12,
                color: CatppuccinMocha.subtext0,
              ),
            ),
          ],
        ),
        backgroundColor: CatppuccinMocha.mantle,
        actions: [
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () => _createNewSession(context, fingerprint),
            tooltip: 'New Session',
          ),
        ],
      ),
      body: SessionList(
        project: widget.project,
        onSessionTap: (session) => _startSession(context, session),
        onDelete: (session) => _handleDeleteSession(context, fingerprint, session),
      ),
    );
  }

  void _createNewSession(BuildContext context, String fingerprint) {
    final defaultName = 'Session ${widget.project.sessions.length + 1}';
    bool isCreating = false;

    showDialog(
      context: context,
      builder: (dialogContext) => StatefulBuilder(
        builder: (dialogContext, setDialogState) {
          final nameController = TextEditingController(text: defaultName);

          return AlertDialog(
            backgroundColor: CatppuccinMocha.surface,
            title: Text(
              'New Session',
              style: TextStyle(color: CatppuccinMocha.text),
            ),
            content: TextField(
              controller: nameController,
              style: TextStyle(color: CatppuccinMocha.text),
              decoration: InputDecoration(
                labelText: 'Session Name',
                labelStyle: TextStyle(color: CatppuccinMocha.subtext0),
                hintStyle: TextStyle(color: CatppuccinMocha.overlay0),
                filled: true,
                fillColor: CatppuccinMocha.surface0,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: BorderSide.none,
                ),
              ),
              autofocus: true,
            ),
            actions: [
              TextButton(
                onPressed: isCreating
                    ? null
                    : () => Navigator.pop(dialogContext),
                child: Text(
                  'Cancel',
                  style: TextStyle(color: CatppuccinMocha.subtext0),
                ),
              ),
              TextButton(
                onPressed: isCreating
                    ? null
                    : () async {
                        final name = nameController.text.trim();

                        // Validate session name
                        if (name.isEmpty) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                              content: Text('Please enter a session name'),
                              backgroundColor: CatppuccinMocha.red,
                            ),
                          );
                          return;
                        }

                        if (!_isValidSessionName(name)) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                              content: Text(
                                'Invalid name. Use letters, numbers, -, _ only (max 50 chars)',
                              ),
                              backgroundColor: CatppuccinMocha.red,
                            ),
                          );
                          return;
                        }

                        setDialogState(() => isCreating = true);

                        final session = SessionMetadata.create(name: name);

                        await ref
                            .read(projectNotifierProvider(fingerprint).notifier)
                            .addSession(widget.project.id, session);

                        // Clean up controller
                        nameController.dispose();

                        if (context.mounted) {
                          Navigator.pop(dialogContext);
                          _startSession(context, session);
                        }
                      },
                child: isCreating
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: CatppuccinMocha.mauve,
                        ),
                      )
                    : const Text('Create'),
              ),
            ],
          );
        },
      ),
    );
  }

  bool _isValidSessionName(String name) {
    // Allow letters, numbers, hyphen, underscore; max 50 chars
    if (name.length > 50) return false;
    final validPattern = RegExp(r'^[a-zA-Z0-9_\-\s]+$');
    return validPattern.hasMatch(name);
  }

  void _startSession(BuildContext context, SessionMetadata session) {
    // Phase 05: Navigate to VibeSessionPage with project + session context
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(
        builder: (_) => VibeSessionPage(
          project: widget.project,
          session: session,
        ),
      ),
    );
  }

  void _handleDeleteSession(
    BuildContext context,
    String fingerprint,
    SessionMetadata session,
  ) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: CatppuccinMocha.surface,
        title: Text(
          'Delete Session',
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        content: Text(
          'Delete "${session.name}"?',
          style: TextStyle(color: CatppuccinMocha.subtext0),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(
              'Cancel',
              style: TextStyle(color: CatppuccinMocha.subtext0),
            ),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text(
              'Delete',
              style: TextStyle(color: CatppuccinMocha.red),
            ),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      await ref
          .read(projectNotifierProvider(fingerprint).notifier)
          .removeSession(widget.project.id, session.id);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Session "${session.name}" deleted'),
            backgroundColor: CatppuccinMocha.green,
          ),
        );
      }
    }
  }
}

================
File: lib/features/qr_scanner/qr_scanner_page.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import '../connection/connection_providers.dart';
import '../project/project_picker_page.dart';
import '../../core/theme.dart';
import 'dart:convert';

/// QR Scanner page
///
/// Phase 06: Refactor to Riverpod
/// Scans QR code containing connection details (IP, port, token, fingerprint)
class QrScannerPage extends ConsumerStatefulWidget {
  const QrScannerPage({super.key});

  @override
  ConsumerState<QrScannerPage> createState() => _QrScannerPageState();
}

class _QrScannerPageState extends ConsumerState<QrScannerPage> {
  final MobileScannerController _controller = MobileScannerController();
  bool _isScanning = true;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  /// Handle QR code detection
  void _onDetect(BarcodeCapture capture) {
    if (!_isScanning) return;

    for (final barcode in capture.barcodes) {
      if (barcode.rawValue != null) {
        _handleQrCode(barcode.rawValue!);
        break;
      }
    }
  }

  /// Process scanned QR code
  void _handleQrCode(String rawJson) {
    setState(() => _isScanning = false);

    // Validate QR payload format before connecting
    if (!_isValidQrPayload(rawJson)) {
      _showError('Invalid QR code format');
      setState(() => _isScanning = true);
      return;
    }

    // Connect using connection provider
    _connect(rawJson);
  }

  /// Validate QR payload has required fields
  bool _isValidQrPayload(String json) {
    try {
      final decoded = jsonDecode(json) as Map<String, dynamic>;
      return decoded['ip'] is String &&
          (decoded['port'] is int) &&
          decoded['token'] is String &&
          decoded['fingerprint'] is String;
    } catch (_) {
      return false;
    }
  }

  /// Connect to host via provider
  Future<void> _connect(String qrJson) async {
    try {
      await ref.read(connectionStateProvider.notifier).connect(qrJson);

      if (mounted) {
        // Navigate to Project Picker on success
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const ProjectPickerPage()),
        );
      }
    } catch (e) {
      if (mounted) {
        _showError('Connection failed: $e');
        setState(() => _isScanning = true);
      }
    }
  }

  /// Show error message
  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: CatppuccinMocha.red,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scan QR Code'),
        backgroundColor: CatppuccinMocha.mantle,
      ),
      body: Stack(
        children: [
          // Camera preview
          MobileScanner(
            controller: _controller,
            onDetect: _onDetect,
          ),

          // Dark overlay
          Container(
            color: Colors.black.withValues(alpha: 0.3),
          ),

          // Scan frame
          Center(
            child: Container(
              width: 280,
              height: 280,
              decoration: BoxDecoration(
                border: Border.all(
                  color: CatppuccinMocha.lavender,
                  width: 4,
                ),
                borderRadius: BorderRadius.circular(24),
              ),
              // Corner markers
              child: Stack(
                children: [
                  // Top-left
                  Positioned(
                    top: 0,
                    left: 0,
                    child: Container(
                      width: 32,
                      height: 32,
                      decoration: BoxDecoration(
                        border: Border(
                          top: BorderSide(color: CatppuccinMocha.green, width: 4),
                          left: BorderSide(color: CatppuccinMocha.green, width: 4),
                        ),
                        borderRadius: const BorderRadius.only(
                          topLeft: Radius.circular(20),
                        ),
                      ),
                    ),
                  ),
                  // Top-right
                  Positioned(
                    top: 0,
                    right: 0,
                    child: Container(
                      width: 32,
                      height: 32,
                      decoration: BoxDecoration(
                        border: Border(
                          top: BorderSide(color: CatppuccinMocha.green, width: 4),
                          right: BorderSide(color: CatppuccinMocha.green, width: 4),
                        ),
                        borderRadius: const BorderRadius.only(
                          topRight: Radius.circular(20),
                        ),
                      ),
                    ),
                  ),
                  // Bottom-left
                  Positioned(
                    bottom: 0,
                    left: 0,
                    child: Container(
                      width: 32,
                      height: 32,
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(color: CatppuccinMocha.green, width: 4),
                          left: BorderSide(color: CatppuccinMocha.green, width: 4),
                        ),
                        borderRadius: const BorderRadius.only(
                          bottomLeft: Radius.circular(20),
                        ),
                      ),
                    ),
                  ),
                  // Bottom-right
                  Positioned(
                    bottom: 0,
                    right: 0,
                    child: Container(
                      width: 32,
                      height: 32,
                      decoration: BoxDecoration(
                        border: Border(
                          bottom: BorderSide(color: CatppuccinMocha.green, width: 4),
                          right: BorderSide(color: CatppuccinMocha.green, width: 4),
                        ),
                        borderRadius: const BorderRadius.only(
                          bottomRight: Radius.circular(20),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),

          // Instructions
          Positioned(
            bottom: 100,
            left: 0,
            right: 0,
            child: Center(
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                decoration: BoxDecoration(
                  color: CatppuccinMocha.mantle.withValues(alpha: 0.9),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  'Align QR code within frame',
                  style: TextStyle(
                    color: CatppuccinMocha.text,
                    fontSize: 16,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

================
File: lib/features/vfs/widgets/entry_tile.dart
================
import 'package:flutter/material.dart';
import '../../../../core/theme.dart';
import '../../../models/dir_entry.dart';

/// File/folder entry tile for VFS browser
///
/// Phase VFS-2: UI component for directory entries
class EntryTile extends StatelessWidget {
  final VfsEntry entry;
  final VoidCallback onTap;

  const EntryTile({
    super.key,
    required this.entry,
    required this.onTap,
  });

  bool get _isDir => entry.isDir;

  String get _name => entry.name;

  String? _formattedSize() {
    return entry.formattedSize;
  }

  @override
  Widget build(BuildContext context) {
    final isDir = _isDir;
    final name = _name;

    return ListTile(
      leading: Icon(
        isDir ? Icons.folder : Icons.insert_drive_file_outlined,
        color: isDir
            ? CatppuccinMocha.yellow
            : CatppuccinMocha.blue,
      ),
      title: Text(
        name,
        style: TextStyle(
          color: CatppuccinMocha.text,
          fontWeight: isDir ? FontWeight.w500 : FontWeight.normal,
        ),
      ),
      subtitle: isDir
          ? null
          : Text(
              _formattedSize() ?? '',
              style: TextStyle(
                color: CatppuccinMocha.subtext0,
                fontSize: 12,
              ),
            ),
      trailing: Icon(
        Icons.chevron_right,
        size: 16,
        color: CatppuccinMocha.overlay0,
      ),
      onTap: onTap,
    );
  }
}

================
File: lib/features/vfs/vfs_notifier.dart
================
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../bridge/bridge_wrapper.dart';
import '../../../models/dir_entry.dart';

/// VFS state for directory browsing
class VfsState {
  final String currentPath;
  final List<VfsEntry> entries;
  final bool isLoading;
  final bool hasMore;
  final String? error;

  const VfsState({
    required this.currentPath,
    this.entries = const [],
    this.isLoading = false,
    this.hasMore = false,
    this.error,
  });

  /// Initial state (root directory)
  factory VfsState.initial() {
    return VfsState(
      currentPath: '/',
      entries: [],
      isLoading: false,
    );
  }

  /// Copy with for immutable state updates
  VfsState copyWith({
    String? currentPath,
    List<VfsEntry>? entries,
    bool? isLoading,
    bool? hasMore,
    String? error,
  }) {
    return VfsState(
      currentPath: currentPath ?? this.currentPath,
      entries: entries ?? this.entries,
      isLoading: isLoading ?? this.isLoading,
      hasMore: hasMore ?? this.hasMore,
      error: error ?? this.error,
    );
  }

  /// Check if at root directory
  bool get isAtRoot => currentPath == '/' || currentPath == '.' || currentPath.isEmpty;

  /// Get parent path
  String get parentPath {
    if (isAtRoot) return currentPath;
    final parts = currentPath.split('/')..removeWhere((p) => p.isEmpty);
    if (parts.length <= 1) return '/';
    parts.removeLast();
    return '/${parts.join('/')}';
  }

  /// Get display name (basename of current path)
  String get displayName {
    if (isAtRoot) return '/';
    final parts = currentPath.split('/')..removeWhere((p) => p.isEmpty);
    return parts.last;
  }
}

/// VFS Notifier for directory browsing
///
/// Phase VFS-2: State management for file browser
/// Phase VFS-Fix: Stream now emits single chunk with all data (no race condition)
class VfsNotifier extends StateNotifier<VfsState> {
  final BridgeWrapper _bridge;
  StreamSubscription<List<VfsEntry>>? _dirSubscription;

  VfsNotifier(this._bridge) : super(VfsState.initial());

  /// Load directory entries from server using Stream API
  ///
  /// Phase VFS-Fix: Stream emits single chunk with all entries.
  /// Rust side collects all data before sending  no race condition.
  Future<void> loadDirectory(String path) async {
    // Cancel old stream
    await _dirSubscription?.cancel();
    _dirSubscription = null;

    // Update path and loading state
    state = state.copyWith(
      currentPath: path,
      isLoading: true,
      error: null,
      entries: [],  // Clear old entries while loading
    );

    try {
      // Stream-based directory listing
      // Rust now waits for ALL data before emitting single chunk
      _dirSubscription = _bridge.listDirectory(path).listen(
        // onData: Single chunk with all entries
        (entries) {
          debugPrint(' [VfsNotifier] RAW entries: ${entries.length}');

          // CRITICAL: Create NEW list to avoid mutating original
          // Also sort safely
          final sortedEntries = List<VfsEntry>.from(entries);
          sortedEntries.sort((a, b) {
            if (a.isDir != b.isDir) return a.isDir ? -1 : 1;
            return a.name.compareTo(b.name);
          });

          // CRITICAL: Set ALL fields explicitly to avoid any issues
          final newState = VfsState(
            currentPath: path,
            entries: sortedEntries,
            isLoading: false,
            hasMore: false,
            error: null,
          );

          state = newState;
          debugPrint(' [VfsNotifier] Updated state: path=$path, entries=${sortedEntries.length}, isLoading=false');
        },
        // onError
        onError: (error) {
          state = state.copyWith(
            isLoading: false,
            error: error.toString(),
          );
          debugPrint(' [VfsNotifier] Stream error: $error');
        },
        // onDone
        onDone: () {
          // Phase VFS-Fix: Do NOT modify state here!
          // onData already set isLoading=false and entries
          // onDone fires after, so we should not overwrite anything
          debugPrint(' [VfsNotifier] Stream done (state has ${state.entries.length} entries)');
        },
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  /// Navigate to parent directory
  void navigateUp() {
    if (state.isAtRoot) return;
    final parent = state.parentPath;
    loadDirectory(parent);
  }

  /// Navigate into child directory
  void navigateDown(String childPath) {
    loadDirectory(childPath);
  }

  /// Refresh current directory (cancel + restart)
  void refresh() {
    loadDirectory(state.currentPath);
  }

  /// Clear error state
  void clearError() {
    if (state.error != null) {
      state = state.copyWith(error: null);
    }
  }

  @override
  void dispose() {
    // Cancel stream to prevent memory leak
    _dirSubscription?.cancel();
    super.dispose();
  }
}

/// Riverpod provider for VFS state
final vfsProvider = StateNotifierProvider<VfsNotifier, VfsState>((ref) {
  final bridge = ref.watch(bridgeWrapperProvider);
  return VfsNotifier(bridge);
});

================
File: lib/features/vibe/models/file_attachment.dart
================
/// File attachment format for Vibe Coding prompts
enum AttachmentFormat {
  /// Path reference only: `Refactor @lib/models/user.dart`
  path,

  /// Full content: `Here's the file:\n\`\`\`dart\n{content}\n\`\`\``
  content,
}

extension AttachmentFormatExtension on AttachmentFormat {
  String get label {
    switch (this) {
      case AttachmentFormat.path:
        return 'Path only (@file)';
      case AttachmentFormat.content:
        return 'Full content';
    }
  }

  String formatAttachment(String path, String content) {
    switch (this) {
      case AttachmentFormat.path:
        return '@$path';
      case AttachmentFormat.content:
        return 'Here is `$path`:\n```\n$content\n```\n';
    }
  }
}

================
File: lib/features/vibe/models/output_block.dart
================
/// Output block types for parsed terminal output
enum BlockType {
  /// Raw text (fallback for unrecognized patterns)
  raw,

  /// File path: lib/.../file.dart
  file,

  /// Git diff: + added, - removed
  diff,

  /// List items: - item, * item
  list,

  /// Plan steps: 1. Step one
  plan,

  /// Error message
  error,

  /// Question prompt: (Y/n), (y/N)
  question,

  /// Code block: ```lang ... ```
  code,

  /// Tool use: running command, reading file
  tool,
}

/// Parsed output block for enhanced display
class OutputBlock {
  final BlockType type;
  final String content;
  final List<OutputBlock>? children;
  bool isCollapsed;
  final Map<String, String>? metadata;

  OutputBlock({
    required this.type,
    required this.content,
    this.children,
    this.isCollapsed = false,
    this.metadata,
  });

  OutputBlock copyWith({
    BlockType? type,
    String? content,
    List<OutputBlock>? children,
    bool? isCollapsed,
    Map<String, String>? metadata,
  }) {
    return OutputBlock(
      type: type ?? this.type,
      content: content ?? this.content,
      children: children ?? this.children,
      isCollapsed: isCollapsed ?? this.isCollapsed,
      metadata: metadata ?? this.metadata,
    );
  }

  /// Check if block has collapsible content
  bool get isCollapsible => children != null && children!.isNotEmpty;

  /// Check if block is a diff line
  bool get isDiffAdded => type == BlockType.diff && content.startsWith('+');
  bool get isDiffRemoved => type == BlockType.diff && content.startsWith('-');

  /// Get file path if this is a file block
  String? get filePath {
    if (type == BlockType.file) {
      return content.trim();
    }
    return metadata?['path'];
  }

  /// Get question options if this is a question block
  List<String>? get questionOptions {
    if (type == BlockType.question && metadata != null) {
      final opts = metadata!['options'];
      if (opts != null) return opts.split(',');
    }
    return null;
  }
}

================
File: lib/features/vibe/models/output_buffer.dart
================
/// Bounded output buffer to prevent memory issues with large output
///
/// Limits buffer size by dropping oldest lines when exceeding MAX_LINES.
/// This prevents memory growth issues with long-running sessions.
class OutputBuffer {
  /// Maximum number of lines to keep in buffer
  static const int maxLines = 10000;

  /// Maximum size per line in bytes (to prevent single huge lines)
  static const int maxLineBytes = 4096;

  final List<String> _lines = [];
  int _totalBytes = 0;

  /// Current number of lines in buffer
  int get length => _lines.length;

  /// Whether buffer is at capacity
  bool get isFull => _lines.length >= maxLines;

  /// Whether buffer is empty
  bool get isEmpty => _lines.isEmpty;

  /// Get all lines currently in buffer
  List<String> get lines => List.unmodifiable(_lines);

  /// Add a line to buffer
  ///
  /// If buffer exceeds maxLines, oldest lines are dropped.
  /// If line exceeds maxLineBytes, it is truncated.
  void add(String line) {
    // Truncate huge lines
    final sanitized = _sanitizeLine(line);

    _lines.add(sanitized);
    _totalBytes += sanitized.length;

    // Drop oldest if over capacity
    while (_lines.length > maxLines) {
      final removed = _lines.removeAt(0);
      _totalBytes -= removed.length;
    }
  }

  /// Add multiple lines at once
  void addAll(List<String> lines) {
    for (final line in lines) {
      add(line);
    }
  }

  /// Clear all lines from buffer
  void clear() {
    _lines.clear();
    _totalBytes = 0;
  }

  /// Get a range of lines
  List<String> getRange(int start, int end) {
    if (start < 0) start = 0;
    if (end > _lines.length) end = _lines.length;
    if (start >= end) return [];

    return List.unmodifiable(_lines.sublist(start, end));
  }

  /// Get last N lines
  List<String> getLast(int count) {
    if (count <= 0) return [];
    if (count >= _lines.length) return List.unmodifiable(_lines);

    return List.unmodifiable(
      _lines.sublist(_lines.length - count),
    );
  }

  /// Approximate memory usage in bytes
  int get memoryUsage => _totalBytes;

  /// Sanitize a line to prevent buffer overflow issues
  String _sanitizeLine(String line) {
    // Truncate if too long
    if (line.length > maxLineBytes) {
      return '${line.substring(0, maxLineBytes)}\n<TRUNCATED>';
    }
    return line;
  }

  /// Convert buffer to single string
  @override
  String toString() {
    return _lines.join('\n');
  }

  /// Get buffer statistics
  Map<String, dynamic> get stats => {
        'lines': _lines.length,
        'maxLines': maxLines,
        'bytes': _totalBytes,
        'isFull': isFull,
      };
}

================
File: lib/features/vibe/models/session_status.dart
================
/// Session status for Vibe Coding multi-session
///
/// Phase 02: Multi-Session Tab Architecture
enum SessionStatus {
  /// Currently viewing/active
  active,

  /// Running in background
  idle,

  /// Claude is processing
  busy,

  /// PTY died/corrupted
  error,
}

extension SessionStatusExtension on SessionStatus {
  String get label {
    switch (this) {
      case SessionStatus.active:
        return 'Active';
      case SessionStatus.idle:
        return 'Idle';
      case SessionStatus.busy:
        return 'Busy';
      case SessionStatus.error:
        return 'Error';
    }
  }

  /// Indicator color for UI
  String colorHex() {
    switch (this) {
      case SessionStatus.active:
        return '#89b4fa'; // CatppuccinMocha.blue
      case SessionStatus.idle:
        return '#a6adc8'; // CatppuccinMocha.overlay1
      case SessionStatus.busy:
        return '#f9e2af'; // CatppuccinMocha.yellow
      case SessionStatus.error:
        return '#f38ba8'; // CatppuccinMocha.red
    }
  }
}

================
File: lib/features/vibe/models/special_key.dart
================
/// Special keys for terminal interaction
enum SpecialKey {
  arrowUp,
  arrowDown,
  enter,
  ctrlC,
}

extension SpecialKeyExtension on SpecialKey {
  String get sequence {
    switch (this) {
      case SpecialKey.arrowUp:
        return '\x1b[A';
      case SpecialKey.arrowDown:
        return '\x1b[B';
      case SpecialKey.enter:
        return '\r';
      case SpecialKey.ctrlC:
        return '\x03';
    }
  }

  String get label {
    switch (this) {
      case SpecialKey.arrowUp:
        return '';
      case SpecialKey.arrowDown:
        return '';
      case SpecialKey.enter:
        return 'Enter';
      case SpecialKey.ctrlC:
        return 'Ctrl+C';
    }
  }

  /// Get all special key values
  static List<SpecialKey> get values => [
    SpecialKey.arrowUp,
    SpecialKey.arrowDown,
    SpecialKey.enter,
    SpecialKey.ctrlC,
  ];
}

================
File: lib/features/vibe/models/vibe_session_state.dart
================
import 'package:xterm/xterm.dart';

/// Vibe session state management
class VibeSessionState {
  final bool isConnected;
  final bool isOutputModeRaw;
  final Terminal terminal;
  final bool isSending;
  final String? error;

  VibeSessionState({
    this.isConnected = false,
    this.isOutputModeRaw = true,
    Terminal? terminal,
    this.isSending = false,
    this.error,
  }) : terminal = terminal ?? Terminal(maxLines: 10000);

  VibeSessionState copyWith({
    bool? isConnected,
    bool? isOutputModeRaw,
    Terminal? terminal,
    bool? isSending,
    String? error,
  }) {
    return VibeSessionState(
      isConnected: isConnected ?? this.isConnected,
      isOutputModeRaw: isOutputModeRaw ?? this.isOutputModeRaw,
      terminal: terminal ?? this.terminal,
      isSending: isSending ?? this.isSending,
      error: error,
    );
  }
}

================
File: lib/features/vibe/models/vibe_session.dart
================
import 'package:xterm/xterm.dart';

import 'session_status.dart';

/// Single Vibe session model
///
/// Phase 02: Multi-Session Tab Architecture
/// Each session represents a PTY connection to a project
class VibeSession {
  final String id;
  final String projectName; // e.g., "api", "mobile", "web"
  final String projectPath; // e.g., ~/dev/api
  final SessionStatus status;
  final Terminal terminal;
  final DateTime createdAt;
  final DateTime lastActive;

  const VibeSession({
    required this.id,
    required this.projectName,
    required this.projectPath,
    required this.status,
    required this.terminal,
    required this.createdAt,
    required this.lastActive,
  });

  /// Create a new session
  factory VibeSession.create({
    required String projectName,
    required String projectPath,
    required Terminal terminal,
  }) {
    final now = DateTime.now();
    return VibeSession(
      id: now.millisecondsSinceEpoch.toString(),
      projectName: projectName,
      projectPath: projectPath,
      status: SessionStatus.active,
      terminal: terminal,
      createdAt: now,
      lastActive: now,
    );
  }

  /// Copy with modified fields
  VibeSession copyWith({
    String? id,
    String? projectName,
    String? projectPath,
    SessionStatus? status,
    Terminal? terminal,
    DateTime? createdAt,
    DateTime? lastActive,
  }) {
    return VibeSession(
      id: id ?? this.id,
      projectName: projectName ?? this.projectName,
      projectPath: projectPath ?? this.projectPath,
      status: status ?? this.status,
      terminal: terminal ?? this.terminal,
      createdAt: createdAt ?? this.createdAt,
      lastActive: lastActive ?? this.lastActive,
    );
  }

  /// Update last active time
  VibeSession touch() {
    return copyWith(lastActive: DateTime.now());
  }

  /// Check if session is stale (idle > 30 min)
  bool get isStale {
    final diff = DateTime.now().difference(lastActive);
    return diff.inMinutes > 30;
  }

  /// Convert to JSON for persistence
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'projectName': projectName,
      'projectPath': projectPath,
      'status': status.name,
      'createdAt': createdAt.toIso8601String(),
      'lastActive': lastActive.toIso8601String(),
    };
  }

  /// Create from JSON
  factory VibeSession.fromJson(Map<String, dynamic> json, Terminal terminal) {
    return VibeSession(
      id: json['id'] as String,
      projectName: json['projectName'] as String,
      projectPath: json['projectPath'] as String,
      status: SessionStatus.values.firstWhere(
        (e) => e.name == json['status'],
        orElse: () => SessionStatus.idle,
      ),
      terminal: terminal,
      createdAt: DateTime.parse(json['createdAt'] as String),
      lastActive: DateTime.parse(json['lastActive'] as String),
    );
  }
}

================
File: lib/features/vibe/services/haptic_service.dart
================
import 'package:haptic_feedback/haptic_feedback.dart';

/// Haptic feedback service for Vibe Coding
///
/// Provides typed haptic feedback methods for different interaction types.
/// Uses iOS Haptic Feedback API natively on supported devices.
class HapticService {
  HapticService._();

  /// Light haptic for subtle feedback
  /// Use for: file attached, small interactions
  static Future<void> light() async {
    try {
      await Haptics.vibrate(HapticsType.light);
    } catch (_) {
      // Silently fail on unsupported devices
    }
  }

  /// Medium haptic for standard interactions
  /// Use for: send prompt, session switched
  static Future<void> medium() async {
    try {
      await Haptics.vibrate(HapticsType.medium);
    } catch (_) {
      // Silently fail on unsupported devices
    }
  }

  /// Heavy haptic for important feedback
  /// Use for: errors, warnings
  static Future<void> heavy() async {
    try {
      await Haptics.vibrate(HapticsType.heavy);
    } catch (_) {
      // Silently fail on unsupported devices
    }
  }

  /// Selection haptic for UI selection
  /// Use for: quick key press, toggle switches
  static Future<void> selection() async {
    try {
      await Haptics.vibrate(HapticsType.selection);
    } catch (_) {
      // Silently fail on unsupported devices
    }
  }

  /// Success haptic for positive feedback
  /// Use for: operation completed successfully
  static Future<void> success() async {
    try {
      await Haptics.vibrate(HapticsType.success);
    } catch (_) {
      // Silently fail on unsupported devices
    }
  }

  /// Warning haptic
  static Future<void> warning() async {
    try {
      await Haptics.vibrate(HapticsType.warning);
    } catch (_) {
      // Silently fail on unsupported devices
    }
  }

  /// Error haptic
  /// Use for: error occurred
  static Future<void> error() async {
    try {
      await Haptics.vibrate(HapticsType.error);
    } catch (_) {
      // Silently fail on unsupported devices
    }
  }

  /// Notification haptic (deprecated - use specific type)
  /// Kept for backward compatibility
  static Future<void> notification({required bool success}) async {
    if (success) {
      await HapticService.success();
    } else {
      await HapticService.error();
    }
  }
}

================
File: lib/features/vibe/services/session_manager.dart
================
import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:xterm/xterm.dart';

import '../../../bridge/bridge_wrapper.dart';
import '../models/session_status.dart';
import '../models/vibe_session.dart';

/// Session state for multi-session management
class SessionState {
  final Map<String, VibeSession> sessions;
  final String? activeSessionId;
  final String? error;

  const SessionState({
    this.sessions = const {},
    this.activeSessionId,
    this.error,
  });

  VibeSession? get activeSession =>
      activeSessionId != null ? sessions[activeSessionId] : null;

  List<VibeSession> get sessionList => sessions.values.toList()
    ..sort((a, b) => b.lastActive.compareTo(a.lastActive));

  SessionState copyWith({
    Map<String, VibeSession>? sessions,
    String? activeSessionId,
    String? error,
  }) {
    return SessionState(
      sessions: sessions ?? this.sessions,
      activeSessionId: activeSessionId ?? this.activeSessionId,
      error: error,
    );
  }
}

/// Session manager provider
///
/// Phase 02: Multi-Session Tab Architecture
/// Phase 05: Added backend integration via BridgeWrapper
/// Manages multiple PTY sessions with persistence
final sessionManagerProvider =
    StateNotifierProvider<SessionManager, SessionState>((ref) {
  final bridge = ref.watch(bridgeWrapperProvider);
  return SessionManager(bridge);
});

/// Session manager for multi-PTY support
///
/// Features:
/// - Max 5 sessions limit
/// - 30-minute idle timeout
/// - Persistence to shared_preferences
/// - Phase 05: Backend integration for remote sessions
class SessionManager extends StateNotifier<SessionState> {
  static const String _keySessions = 'vibe_sessions';
  static const String _keyActive = 'vibe_active_session';
  static const int _maxSessions = 5;
  // ignore: unused_field
  static const int _idleTimeoutMinutes = 30;

  Timer? _idleCheckTimer;
  SharedPreferences? _prefs;
  final BridgeWrapper _bridge;

  SessionManager(this._bridge) : super(const SessionState()) {
    _init();
  }

  Future<void> _init() async {
    _prefs = await SharedPreferences.getInstance();
    await _loadSessions();
    _startIdleCheck();
  }

  /// Start idle check timer
  void _startIdleCheck() {
    _idleCheckTimer?.cancel();
    _idleCheckTimer = Timer.periodic(
      const Duration(minutes: 5),
      (_) => _checkIdleSessions(),
    );
  }

  /// Check and close idle sessions
  void _checkIdleSessions() {
    final staleSessions = <String>[];
    for (final session in state.sessions.values) {
      if (session.isStale && session.id != state.activeSessionId) {
        staleSessions.add(session.id);
      }
    }
    for (final id in staleSessions) {
      closeSession(id);
    }
  }

  /// Create new session
  Future<bool> createSession({
    required String projectPath,
    required String projectName,
  }) async {
    // Check limit
    if (state.sessions.length >= _maxSessions) {
      state = state.copyWith(error: 'Max sessions ($_maxSessions) reached');
      return false;
    }

    // Create new terminal for this session
    final terminal = Terminal();

    final session = VibeSession.create(
      projectName: projectName,
      projectPath: projectPath,
      terminal: terminal,
    );

    final newSessions = Map<String, VibeSession>.from(state.sessions);
    newSessions[session.id] = session;

    state = state.copyWith(
      sessions: newSessions,
      activeSessionId: session.id,
      error: null,
    );

    await _saveSessions();
    return true;
  }

  /// Switch active session
  ///
  /// Phase 05: Also notifies backend to switch active session
  Future<void> switchSession(String sessionId) async {
    if (!state.sessions.containsKey(sessionId)) {
      state = state.copyWith(error: 'Session not found');
      return;
    }

    final session = state.sessions[sessionId]!;
    final updated = session.touch();

    final newSessions = Map<String, VibeSession>.from(state.sessions);
    newSessions[sessionId] = updated;

    state = state.copyWith(
      sessions: newSessions,
      activeSessionId: sessionId,
      error: null,
    );

    await _saveSessions();

    // Phase 05: Notify backend to switch session
    try {
      await _bridge.switchSession(sessionId);
    } catch (e) {
      debugPrint(' Failed to switch backend session: $e');
    }
  }

  /// Close session
  ///
  /// Phase 05: Also notifies backend to close session
  Future<void> closeSession(String sessionId) async {
    // Phase 05: Notify backend first
    try {
      await _bridge.closeSession(sessionId);
    } catch (e) {
      debugPrint(' Failed to close backend session: $e');
    }

    final newSessions = Map<String, VibeSession>.from(state.sessions);
    newSessions.remove(sessionId);

    String? newActiveId = state.activeSessionId;
    if (newActiveId == sessionId) {
      newActiveId = newSessions.isEmpty ? null : newSessions.keys.first;
    }

    state = state.copyWith(
      sessions: newSessions,
      activeSessionId: newActiveId,
    );

    await _saveSessions();
  }

  /// Rename session
  void renameSession(String sessionId, String newName) {
    final session = state.sessions[sessionId];
    if (session == null) return;

    final newSessions = Map<String, VibeSession>.from(state.sessions);
    newSessions[sessionId] = session.copyWith(projectName: newName);

    state = state.copyWith(sessions: newSessions);
    _saveSessions();
  }

  /// Update session status
  void updateStatus(String sessionId, SessionStatus status) {
    final session = state.sessions[sessionId];
    if (session == null) return;

    final newSessions = Map<String, VibeSession>.from(state.sessions);
    newSessions[sessionId] = session.copyWith(
      status: status,
      lastActive: DateTime.now(),
    );

    state = state.copyWith(sessions: newSessions);
  }

  /// Clear error state
  void clearError() {
    state = state.copyWith(error: null);
  }

  /// Save sessions to preferences
  Future<void> _saveSessions() async {
    final prefs = _prefs;
    if (prefs == null) return;

    try {
      // Save session metadata (without Terminal which isn't serializable)
      final sessionsJson = <String, dynamic>{};
      for (final session in state.sessions.values) {
        sessionsJson[session.id] = session.toJson();
      }
      await prefs.setString(_keySessions, jsonEncode(sessionsJson));

      if (state.activeSessionId != null) {
        await prefs.setString(_keyActive, state.activeSessionId!);
      } else {
        await prefs.remove(_keyActive);
      }
    } catch (e) {
      debugPrint(' Failed to save sessions: $e');
    }
  }

  /// Load sessions from preferences
  Future<void> _loadSessions() async {
    final prefs = _prefs;
    if (prefs == null) return;

    try {
      final sessionsJsonStr = prefs.getString(_keySessions);
      if (sessionsJsonStr == null) return;

      final sessionsJson = jsonDecode(sessionsJsonStr) as Map<String, dynamic>;
      final activeId = prefs.getString(_keyActive);

      final restoredSessions = <String, VibeSession>{};

      for (final entry in sessionsJson.entries) {
        // Create new terminal for restored session
        final terminal = Terminal();
        final session = VibeSession.fromJson(
          entry.value as Map<String, dynamic>,
          terminal,
        );
        restoredSessions[session.id] = session;
      }

      state = SessionState(
        sessions: restoredSessions,
        activeSessionId:
            restoredSessions.containsKey(activeId) ? activeId : null,
      );
    } catch (e) {
      debugPrint(' Failed to load sessions: $e');
    }
  }

  @override
  void dispose() {
    _idleCheckTimer?.cancel();
    super.dispose();
  }
}

================
File: lib/features/vibe/services/speech_service_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'speech_service.dart';

/// Provider for SpeechService
///
/// Phase 02: Dictation Integration
final speechServiceProvider =
    StateNotifierProvider<SpeechServiceNotifier, SpeechState>((ref) {
  return SpeechServiceNotifier();
});

/// Notifier for SpeechService state management
class SpeechServiceNotifier extends StateNotifier<SpeechState> {
  SpeechService? _service;

  SpeechServiceNotifier() : super(const SpeechState());

  /// Get or create the service instance
  SpeechService get _speechService {
    _service ??= SpeechService();
    return _service!;
  }

  /// Initialize speech recognition
  Future<void> initialize() async {
    final success = await _speechService.initialize();
    state = state.copyWith(isInitialized: success);
  }

  /// Start listening with Vietnamese language
  Future<bool> startListening({
    required Function(String text) onResult,
  }) async {
    final success = await _speechService.startListening(
      onResult: (text) {
        state = state.copyWith(lastRecognizedText: text);
        onResult(text);
      },
    );
    state = state.copyWith(isListening: success);
    return success;
  }

  /// Stop listening
  Future<void> stopListening() async {
    await _speechService.stopListening();
    state = state.copyWith(isListening: false);
  }

  /// Cancel listening immediately
  Future<void> cancel() async {
    await _speechService.cancelListening();
    state = state.copyWith(isListening: false);
  }
}

================
File: lib/features/vibe/services/speech_service.dart
================
import 'package:flutter/foundation.dart';
import 'package:speech_to_text/speech_to_text.dart';

/// Speech recognition service for Vibe Coding dictation
///
/// Phase 02: Dictation Integration
/// Supports Vietnamese language with real-time recognition
class SpeechService {
  final SpeechToText _speech = SpeechToText();

  bool _isAvailable = false;
  bool _isListening = false;
  String _lastError = '';

  /// Check if speech recognition is available
  bool get isAvailable => _isAvailable;

  /// Currently listening state
  bool get isListening => _isListening;

  /// Last error message
  String get lastError => _lastError;

  /// Initialize speech recognition
  /// Must be called before other methods
  Future<bool> initialize() async {
    try {
      _isAvailable = await _speech.initialize(
        onError: (error) {
          _lastError = error.errorMsg;
          debugPrint(' Speech error: $error');
          _isListening = false;
        },
        onStatus: (status) {
          debugPrint(' Speech status: $status');
          _isListening = status == 'listening';
        },
      );
      return _isAvailable;
    } catch (e) {
      _lastError = e.toString();
      debugPrint(' Speech init error: $e');
      return false;
    }
  }

  /// Start listening with Vietnamese language
  ///
  /// [onResult] callback receives recognized text
  /// [listenFor] maximum duration to listen (default: 30s)
  /// [pauseFor] pause duration on silence (default: 3s)
  Future<bool> startListening({
    required Function(String text) onResult,
    Duration listenFor = const Duration(seconds: 30),
    Duration pauseFor = const Duration(seconds: 3),
  }) async {
    if (!_isAvailable) {
      _lastError = 'Speech not available. Call initialize() first.';
      return false;
    }

    if (_isListening) {
      await stopListening();
    }

    try {
      await _speech.listen(
        onResult: (result) {
          final text = result.recognizedWords;
          if (text.isNotEmpty) {
            onResult(text);
          }
        },
        listenFor: listenFor,
        pauseFor: pauseFor,
        localeId: 'vi_VN', // Vietnamese
        // ignore: deprecated_member_use
        listenMode: ListenMode.confirmation,
        // ignore: deprecated_member_use
        cancelOnError: true,
        // ignore: deprecated_member_use
        partialResults: true, // Real-time updates
      );
      _isListening = true;
      return true;
    } catch (e) {
      _lastError = e.toString();
      debugPrint(' Listen error: $e');
      return false;
    }
  }

  /// Stop listening
  Future<void> stopListening() async {
    await _speech.stop();
    _isListening = false;
  }

  /// Cancel listening immediately
  Future<void> cancelListening() async {
    await _speech.cancel();
    _isListening = false;
  }

  /// Get available locales (for language picker)
  Future<List<LocaleName>> getLocales() async {
    return await _speech.locales();
  }
}

/// Speech recognition state for UI
class SpeechState {
  final bool isInitialized;
  final bool isListening;
  final String lastRecognizedText;
  final String? error;

  const SpeechState({
    this.isInitialized = false,
    this.isListening = false,
    this.lastRecognizedText = '',
    this.error,
  });

  SpeechState copyWith({
    bool? isInitialized,
    bool? isListening,
    String? lastRecognizedText,
    String? error,
  }) {
    return SpeechState(
      isInitialized: isInitialized ?? this.isInitialized,
      isListening: isListening ?? this.isListening,
      lastRecognizedText: lastRecognizedText ?? this.lastRecognizedText,
      error: error,
    );
  }
}

================
File: lib/features/vibe/widgets/attachment_button.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/theme.dart';
import '../models/file_attachment.dart';
import 'file_attachment_picker.dart';

/// Attachment button for file picker in Vibe Coding
///
/// Phase 02: File Attachment
/// Shows badge when files are attached
class AttachmentButton extends ConsumerWidget {
  final int attachmentCount;
  final Function(List<String> paths, AttachmentFormat format) onFilesSelected;

  const AttachmentButton({
    super.key,
    this.attachmentCount = 0,
    required this.onFilesSelected,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return GestureDetector(
      onTap: () => showFileAttachmentPicker(
        context,
        onFilesSelected: onFilesSelected,
      ),
      child: Container(
        padding: const EdgeInsets.all(10),
        decoration: BoxDecoration(
          color: attachmentCount > 0
              ? CatppuccinMocha.blue.withValues(alpha: 0.2)
              : CatppuccinMocha.surface0,
          shape: BoxShape.circle,
          border: Border.all(
            color: attachmentCount > 0
                ? CatppuccinMocha.blue
                : CatppuccinMocha.surface1,
            width: 1,
          ),
        ),
        child: Stack(
          clipBehavior: Clip.none,
          children: [
            Icon(
              Icons.attach_file,
              color: attachmentCount > 0
                  ? CatppuccinMocha.blue
                  : CatppuccinMocha.text,
              size: 20,
            ),
            if (attachmentCount > 0)
              Positioned(
                right: -4,
                top: -4,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
                  decoration: BoxDecoration(
                    color: CatppuccinMocha.blue,
                    shape: BoxShape.circle,
                  ),
                  constraints: const BoxConstraints(
                    minWidth: 14,
                    minHeight: 14,
                  ),
                  child: Center(
                    child: Text(
                      attachmentCount > 9 ? '9+' : '$attachmentCount',
                      style: TextStyle(
                        color: CatppuccinMocha.crust,
                        fontSize: 8,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/dictation_button.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/theme.dart';
import '../services/speech_service_provider.dart';

/// Dictation button for voice input in Vibe Coding
///
/// Phase 02: Dictation Integration
/// - Pulse animation when recording
/// - Vietnamese language support
/// - Real-time text display
class DictationButton extends ConsumerStatefulWidget {
  final ValueChanged<String> onTextRecognized;

  const DictationButton({
    super.key,
    required this.onTextRecognized,
  });

  @override
  ConsumerState<DictationButton> createState() => _DictationButtonState();
}

class _DictationButtonState extends ConsumerState<DictationButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _pulseController;
  late Animation<double> _pulseAnimation;

  @override
  void initState() {
    super.initState();
    // Pulse animation for recording state
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1000),
    )..repeat(reverse: true);

    _pulseAnimation = Tween<double>(begin: 1.0, end: 1.3).animate(
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );

    // Initialize speech service
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(speechServiceProvider.notifier).initialize();
    });
  }

  @override
  void dispose() {
    _pulseController.dispose();
    super.dispose();
  }

  void _toggleDictation() async {
    final notifier = ref.read(speechServiceProvider.notifier);
    final state = ref.read(speechServiceProvider);

    if (state.isListening) {
      await notifier.stopListening();
    } else {
      await notifier.startListening(
        onResult: widget.onTextRecognized,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final speechState = ref.watch(speechServiceProvider);

    return GestureDetector(
      onTap: speechState.isInitialized ? _toggleDictation : null,
      child: AnimatedBuilder(
        animation: _pulseAnimation,
        builder: (context, child) {
          return Transform.scale(
            scale: speechState.isListening ? _pulseAnimation.value : 1.0,
            child: Container(
              padding: const EdgeInsets.all(10),
              decoration: BoxDecoration(
                color: speechState.isListening
                    ? CatppuccinMocha.red
                    : CatppuccinMocha.surface0,
                shape: BoxShape.circle,
                border: Border.all(
                  color: speechState.isListening
                      ? CatppuccinMocha.red
                      : CatppuccinMocha.surface1,
                  width: 1,
                ),
              ),
              child: speechState.isInitialized
                  ? Icon(
                      Icons.mic,
                      color: speechState.isListening
                          ? CatppuccinMocha.crust
                          : CatppuccinMocha.text,
                      size: 20,
                    )
                  : SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          CatppuccinMocha.overlay1,
                        ),
                      ),
                    ),
            ),
          );
        },
      ),
    );
  }
}

/// Dictation status overlay when recording
///
/// Shows recognized text in real-time
class DictationOverlay extends StatelessWidget {
  final String recognizedText;
  final VoidCallback onStop;
  final VoidCallback onSend;

  const DictationOverlay({
    super.key,
    required this.recognizedText,
    required this.onStop,
    required this.onSend,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: CatppuccinMocha.surface0,
        border: Border(
          top: BorderSide(color: CatppuccinMocha.surface1, width: 1),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                width: 8,
                height: 8,
                decoration: BoxDecoration(
                  color: CatppuccinMocha.red,
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 8),
              Text(
                'Listening...',
                style: TextStyle(
                  color: CatppuccinMocha.subtext0,
                  fontSize: 12,
                ),
              ),
              const Spacer(),
              TextButton(
                onPressed: onStop,
                child: Text(
                  'Stop',
                  style: TextStyle(color: CatppuccinMocha.red),
                ),
              ),
            ],
          ),
          if (recognizedText.isNotEmpty) ...[
            const SizedBox(height: 8),
            Text(
              recognizedText,
              style: TextStyle(
                color: CatppuccinMocha.text,
                fontSize: 14,
              ),
            ),
            const SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton.icon(
                  onPressed: onSend,
                  icon: Icon(Icons.send, size: 16, color: CatppuccinMocha.mauve),
                  label: Text(
                    'Send',
                    style: TextStyle(color: CatppuccinMocha.mauve),
                  ),
                ),
              ],
            ),
          ],
        ],
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/error_dialog.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';
import '../services/haptic_service.dart';

/// Error type for categorization
enum ErrorType {
  /// Network/connection errors
  connection,

  /// Authentication/session errors
  authentication,

  /// File operation errors
  file,

  /// Dictation/speech errors
  dictation,

  /// Generic errors
  generic,
}

/// Error data for dialogs
class ErrorData {
  final String title;
  final String message;
  final ErrorType type;
  final List<ErrorAction>? actions;

  const ErrorData({
    required this.title,
    required this.message,
    required this.type,
    this.actions,
  });

  /// Create connection lost error
  factory ErrorData.connectionLost({
    String? message,
    VoidCallback? onReconnect,
    VoidCallback? onNewSession,
  }) {
    return ErrorData(
      title: 'Connection Lost',
      message: message ?? 'Claude stopped responding. The connection may have been interrupted.',
      type: ErrorType.connection,
      actions: [
        if (onReconnect != null)
          ErrorAction(
            label: 'Reconnect',
            type: ErrorActionType.primary,
            onPressed: onReconnect,
          ),
        if (onNewSession != null)
          ErrorAction(
            label: 'Start New Session',
            type: ErrorActionType.secondary,
            onPressed: onNewSession,
          ),
      ],
    );
  }

  /// Create dictation error
  factory ErrorData.dictationFailed({
    String? message,
    VoidCallback? onRetry,
  }) {
    return ErrorData(
      title: 'Dictation Failed',
      message: message ?? 'Could not capture speech. Please check microphone permissions.',
      type: ErrorType.dictation,
      actions: [
        if (onRetry != null)
          ErrorAction(
            label: 'Retry',
            type: ErrorActionType.primary,
            onPressed: onRetry,
          ),
        ErrorAction(
          label: 'Cancel',
          type: ErrorActionType.secondary,
          onPressed: () {},
        ),
      ],
    );
  }

  /// Create file read error
  factory ErrorData.fileReadFailed({
    required String filePath,
    String? message,
    VoidCallback? onRetry,
    VoidCallback? onSkip,
  }) {
    return ErrorData(
      title: 'File Read Failed',
      message: message ?? 'Could not read file: $filePath',
      type: ErrorType.file,
      actions: [
        if (onRetry != null)
          ErrorAction(
            label: 'Retry',
            type: ErrorActionType.primary,
            onPressed: onRetry,
          ),
        if (onSkip != null)
          ErrorAction(
            label: 'Skip',
            type: ErrorActionType.secondary,
            onPressed: onSkip,
          ),
      ],
    );
  }

  /// Create generic error
  factory ErrorData.generic({
    required String title,
    required String message,
    VoidCallback? onDismiss,
  }) {
    return ErrorData(
      title: title,
      message: message,
      type: ErrorType.generic,
      actions: [
        if (onDismiss != null)
          ErrorAction(
            label: 'OK',
            type: ErrorActionType.primary,
            onPressed: onDismiss,
          ),
      ],
    );
  }
}

/// Error action type
enum ErrorActionType {
  primary,
  secondary,
  destructive,
}

/// Error action button
class ErrorAction {
  final String label;
  final ErrorActionType type;
  final VoidCallback onPressed;

  const ErrorAction({
    required this.label,
    required this.type,
    required this.onPressed,
  });
}

/// Error dialog for Vibe Coding
///
/// Shows categorized errors with appropriate actions and haptic feedback.
class VibeErrorDialog extends StatelessWidget {
  final ErrorData error;

  const VibeErrorDialog({
    super.key,
    required this.error,
  });

  /// Show error dialog
  static Future<void> show(
    BuildContext context,
    ErrorData error,
  ) async {
    // Haptic feedback for error
    await HapticService.heavy();

    if (!context.mounted) return;

    await showDialog(
      context: context,
      builder: (context) => VibeErrorDialog(error: error),
    );
  }

  /// Show connection lost dialog
  static Future<void> showConnectionLost({
    required BuildContext context,
    String? message,
    VoidCallback? onReconnect,
    VoidCallback? onNewSession,
  }) async {
    await show(
      context,
      ErrorData.connectionLost(
        message: message,
        onReconnect: onReconnect,
        onNewSession: onNewSession,
      ),
    );
  }

  /// Show dictation failed dialog
  static Future<void> showDictationFailed({
    required BuildContext context,
    String? message,
    VoidCallback? onRetry,
  }) async {
    await show(
      context,
      ErrorData.dictationFailed(
        message: message,
        onRetry: onRetry,
      ),
    );
  }

  /// Show file read failed dialog
  static Future<void> showFileReadFailed({
    required BuildContext context,
    required String filePath,
    String? message,
    VoidCallback? onRetry,
    VoidCallback? onSkip,
  }) async {
    await show(
      context,
      ErrorData.fileReadFailed(
        filePath: filePath,
        message: message,
        onRetry: onRetry,
        onSkip: onSkip,
      ),
    );
  }

  /// Show generic error dialog
  static Future<void> showGeneric({
    required BuildContext context,
    required String title,
    required String message,
    VoidCallback? onDismiss,
  }) async {
    await show(
      context,
      ErrorData.generic(
        title: title,
        message: message,
        onDismiss: onDismiss,
      ),
    );
  }

  Color _getErrorColor() {
    return switch (error.type) {
      ErrorType.connection => CatppuccinMocha.red,
      ErrorType.authentication => CatppuccinMocha.yellow,
      ErrorType.file => CatppuccinMocha.red,
      ErrorType.dictation => CatppuccinMocha.yellow,
      ErrorType.generic => CatppuccinMocha.red,
    };
  }

  IconData _getErrorIcon() {
    return switch (error.type) {
      ErrorType.connection => Icons.wifi_off,
      ErrorType.authentication => Icons.lock_outline,
      ErrorType.file => Icons.insert_drive_file_outlined,
      ErrorType.dictation => Icons.mic_off,
      ErrorType.generic => Icons.error_outline,
    };
  }

  Color _getActionColor(ErrorActionType type) {
    return switch (type) {
      ErrorActionType.primary => CatppuccinMocha.mauve,
      ErrorActionType.secondary => CatppuccinMocha.surface1,
      ErrorActionType.destructive => CatppuccinMocha.red,
    };
  }

  @override
  Widget build(BuildContext context) {
    final errorColor = _getErrorColor();

    return AlertDialog(
      backgroundColor: CatppuccinMocha.surface,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(
          color: errorColor.withValues(alpha: 0.3),
          width: 1,
        ),
      ),
      title: Row(
        children: [
          Icon(
            _getErrorIcon(),
            color: errorColor,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              error.title,
              style: TextStyle(
                color: CatppuccinMocha.text,
                fontSize: 18,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
      content: Text(
        error.message,
        style: TextStyle(
          color: CatppuccinMocha.subtext0,
          fontSize: 14,
        ),
      ),
      actions: error.actions?.map((action) {
        return TextButton(
          onPressed: () {
            HapticService.selection();
            action.onPressed();
            Navigator.of(context).pop();
          },
          style: TextButton.styleFrom(
            foregroundColor: _getActionColor(action.type),
            padding: const EdgeInsets.symmetric(
              horizontal: 16,
              vertical: 12,
            ),
          ),
          child: Text(
            action.label,
            style: TextStyle(
              fontWeight: action.type == ErrorActionType.primary
                  ? FontWeight.w600
                  : FontWeight.w400,
            ),
          ),
        );
      }).toList(),
    );
  }
}

/// Error banner for inline error display
class ErrorBanner extends StatelessWidget {
  final String message;
  final VoidCallback? onDismiss;
  final VoidCallback? onRetry;
  final ErrorType type;

  const ErrorBanner({
    super.key,
    required this.message,
    this.onDismiss,
    this.onRetry,
    this.type = ErrorType.generic,
  });

  @override
  Widget build(BuildContext context) {
    final color = switch (type) {
      ErrorType.connection => CatppuccinMocha.red,
      ErrorType.authentication => CatppuccinMocha.yellow,
      ErrorType.file => CatppuccinMocha.red,
      ErrorType.dictation => CatppuccinMocha.yellow,
      ErrorType.generic => CatppuccinMocha.red,
    };

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.15),
        border: Border(
          bottom: BorderSide(color: color.withValues(alpha: 0.3), width: 1),
        ),
      ),
      child: Row(
        children: [
          Icon(Icons.error_outline, color: color, size: 20),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              message,
              style: TextStyle(color: CatppuccinMocha.text, fontSize: 14),
            ),
          ),
          if (onRetry != null) ...[
            TextButton(
              onPressed: () {
                HapticService.selection();
                onRetry!();
              },
              child: Text(
                'Retry',
                style: TextStyle(color: CatppuccinMocha.mauve),
              ),
            ),
          ],
          if (onDismiss != null)
            IconButton(
              icon: Icon(Icons.close, color: CatppuccinMocha.text, size: 18),
              onPressed: () {
                HapticService.selection();
                onDismiss!();
              },
              constraints: const BoxConstraints(),
              padding: const EdgeInsets.all(4),
            ),
        ],
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/file_attachment_picker.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/theme.dart';
import '../../vfs/vfs_notifier.dart';
import '../models/file_attachment.dart';

/// File attachment picker modal for Vibe Coding
///
/// Phase 02: File Attachment
/// - Multi-select files from VFS
/// - Choose attachment format (path/content)
class FileAttachmentPicker extends ConsumerStatefulWidget {
  final Function(List<String> paths, AttachmentFormat format) onFilesSelected;

  const FileAttachmentPicker({
    super.key,
    required this.onFilesSelected,
  });

  @override
  ConsumerState<FileAttachmentPicker> createState() =>
      _FileAttachmentPickerState();
}

class _FileAttachmentPickerState extends ConsumerState<FileAttachmentPicker> {
  final Set<String> _selectedPaths = {};
  AttachmentFormat _format = AttachmentFormat.path;

  @override
  void initState() {
    super.initState();
    // Load root directory on mount
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(vfsProvider.notifier).loadDirectory('/');
    });
  }

  void _toggleSelection(String path) {
    setState(() {
      if (_selectedPaths.contains(path)) {
        _selectedPaths.remove(path);
      } else {
        _selectedPaths.add(path);
      }
    });
  }

  void _handleConfirm() {
    if (_selectedPaths.isEmpty) return;
    widget.onFilesSelected(_selectedPaths.toList(), _format);
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    final vfsState = ref.watch(vfsProvider);

    return Dialog(
      backgroundColor: CatppuccinMocha.surface,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Header
            _buildHeader(vfsState),
            // Format selector
            _buildFormatSelector(),
            // File list
            Expanded(
              child: _buildFileList(vfsState),
            ),
            // Footer with actions
            _buildFooter(),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader(dynamic vfsState) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: CatppuccinMocha.mantle,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(16),
          topRight: Radius.circular(16),
        ),
      ),
      child: Row(
        children: [
          Icon(Icons.attach_file, color: CatppuccinMocha.mauve),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Attach Files',
                  style: TextStyle(
                    color: CatppuccinMocha.text,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Text(
                  vfsState.currentPath,
                  style: TextStyle(
                    color: CatppuccinMocha.subtext0,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),
          // Navigation buttons
          IconButton(
            icon: Icon(Icons.arrow_upward, color: CatppuccinMocha.text),
            onPressed: vfsState.isAtRoot
                ? null
                : () => ref.read(vfsProvider.notifier).navigateUp(),
            tooltip: 'Parent directory',
          ),
          IconButton(
            icon: Icon(Icons.refresh, color: CatppuccinMocha.text),
            onPressed:
                vfsState.isLoading ? null : () => ref.read(vfsProvider.notifier).refresh(),
            tooltip: 'Refresh',
          ),
        ],
      ),
    );
  }

  Widget _buildFormatSelector() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        border: Border(
          bottom: BorderSide(color: CatppuccinMocha.surface1, width: 1),
        ),
      ),
      child: Row(
        children: [
          Text(
            'Format:',
            style: TextStyle(color: CatppuccinMocha.subtext0, fontSize: 14),
          ),
          const SizedBox(width: 12),
          SegmentedButton<AttachmentFormat>(
            segments: AttachmentFormat.values.map((format) {
              return ButtonSegment(
                value: format,
                label: Text(format.label),
              );
            }).toList(),
            selected: {_format},
            onSelectionChanged: (Set<AttachmentFormat> selected) {
              setState(() => _format = selected.first);
            },
            style: ButtonStyle(
              backgroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return CatppuccinMocha.mauve;
                }
                return CatppuccinMocha.surface0;
              }),
              foregroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return CatppuccinMocha.crust;
                }
                return CatppuccinMocha.text;
              }),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFileList(dynamic vfsState) {
    if (vfsState.isLoading) {
      return const Center(
        child: CircularProgressIndicator(color: CatppuccinMocha.mauve),
      );
    }

    if (vfsState.error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, color: CatppuccinMocha.red, size: 48),
            const SizedBox(height: 8),
            Text(
              vfsState.error!,
              style: TextStyle(color: CatppuccinMocha.red),
            ),
          ],
        ),
      );
    }

    if (vfsState.entries.isEmpty) {
      return Center(
        child: Text(
          'Empty directory',
          style: TextStyle(color: CatppuccinMocha.subtext0),
        ),
      );
    }

    return ListView.builder(
      itemCount: vfsState.entries.length,
      itemBuilder: (context, index) {
        final entry = vfsState.entries[index];
        final isSelected = _selectedPaths.contains(entry.path);
        final isSelectable = !entry.isDir; // Only files can be attached

        return CheckboxListTile(
          value: isSelected,
          onChanged: isSelectable ? (_) => _toggleSelection(entry.path) : null,
          enabled: isSelectable,
          title: Row(
            children: [
              Icon(
                entry.isDir ? Icons.folder : Icons.insert_drive_file,
                color: entry.isDir
                    ? CatppuccinMocha.yellow
                    : CatppuccinMocha.mauve,
                size: 20,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  entry.name,
                  style: TextStyle(
                    color: isSelectable
                        ? CatppuccinMocha.text
                        : CatppuccinMocha.overlay1,
                  ),
                ),
              ),
            ],
          ),
          subtitle: entry.isDir
              ? Text(
                  'Directory',
                  style: TextStyle(color: CatppuccinMocha.overlay1, fontSize: 12),
                )
              : null,
          checkboxShape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(4),
          ),
          fillColor: WidgetStateProperty.resolveWith((states) {
            if (states.contains(WidgetState.selected)) {
              return CatppuccinMocha.mauve;
            }
            return CatppuccinMocha.surface0;
          }),
          checkColor: CatppuccinMocha.crust,
        );
      },
    );
  }

  Widget _buildFooter() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        border: Border(
          top: BorderSide(color: CatppuccinMocha.surface1, width: 1),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            '${_selectedPaths.length} file${_selectedPaths.length == 1 ? '' : 's'} selected',
            style: TextStyle(color: CatppuccinMocha.subtext0, fontSize: 14),
          ),
          Row(
            children: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text(
                  'Cancel',
                  style: TextStyle(color: CatppuccinMocha.subtext0),
                ),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: _selectedPaths.isEmpty ? null : _handleConfirm,
                style: ElevatedButton.styleFrom(
                  backgroundColor: CatppuccinMocha.mauve,
                  foregroundColor: CatppuccinMocha.crust,
                  disabledBackgroundColor: CatppuccinMocha.surface0,
                  disabledForegroundColor: CatppuccinMocha.overlay1,
                ),
                child: Text('Attach ${_selectedPaths.isEmpty ? '' : '(${_selectedPaths.length})'}'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Show file attachment picker modal
Future<void> showFileAttachmentPicker(
  BuildContext context, {
  required Function(List<String> paths, AttachmentFormat format) onFilesSelected,
}) {
  return showDialog(
    context: context,
    builder: (context) => FileAttachmentPicker(
      onFilesSelected: onFilesSelected,
    ),
  );
}

================
File: lib/features/vibe/widgets/input_bar.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/theme.dart';
import '../models/file_attachment.dart';
import '../services/haptic_service.dart';
import '../vibe_session_providers.dart';
import 'attachment_button.dart';
import 'dictation_button.dart';
import 'quick_keys_toolbar.dart';

/// Input bar with prompt field and send button
class InputBar extends ConsumerStatefulWidget {
  const InputBar({super.key});

  @override
  ConsumerState<InputBar> createState() => _InputBarState();
}

class _InputBarState extends ConsumerState<InputBar> {
  late final TextEditingController _controller;
  final FocusNode _focusNode = FocusNode();
  final List<String> _attachedFiles = [];
  AttachmentFormat _attachmentFormat = AttachmentFormat.path;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController();
    // Auto-focus on mount
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _focusNode.requestFocus();
      }
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  Future<void> _sendPrompt() async {
    final text = _controller.text.trim();
    if (text.isEmpty && _attachedFiles.isEmpty) return;

    // Haptic feedback for send
    await HapticService.medium();

    // Build prompt with attachments
    String finalPrompt = text;

    if (_attachedFiles.isNotEmpty && _attachmentFormat == AttachmentFormat.path) {
      // Add path references at the beginning
      final paths = _attachedFiles.map((p) => '@$p').join(' ');
      if (finalPrompt.isNotEmpty) {
        finalPrompt = '$paths $finalPrompt';
      } else {
        finalPrompt = paths;
      }
    }

    // Keep focus for next prompt (keyboard stays open)
    _controller.clear();
    _attachedFiles.clear();
    setState(() {}); // Update attachment button badge

    await ref.read(vibeSessionProvider.notifier).sendPrompt(finalPrompt);
  }

  void _handleFilesAttached(List<String> paths, AttachmentFormat format) {
    HapticService.light();
    setState(() {
      _attachedFiles.clear();
      _attachedFiles.addAll(paths);
      _attachmentFormat = format;
    });

    // If content format, insert content directly (placeholder for now)
    // TODO: Implement file content reading from backend
    if (format == AttachmentFormat.content) {
      for (final path in paths) {
        _controller.text += '\n// TODO: Content of $path will be inserted\n';
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final sessionState = ref.watch(vibeSessionProvider);
    final isConnected = sessionState.isConnected;
    final isSending = sessionState.isSending;

    return Column(
      children: [
        // Input field
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: CatppuccinMocha.surface0,
            border: Border(
              top: BorderSide(color: CatppuccinMocha.surface1, width: 1),
            ),
          ),
          child: Row(
            children: [
              // Prompt indicator
              Text(
                '\$ ',
                style: TextStyle(
                  color: CatppuccinMocha.green,
                  fontFamily: 'monospace',
                  fontSize: 16,
                ),
              ),
              // Text field
              Expanded(
                child: TextField(
                  controller: _controller,
                  focusNode: _focusNode,
                  enabled: isConnected && !isSending,
                  style: TextStyle(
                    color: CatppuccinMocha.text,
                    fontSize: 16,
                  ),
                  decoration: InputDecoration(
                    hintText: 'Type your prompt...',
                    hintStyle: TextStyle(
                      color: CatppuccinMocha.overlay1,
                    ),
                    border: InputBorder.none,
                    contentPadding: EdgeInsets.zero,
                  ),
                  maxLines: null,
                  minLines: 1,
                  textInputAction: TextInputAction.send,
                  onSubmitted: (_) => _sendPrompt(),
                ),
              ),
              const SizedBox(width: 8),
              // Attachment button
              AttachmentButton(
                attachmentCount: _attachedFiles.length,
                onFilesSelected: _handleFilesAttached,
              ),
              const SizedBox(width: 8),
              // Dictation button
              DictationButton(
                onTextRecognized: (text) {
                  // Append recognized text to input field
                  _controller.value = TextEditingValue(
                    text: _controller.text + text,
                    selection: TextSelection.collapsed(
                      offset: _controller.text.length + text.length,
                    ),
                  );
                },
              ),
              const SizedBox(width: 8),
              // Send button
              _SendButton(
                isEnabled: isConnected &&
                    !isSending &&
                    _controller.text.trim().isNotEmpty,
                isLoading: isSending,
                onPressed: _sendPrompt,
              ),
            ],
          ),
        ),
        // Quick keys toolbar
        QuickKeysToolbar(
          onKeyPressed: (key) =>
              ref.read(vibeSessionProvider.notifier).sendSpecialKey(key),
        ),
      ],
    );
  }
}

class _SendButton extends StatelessWidget {
  final bool isEnabled;
  final bool isLoading;
  final VoidCallback onPressed;

  const _SendButton({
    required this.isEnabled,
    required this.isLoading,
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: isEnabled
          ? CatppuccinMocha.mauve
          : CatppuccinMocha.surface0,
      borderRadius: BorderRadius.circular(8),
      child: InkWell(
        onTap: isEnabled ? onPressed : null,
        borderRadius: BorderRadius.circular(8),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: isLoading
              ? SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(
                      CatppuccinMocha.crust,
                    ),
                  ),
                )
              : Icon(
                  Icons.send,
                  color: isEnabled
                      ? CatppuccinMocha.crust
                      : CatppuccinMocha.overlay1,
                  size: 18,
                ),
        ),
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/output_parser.dart
================
import '../models/output_block.dart';

/// Output parser for enhanced terminal display
///
/// Uses heuristic patterns to detect:
/// - File paths
/// - Git diffs
/// - Questions/prompts
/// - Lists
/// - Plans
/// - Code blocks
/// - Tool use sections
class OutputParser {
  /// Regex patterns for detection
  static final RegExp _filePattern = RegExp(
    r'[\w\-./]+/[\w\-./]*\.(\w+|Dockerfile|Makefile|Containerfile|gitignore)$',
    caseSensitive: false,
  );

  static final RegExp _questionPattern = RegExp(
    r'\([Yy]/[Nn]\)|\([Nn]/[Yy]\)|\(yes/no\)|\(y/n\)',
  );

  static final RegExp _planStepPattern = RegExp(
    r'^\s*(\d+\.|[a-zA-Z]\.)\s+',
    multiLine: true,
  );

  static final RegExp _listPattern = RegExp(
    r'^\s*[\-\*+]\s+',
    multiLine: true,
  );

  static final RegExp _codeBlockPattern = RegExp(
    r'```[\w\+]*\n([\s\S]*?)\n```',
    multiLine: true,
  );

  static final RegExp _toolPattern = RegExp(
    r'^(Running|Reading|Writing|Executing|Searching)\s+',
    caseSensitive: false,
  );

  /// Parse terminal output into structured blocks
  static List<OutputBlock> parse(String output) {
    if (output.isEmpty) return [];

    final blocks = <OutputBlock>[];
    final lines = output.split('\n');

    int i = 0;
    while (i < lines.length) {
      final line = lines[i];
      final block = _parseLine(line, lines, i);
      blocks.add(block);
      i += _countLinesConsumed(block);
    }

    return _mergeConsecutiveBlocks(blocks);
  }

  /// Parse single line with context
  static OutputBlock _parseLine(
    String line,
    List<String> lines,
    int currentIndex,
  ) {
    // Tool use section
    if (_toolPattern.hasMatch(line)) {
      return OutputBlock(
        type: BlockType.tool,
        content: line,
        metadata: {'tool': line.split(' ').first},
      );
    }

    // Question prompt
    final questionMatch = _questionPattern.firstMatch(line);
    if (questionMatch != null) {
      return OutputBlock(
        type: BlockType.question,
        content: line,
        metadata: {'options': _extractOptions(questionMatch.group(0)!)},
      );
    }

    // Diff line
    if (line.startsWith('+++ ') || line.startsWith('--- ') ||
        line.startsWith('+') && !line.startsWith('++') ||
        line.startsWith('-') && !line.startsWith('---')) {
      return OutputBlock(
        type: BlockType.diff,
        content: line,
      );
    }

    // Plan step
    if (_planStepPattern.hasMatch(line)) {
      return OutputBlock(
        type: BlockType.plan,
        content: line,
        children: _extractPlanChildren(lines, currentIndex),
      );
    }

    // List item
    if (_listPattern.hasMatch(line)) {
      return OutputBlock(
        type: BlockType.list,
        content: line,
      );
    }

    // File path
    final fileMatch = _filePattern.firstMatch(line);
    if (fileMatch != null) {
      return OutputBlock(
        type: BlockType.file,
        content: fileMatch.group(0)!,
        metadata: {'fullLine': line},
      );
    }

    // Code block
    final codeMatch = _codeBlockPattern.firstMatch(line);
    if (codeMatch != null) {
      return OutputBlock(
        type: BlockType.code,
        content: codeMatch.group(1) ?? '',
      );
    }

    // Error detection
    if (_isErrorLine(line)) {
      return OutputBlock(
        type: BlockType.error,
        content: line,
      );
    }

    // Default: raw text
    return OutputBlock(
      type: BlockType.raw,
      content: line,
    );
  }

  /// Extract children for plan blocks (indented content)
  static List<OutputBlock>? _extractPlanChildren(List<String> lines, int startIndex) {
    final children = <OutputBlock>[];
    int i = startIndex + 1;

    // Collect indented lines until next non-indented
    while (i < lines.length) {
      final line = lines[i];
      if (line.isEmpty || line.startsWith('   ') || line.startsWith('\t')) {
        children.add(OutputBlock(
          type: BlockType.raw,
          content: line,
        ));
        i++;
      } else {
        break;
      }
    }

    return children.isEmpty ? null : children;
  }

  /// Extract options from question prompt
  static String _extractOptions(String prompt) {
    if (prompt.contains('(Y/n)')) return 'Y,n';
    if (prompt.contains('(y/N)')) return 'y,N';
    if (prompt.contains('(y/n)')) return 'y,n';
    if (prompt.contains('(Y/N)')) return 'Y,N';
    return 'yes,no';
  }

  /// Extract options from question prompt
  static String extractOptions(String prompt) {
    return _extractOptions(prompt);
  }

  /// Check if line is an error
  static bool _isErrorLine(String line) {
    final lower = line.toLowerCase();
    final errorIndicators = [
      'error:', 'exception:', 'failed', 'cannot', 'unable to',
      'warning:', 'warn:', 'not found', 'no such file', 'undefined',
    ];
    return errorIndicators.any((ind) => lower.contains(ind));
  }

  /// Count how many lines a block consumes (for children)
  static int _countLinesConsumed(OutputBlock block) {
    if (block.isCollapsible && block.isCollapsed) {
      return 1;
    }
    return 1 + (block.children?.length ?? 0);
  }

  /// Merge consecutive blocks of same type
  static List<OutputBlock> _mergeConsecutiveBlocks(List<OutputBlock> blocks) {
    if (blocks.isEmpty) return blocks;

    final merged = <OutputBlock>[blocks.first];

    for (int i = 1; i < blocks.length; i++) {
      final current = blocks[i];
      final last = merged.last;

      // Only merge raw blocks
      if (last.type == BlockType.raw && current.type == BlockType.raw) {
        merged[merged.length - 1] = OutputBlock(
          type: BlockType.raw,
          content: '${last.content}\n${current.content}',
        );
      } else {
        merged.add(current);
      }
    }

    return merged;
  }

  /// Extract all file paths from output
  static List<String> extractFilePaths(String output) {
    final matches = _filePattern.allMatches(output);
    return matches.map((m) => m.group(0)!).toList();
  }

  /// Extract all diff hunks from output
  static List<String> extractDiffHunks(String output) {
    final lines = output.split('\n');
    final hunks = <String>[];
    final currentHunk = <String>[];
    bool inDiff = false;

    for (final line in lines) {
      if (line.startsWith('@@ ')) {
        inDiff = true;
        if (currentHunk.isNotEmpty) {
          hunks.add(currentHunk.join('\n'));
          currentHunk.clear();
        }
        currentHunk.add(line);
      } else if (inDiff) {
        if (line.startsWith('+') || line.startsWith('-') ||
            line.startsWith(' ') || line.isEmpty) {
          currentHunk.add(line);
        } else {
          inDiff = false;
          if (currentHunk.isNotEmpty) {
            hunks.add(currentHunk.join('\n'));
            currentHunk.clear();
          }
        }
      }
    }

    if (currentHunk.isNotEmpty) {
      hunks.add(currentHunk.join('\n'));
    }

    return hunks;
  }

  /// Check if output contains a question prompt
  static bool hasQuestionPrompt(String output) {
    return _questionPattern.hasMatch(output);
  }

  /// Get the active question prompt from output
  static String? getQuestionPrompt(String output) {
    final match = _questionPattern.firstMatch(output);
    return match?.group(0);
  }
}

================
File: lib/features/vibe/widgets/output_view.dart
================
import 'package:flutter/material.dart';
import 'package:xterm/xterm.dart';

import '../../../core/theme.dart';

/// Output view using xterm for terminal display
///
///  AUTO-SCROLL WARNING:
/// Ch auto-scroll khi user ang  bottom. Nu user scroll ln xem log c,
/// KHNG t ng scroll khi output mi n.
///
/// Note: xterm.dart 4.0 has built-in scroll management.
/// This wrapper provides the Catppuccin theme.
class OutputView extends StatelessWidget {
  final Terminal terminal;
  final bool isParsedMode;
  final VoidCallback? onFileTap;

  const OutputView({
    super.key,
    required this.terminal,
    this.isParsedMode = false,
    this.onFileTap,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      color: CatppuccinMocha.terminalBackground,
      child: TerminalView(
        terminal,
        textStyle: TerminalStyle(
          fontSize: 14,
          fontFamily: 'Courier',
          height: 1.4,
        ),
        theme: TerminalTheme(
          cursor: CatppuccinMocha.green,
          selection: CatppuccinMocha.surface1,
          foreground: CatppuccinMocha.terminalForeground,
          background: CatppuccinMocha.terminalBackground,
          black: CatppuccinMocha.surface0,
          red: CatppuccinMocha.red,
          green: CatppuccinMocha.green,
          yellow: CatppuccinMocha.yellow,
          blue: CatppuccinMocha.blue,
          magenta: CatppuccinMocha.mauve,
          cyan: CatppuccinMocha.teal,
          white: CatppuccinMocha.text,
          brightBlack: CatppuccinMocha.surface1,
          brightRed: CatppuccinMocha.red,
          brightGreen: CatppuccinMocha.green,
          brightYellow: CatppuccinMocha.yellow,
          brightBlue: CatppuccinMocha.blue,
          brightMagenta: CatppuccinMocha.mauve,
          brightCyan: CatppuccinMocha.teal,
          brightWhite: CatppuccinMocha.text,
          searchHitBackground: CatppuccinMocha.yellow,
          searchHitBackgroundCurrent: CatppuccinMocha.peach,
          searchHitForeground: CatppuccinMocha.base,
        ),
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/parsed_output_view.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';
import '../models/output_block.dart';
import 'output_parser.dart';

/// Parsed output view with enhanced rendering
class ParsedOutputView extends StatefulWidget {
  final String output;
  final VoidCallback? onFileTap;
  final Function(String)? onQuestionAnswer;

  const ParsedOutputView({
    super.key,
    required this.output,
    this.onFileTap,
    this.onQuestionAnswer,
  });

  @override
  State<ParsedOutputView> createState() => _ParsedOutputViewState();
}

class _ParsedOutputViewState extends State<ParsedOutputView> {
  final List<OutputBlock> _blocks = [];

  @override
  void initState() {
    super.initState();
    _blocks.addAll(OutputParser.parse(widget.output));
  }

  @override
  void didUpdateWidget(ParsedOutputView oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.output != widget.output) {
      _blocks.clear();
      _blocks.addAll(OutputParser.parse(widget.output));
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_blocks.isEmpty) {
      return const SizedBox.shrink();
    }

    return ListView.separated(
      padding: const EdgeInsets.all(16),
      itemCount: _blocks.length,
      separatorBuilder: (_, __) => const SizedBox(height: 4),
      itemBuilder: (context, index) {
        return _buildBlock(_blocks[index]);
      },
    );
  }

  Widget _buildBlock(OutputBlock block) {
    switch (block.type) {
      case BlockType.file:
        return _buildFileBlock(block);
      case BlockType.diff:
        return _buildDiffBlock(block);
      case BlockType.question:
        return _buildQuestionBlock(block);
      case BlockType.plan:
        return _buildPlanBlock(block);
      case BlockType.list:
        return _buildListBlock(block);
      case BlockType.error:
        return _buildErrorBlock(block);
      case BlockType.code:
        return _buildCodeBlock(block);
      case BlockType.tool:
        return _buildToolBlock(block);
      case BlockType.raw:
        return _buildRawBlock(block);
    }
  }

  Widget _buildFileBlock(OutputBlock block) {
    return GestureDetector(
      onTap: () {
        if (widget.onFileTap != null) {
          widget.onFileTap!();
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: CatppuccinMocha.blue.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(
            color: CatppuccinMocha.blue.withValues(alpha: 0.3),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.insert_drive_file,
              size: 14,
              color: CatppuccinMocha.blue,
            ),
            const SizedBox(width: 4),
            Flexible(
              child: Text(
                block.content,
                style: TextStyle(
                  color: CatppuccinMocha.blue,
                  fontFamily: 'Courier',
                  fontSize: 13,
                  decoration: TextDecoration.underline,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDiffBlock(OutputBlock block) {
    final color = block.isDiffAdded
        ? CatppuccinMocha.green
        : block.isDiffRemoved
            ? CatppuccinMocha.red
            : CatppuccinMocha.text;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      child: Text(
        block.content,
        style: TextStyle(
          color: color,
          fontFamily: 'Courier',
          fontSize: 13,
        ),
      ),
    );
  }

  Widget _buildQuestionBlock(OutputBlock block) {
    final options = block.questionOptions ?? ['Y', 'n'];

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: CatppuccinMocha.mauve.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: CatppuccinMocha.mauve.withValues(alpha: 0.3),
          width: 1,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                Icons.help_outline,
                size: 16,
                color: CatppuccinMocha.mauve,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  block.content,
                  style: TextStyle(
                    color: CatppuccinMocha.text,
                    fontSize: 14,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            children: options.map((opt) {
              return _QuestionButton(
                option: opt,
                onTap: () => widget.onQuestionAnswer?.call(opt),
              );
            }).toList(),
          ),
        ],
      ),
    );
  }

  Widget _buildPlanBlock(OutputBlock block) {
    return _CollapsibleBlock(
      block: block,
      header: Row(
        children: [
          Icon(
            block.isCollapsed
                ? Icons.expand_more
                : Icons.expand_less,
            size: 16,
            color: CatppuccinMocha.mauve,
          ),
          const SizedBox(width: 4),
          Text(
            block.content,
            style: TextStyle(
              color: CatppuccinMocha.mauve,
              fontWeight: FontWeight.w500,
              fontSize: 14,
            ),
          ),
        ],
      ),
      children: block.children?.map((b) => _buildBlock(b)).toList(),
    );
  }

  Widget _buildListBlock(OutputBlock block) {
    return Padding(
      padding: const EdgeInsets.only(left: 16),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '',
            style: TextStyle(
              color: CatppuccinMocha.overlay2,
              fontSize: 14,
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              block.content.replaceFirst(RegExp(r'^[\-\*+]\s+'), ''),
              style: TextStyle(
                color: CatppuccinMocha.text,
                fontSize: 14,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildErrorBlock(OutputBlock block) {
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: CatppuccinMocha.red.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            Icons.error_outline,
            size: 16,
            color: CatppuccinMocha.red,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              block.content,
              style: TextStyle(
                color: CatppuccinMocha.red,
                fontSize: 13,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCodeBlock(OutputBlock block) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: CatppuccinMocha.surface0,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Text(
        block.content,
        style: TextStyle(
          color: CatppuccinMocha.text,
          fontFamily: 'Courier',
          fontSize: 12,
        ),
      ),
    );
  }

  Widget _buildToolBlock(OutputBlock block) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      child: Row(
        children: [
          SizedBox(
            width: 14,
            height: 14,
            child: CircularProgressIndicator(
              strokeWidth: 2,
              valueColor: AlwaysStoppedAnimation(CatppuccinMocha.yellow),
            ),
          ),
          const SizedBox(width: 8),
          Text(
            block.content,
            style: TextStyle(
              color: CatppuccinMocha.yellow,
              fontSize: 13,
              fontStyle: FontStyle.italic,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRawBlock(OutputBlock block) {
    return Text(
      block.content,
      style: TextStyle(
        color: CatppuccinMocha.text,
        fontSize: 14,
      ),
    );
  }
}

/// Collapsible block widget
class _CollapsibleBlock extends StatefulWidget {
  final OutputBlock block;
  final Widget header;
  final List<Widget>? children;
  // ignore: unused_field
  final ValueChanged<bool>? onToggle;

  const _CollapsibleBlock({
    required this.block,
    required this.header,
    this.children,
    // ignore: unused_element_parameter
    this.onToggle,
  });

  @override
  State<_CollapsibleBlock> createState() => _CollapsibleBlockState();
}

class _CollapsibleBlockState extends State<_CollapsibleBlock> {
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        setState(() {
          widget.block.isCollapsed = !widget.block.isCollapsed;
          widget.onToggle?.call(widget.block.isCollapsed);
        });
      },
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 4),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            widget.header,
            if (!widget.block.isCollapsed && widget.children != null)
              Padding(
                padding: const EdgeInsets.only(left: 20, top: 4),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: widget.children!,
                ),
              ),
          ],
        ),
      ),
    );
  }
}

/// Question option button
class _QuestionButton extends StatelessWidget {
  final String option;
  final VoidCallback? onTap;

  const _QuestionButton({
    required this.option,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onTap,
      style: ElevatedButton.styleFrom(
        backgroundColor: CatppuccinMocha.mauve,
        foregroundColor: CatppuccinMocha.crust,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        minimumSize: const Size(40, 32),
      ),
      child: Text(option),
    );
  }
}

================
File: lib/features/vibe/widgets/quick_keys_toolbar.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';
import '../models/special_key.dart';
import '../services/haptic_service.dart';

/// Quick keys toolbar for common terminal interactions
class QuickKeysToolbar extends StatelessWidget {
  final Function(SpecialKey) onKeyPressed;

  const QuickKeysToolbar({
    super.key,
    required this.onKeyPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 48,
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: CatppuccinMocha.surface0,
        border: Border(
          top: BorderSide(color: CatppuccinMocha.surface1, width: 1),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          _QuickKeyButton(
            label: SpecialKey.arrowUp.label,
            specialKey: SpecialKey.arrowUp,
            onTap: () => onKeyPressed(SpecialKey.arrowUp),
            isDestructive: false,
          ),
          _QuickKeyButton(
            label: SpecialKey.arrowDown.label,
            specialKey: SpecialKey.arrowDown,
            onTap: () => onKeyPressed(SpecialKey.arrowDown),
            isDestructive: false,
          ),
          _QuickKeyButton(
            label: SpecialKey.enter.label,
            specialKey: SpecialKey.enter,
            onTap: () => onKeyPressed(SpecialKey.enter),
            isDestructive: false,
          ),
          _QuickKeyButton(
            label: SpecialKey.ctrlC.label,
            specialKey: SpecialKey.ctrlC,
            onTap: () => onKeyPressed(SpecialKey.ctrlC),
            isDestructive: true,
          ),
        ],
      ),
    );
  }
}

class _QuickKeyButton extends StatefulWidget {
  final String label;
  final SpecialKey specialKey;
  final VoidCallback onTap;
  final bool isDestructive;

  const _QuickKeyButton({
    required this.label,
    required this.specialKey,
    required this.onTap,
    this.isDestructive = false,
  });

  @override
  State<_QuickKeyButton> createState() => _QuickKeyButtonState();
}

class _QuickKeyButtonState extends State<_QuickKeyButton> {
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: (_) => setState(() => _isPressed = true),
      onTapUp: (_) {
        setState(() => _isPressed = false);
        HapticService.selection();
        widget.onTap();
      },
      onTapCancel: () => setState(() => _isPressed = false),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 100),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
        decoration: BoxDecoration(
          color: _isPressed
              ? CatppuccinMocha.surface1
              : CatppuccinMocha.surface0,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: widget.isDestructive
                ? CatppuccinMocha.red.withValues(alpha: 0.5)
                : CatppuccinMocha.surface1,
            width: 1,
          ),
        ),
        child: Text(
          widget.label,
          style: TextStyle(
            color: widget.isDestructive
                ? CatppuccinMocha.red
                : CatppuccinMocha.text,
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/search_overlay.dart
================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:xterm/xterm.dart';

import '../../../core/theme.dart';

/// Search result match
class SearchMatch {
  final int index;
  final String match;
  final int start;
  final int end;

  SearchMatch({
    required this.index,
    required this.match,
    required this.start,
    required this.end,
  });
}

/// Search results state
class SearchResults {
  final List<SearchMatch> matches;
  final int currentIndex;

  const SearchResults({
    this.matches = const [],
    this.currentIndex = -1,
  });

  SearchResults copyWith({
    List<SearchMatch>? matches,
    int? currentIndex,
  }) {
    return SearchResults(
      matches: matches ?? this.matches,
      currentIndex: currentIndex ?? this.currentIndex,
    );
  }

  int get count => matches.length;
  bool get hasResults => matches.isNotEmpty;
  SearchMatch? get currentMatch =>
      currentIndex >= 0 && currentIndex < matches.length
          ? matches[currentIndex]
          : null;

  SearchResults next() {
    if (matches.isEmpty) return this;
    final nextIndex = (currentIndex + 1) % matches.length;
    return copyWith(currentIndex: nextIndex);
  }

  SearchResults previous() {
    if (matches.isEmpty) return this;
    final prevIndex = currentIndex <= 0 ? matches.length - 1 : currentIndex - 1;
    return copyWith(currentIndex: prevIndex);
  }
}

/// Search overlay for terminal output
class OutputSearchOverlay extends StatefulWidget {
  final String output;
  final Terminal? terminal;
  final VoidCallback? onClose;

  const OutputSearchOverlay({
    super.key,
    required this.output,
    this.terminal,
    this.onClose,
  });

  @override
  State<OutputSearchOverlay> createState() => _OutputSearchOverlayState();
}

class _OutputSearchOverlayState extends State<OutputSearchOverlay> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();

  SearchResults _results = const SearchResults();
  bool _caseSensitive = false;
  bool _searching = false;

  // Debounce timer for search
  Timer? _debounce;

  @override
  void initState() {
    super.initState();
    _focusNode.requestFocus();
  }

  @override
  void dispose() {
    _debounce?.cancel();
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  void _performSearch() {
    setState(() {
      _searching = true;
    });

    final query = _controller.text;
    if (query.isEmpty) {
      setState(() {
        _results = const SearchResults();
        _searching = false;
      });
      _clearTerminalHighlight();
      return;
    }

    // Find matches
    final matches = <SearchMatch>[];
    final pattern = _caseSensitive ? query : query.toLowerCase();
    final searchContent = _caseSensitive
        ? widget.output
        : widget.output.toLowerCase();

    int index = 0;
    int pos = 0;

    while (true) {
      final start = searchContent.indexOf(pattern, pos);
      if (start == -1) break;

      final end = start + query.length;
      matches.add(SearchMatch(
        index: index++,
        match: widget.output.substring(start, end),
        start: start,
        end: end,
      ));
      pos = end;
    }

    setState(() {
      _results = SearchResults(matches: matches);
      if (matches.isNotEmpty) {
        _results = _results.copyWith(currentIndex: 0);
      }
      _searching = false;
    });

    // Highlight first match in terminal
    if (matches.isNotEmpty && widget.terminal != null) {
      _highlightInTerminal(matches.first);
    }
  }

  void _highlightInTerminal(SearchMatch match) {
    final terminal = widget.terminal;
    if (terminal == null) return;

    // xterm.dart doesn't have a search method in current version
    // TODO: Implement custom highlighting when terminal buffer is accessible
  }

  void _clearTerminalHighlight() {
    // Terminal doesn't have clearSearchHighlight method
    // Search results are cleared when new search is performed
  }

  void _nextMatch() {
    setState(() {
      _results = _results.next();
      if (_results.currentMatch != null) {
        _highlightInTerminal(_results.currentMatch!);
      }
    });
  }

  void _previousMatch() {
    setState(() {
      _results = _results.previous();
      if (_results.currentMatch != null) {
        _highlightInTerminal(_results.currentMatch!);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: CatppuccinMocha.mantle,
        border: Border(
          bottom: BorderSide(color: CatppuccinMocha.surface1, width: 1),
        ),
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Search bar
            Padding(
              padding: const EdgeInsets.all(12),
              child: Row(
                children: [
                  Icon(Icons.search, color: CatppuccinMocha.subtext0, size: 20),
                  const SizedBox(width: 8),
                  Expanded(
                    child: TextField(
                      controller: _controller,
                      focusNode: _focusNode,
                      style: TextStyle(color: CatppuccinMocha.text),
                      decoration: InputDecoration(
                        hintText: 'Search in output...',
                        hintStyle: TextStyle(color: CatppuccinMocha.overlay1),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(color: CatppuccinMocha.surface1),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(color: CatppuccinMocha.surface1),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(color: CatppuccinMocha.mauve),
                        ),
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 12,
                          vertical: 8,
                        ),
                        suffixIcon: _controller.text.isNotEmpty
                            ? IconButton(
                                icon: Icon(Icons.clear,
                                    color: CatppuccinMocha.overlay1),
                                onPressed: () {
                                  _controller.clear();
                                  _performSearch();
                                },
                              )
                            : null,
                      ),
                      onSubmitted: (_) => _performSearch(),
                      onChanged: (value) {
                        // Debounced search for better performance
                        _debounce?.cancel();
                        if (value.isEmpty) {
                          _results = const SearchResults();
                          _clearTerminalHighlight();
                          setState(() {});
                        } else {
                          _debounce = Timer(const Duration(milliseconds: 300), () {
                            _performSearch();
                          });
                        }
                      },
                    ),
                  ),
                  const SizedBox(width: 8),
                  // Case sensitive toggle
                  GestureDetector(
                    onTap: () {
                      setState(() {
                        _caseSensitive = !_caseSensitive;
                        if (_controller.text.isNotEmpty) {
                          _performSearch();
                        }
                      });
                    },
                    child: Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: _caseSensitive
                            ? CatppuccinMocha.mauve
                            : CatppuccinMocha.surface0,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                          color: _caseSensitive
                              ? CatppuccinMocha.mauve
                              : CatppuccinMocha.surface1,
                        ),
                      ),
                      child: Text(
                        'Aa',
                        style: TextStyle(
                          color: _caseSensitive
                              ? CatppuccinMocha.crust
                              : CatppuccinMocha.text,
                          fontWeight: FontWeight.w600,
                          fontSize: 14,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  IconButton(
                    icon: Icon(Icons.close, color: CatppuccinMocha.text),
                    onPressed: widget.onClose,
                  ),
                ],
              ),
            ),

            // Results info and navigation
            if (_searching || _results.hasResults || _controller.text.isNotEmpty)
              Padding(
                padding: const EdgeInsets.fromLTRB(12, 0, 12, 12),
                child: Row(
                  children: [
                    if (_searching)
                      SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation(CatppuccinMocha.yellow),
                        ),
                      )
                    else if (_results.hasResults)
                      Text(
                        '${_results.currentIndex + 1} of ${_results.count}',
                        style: TextStyle(
                          color: CatppuccinMocha.subtext0,
                          fontSize: 13,
                        ),
                      )
                    else if (_controller.text.isNotEmpty)
                      Text(
                        'No results',
                        style: TextStyle(
                          color: CatppuccinMocha.red,
                          fontSize: 13,
                        ),
                      ),
                    const Spacer(),
                    if (_results.hasResults && _results.count > 1) ...[
                      IconButton(
                        icon: Icon(
                          Icons.keyboard_arrow_up,
                          color: CatppuccinMocha.text,
                        ),
                        onPressed: _previousMatch,
                        tooltip: 'Previous',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                      ),
                      const SizedBox(width: 8),
                      IconButton(
                        icon: Icon(
                          Icons.keyboard_arrow_down,
                          color: CatppuccinMocha.text,
                        ),
                        onPressed: _nextMatch,
                        tooltip: 'Next',
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints(),
                      ),
                    ],
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/session_tab_bar.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/theme.dart';
import '../services/session_manager.dart';
import 'tab_item.dart';

/// Session tab bar for multi-session navigation
///
/// Phase 02: Multi-Session Tab Architecture
/// Shows all active sessions with horizontal scrolling
class SessionTabBar extends ConsumerWidget {
  const SessionTabBar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sessionState = ref.watch(sessionManagerProvider);
    final sessions = sessionState.sessionList;
    final activeId = sessionState.activeSessionId;

    if (sessions.isEmpty) {
      return const SizedBox.shrink();
    }

    return Container(
      height: 48,
      decoration: BoxDecoration(
        color: CatppuccinMocha.mantle,
        border: Border(
          bottom: BorderSide(color: CatppuccinMocha.surface1, width: 1),
        ),
      ),
      child: Row(
        children: [
          // Tabs
          Expanded(
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              padding: const EdgeInsets.symmetric(horizontal: 8),
              itemCount: sessions.length,
              itemBuilder: (context, index) {
                final session = sessions[index];
                final isActive = session.id == activeId;

                return TabItem(
                  session: session,
                  isActive: isActive,
                  onTap: () async {
                    // Phase 05: Async switch session
                    await ref.read(sessionManagerProvider.notifier).switchSession(session.id);
                  },
                  onLongPress: () => _showSessionMenu(context, ref, session),
                );
              },
            ),
          ),
          // New session button
          _NewSessionButton(
            onPressed: sessions.length >= 5
                ? null
                : () => _showNewSessionDialog(context, ref),
          ),
        ],
      ),
    );
  }

  void _showSessionMenu(BuildContext context, WidgetRef ref, dynamic session) {
    showModalBottomSheet(
      context: context,
      backgroundColor: CatppuccinMocha.surface,
      builder: (context) => Container(
        padding: const EdgeInsets.symmetric(vertical: 16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: Icon(Icons.edit, color: CatppuccinMocha.text),
              title: Text(
                'Rename',
                style: TextStyle(color: CatppuccinMocha.text),
              ),
              onTap: () {
                Navigator.pop(context);
                _showRenameDialog(context, ref, session);
              },
            ),
            ListTile(
              leading: Icon(Icons.close, color: CatppuccinMocha.red),
              title: Text(
                'Close Session',
                style: TextStyle(color: CatppuccinMocha.red),
              ),
              onTap: () {
                Navigator.pop(context);
                _showCloseDialog(context, ref, session);
              },
            ),
          ],
        ),
      ),
    );
  }

  void _showRenameDialog(BuildContext context, WidgetRef ref, dynamic session) {
    final controller = TextEditingController(text: session.projectName);
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: CatppuccinMocha.surface,
        title: Text(
          'Rename Session',
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        content: TextField(
          controller: controller,
          style: TextStyle(color: CatppuccinMocha.text),
          decoration: InputDecoration(
            hintText: 'Session name',
            hintStyle: TextStyle(color: CatppuccinMocha.overlay1),
            border: OutlineInputBorder(
              borderSide: BorderSide(color: CatppuccinMocha.surface1),
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              if (controller.text.trim().isNotEmpty) {
                ref
                    .read(sessionManagerProvider.notifier)
                    .renameSession(session.id, controller.text.trim());
              }
              Navigator.pop(context);
            },
            child: Text(
              'Rename',
              style: TextStyle(color: CatppuccinMocha.mauve),
            ),
          ),
        ],
      ),
    );
  }

  void _showCloseDialog(BuildContext context, WidgetRef ref, dynamic session) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        backgroundColor: CatppuccinMocha.surface,
        title: Text(
          'Close Session',
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        content: Text(
          'Close "${session.projectName}" session? Claude may be working on tasks.',
          style: TextStyle(color: CatppuccinMocha.subtext0),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              // Phase 05: Async close session
              await ref.read(sessionManagerProvider.notifier).closeSession(session.id);
              if (dialogContext.mounted) Navigator.pop(dialogContext);
            },
            child: Text(
              'Close',
              style: TextStyle(color: CatppuccinMocha.red),
            ),
          ),
        ],
      ),
    );
  }

  void _showNewSessionDialog(BuildContext context, WidgetRef ref) {
    final nameController = TextEditingController();
    final pathController = TextEditingController(text: '~/dev/');
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: CatppuccinMocha.surface,
        title: Text(
          'New Session',
          style: TextStyle(color: CatppuccinMocha.text),
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: nameController,
              style: TextStyle(color: CatppuccinMocha.text),
              decoration: InputDecoration(
                labelText: 'Project Name',
                hintText: 'e.g., api, mobile, web',
                hintStyle: TextStyle(color: CatppuccinMocha.overlay1),
                border: OutlineInputBorder(
                  borderSide: BorderSide(color: CatppuccinMocha.surface1),
                ),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: pathController,
              style: TextStyle(color: CatppuccinMocha.text),
              decoration: InputDecoration(
                labelText: 'Project Path',
                hintStyle: TextStyle(color: CatppuccinMocha.overlay1),
                border: OutlineInputBorder(
                  borderSide: BorderSide(color: CatppuccinMocha.surface1),
                ),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              final name = nameController.text.trim();
              final path = pathController.text.trim();
              if (name.isNotEmpty && path.isNotEmpty) {
                final success = await ref
                    .read(sessionManagerProvider.notifier)
                    .createSession(projectPath: path, projectName: name);
                if (context.mounted) {
                  if (!success) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('Max sessions reached'),
                        backgroundColor: CatppuccinMocha.red,
                      ),
                    );
                  }
                  Navigator.pop(context);
                }
              }
            },
            child: Text(
              'Create',
              style: TextStyle(color: CatppuccinMocha.mauve),
            ),
          ),
        ],
      ),
    );
  }
}

class _NewSessionButton extends StatelessWidget {
  final VoidCallback? onPressed;

  const _NewSessionButton({required this.onPressed});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 32,
      margin: const EdgeInsets.only(right: 8),
      child: IconButton(
        icon: Icon(Icons.add, size: 18),
        padding: const EdgeInsets.all(4),
        onPressed: onPressed,
        style: IconButton.styleFrom(
          backgroundColor: onPressed != null
              ? CatppuccinMocha.mauve.withValues(alpha: 0.2)
              : CatppuccinMocha.surface0,
          foregroundColor: onPressed != null
              ? CatppuccinMocha.mauve
              : CatppuccinMocha.overlay1,
        ),
        tooltip: 'New Session',
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/tab_item.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';
import '../models/session_status.dart';
import '../models/vibe_session.dart';

/// Single tab item for session navigation
///
/// Phase 02: Multi-Session Tab Architecture
/// Tap to switch, long press for menu
class TabItem extends StatelessWidget {
  final VibeSession session;
  final bool isActive;
  final VoidCallback onTap;
  final VoidCallback onLongPress;

  const TabItem({
    super.key,
    required this.session,
    required this.isActive,
    required this.onTap,
    required this.onLongPress,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      onLongPress: onLongPress,
      child: Container(
        margin: const EdgeInsets.only(right: 4),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: isActive
              ? CatppuccinMocha.surface0
              : CatppuccinMocha.mantle,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: _getBorderColor(),
            width: isActive ? 2 : 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Status indicator
            _StatusIndicator(status: session.status),
            const SizedBox(width: 6),
            // Session name
            Text(
              session.projectName,
              style: TextStyle(
                color: CatppuccinMocha.text,
                fontSize: 13,
                fontWeight: isActive ? FontWeight.w600 : FontWeight.w500,
              ),
            ),
            if (isActive) ...[
              const SizedBox(width: 4),
              Icon(
                Icons.expand_more,
                size: 14,
                color: CatppuccinMocha.subtext0,
              ),
            ],
          ],
        ),
      ),
    );
  }

  Color _getBorderColor() {
    switch (session.status) {
      case SessionStatus.active:
        return CatppuccinMocha.mauve;
      case SessionStatus.idle:
        return CatppuccinMocha.surface1;
      case SessionStatus.busy:
        return CatppuccinMocha.yellow;
      case SessionStatus.error:
        return CatppuccinMocha.red;
    }
  }
}

class _StatusIndicator extends StatelessWidget {
  final SessionStatus status;

  const _StatusIndicator({required this.status});

  @override
  Widget build(BuildContext context) {
    Color color;
    double size;

    switch (status) {
      case SessionStatus.active:
        color = CatppuccinMocha.mauve;
        size = 6;
        break;
      case SessionStatus.idle:
        color = CatppuccinMocha.overlay1;
        size = 6;
        break;
      case SessionStatus.busy:
        // Spinner for busy status
        return SizedBox(
          width: 10,
          height: 10,
          child: CircularProgressIndicator(
            strokeWidth: 2,
            valueColor: AlwaysStoppedAnimation<Color>(CatppuccinMocha.yellow),
          ),
        );
      case SessionStatus.error:
        color = CatppuccinMocha.red;
        size = 6;
        break;
    }

    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        color: color,
        shape: BoxShape.circle,
      ),
    );
  }
}

================
File: lib/features/vibe/widgets/thinking_indicator.dart
================
import 'package:flutter/material.dart';

import '../../../core/theme.dart';

/// "Claude thinking" indicator with pulse animation
///
/// Shows when output is paused but Claude is working (connected but no recent output).
/// Uses subtle pulsing animation to indicate activity without distraction.
class ThinkingIndicator extends StatefulWidget {
  final bool isThinking;
  final String? label;

  const ThinkingIndicator({
    super.key,
    required this.isThinking,
    this.label,
  });

  @override
  State<ThinkingIndicator> createState() => _ThinkingIndicatorState();
}

class _ThinkingIndicatorState extends State<ThinkingIndicator>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );

    _scaleAnimation = Tween<double>(
      begin: 0.8,
      end: 1.2,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.3,
      end: 0.8,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    _controller.repeat(reverse: true);
  }

  @override
  void didUpdateWidget(ThinkingIndicator oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isThinking != oldWidget.isThinking) {
      if (widget.isThinking) {
        _controller.repeat(reverse: true);
      } else {
        _controller.stop();
      }
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.isThinking) {
      return const SizedBox.shrink();
    }

    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Opacity(
          opacity: _opacityAnimation.value,
          child: Transform.scale(
            scale: _scaleAnimation.value,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              decoration: BoxDecoration(
                color: CatppuccinMocha.mantle,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: CatppuccinMocha.yellow.withValues(alpha: 0.3),
                  width: 1,
                ),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  SizedBox(
                    width: 8,
                    height: 8,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation(CatppuccinMocha.yellow),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    widget.label ?? 'Claude is thinking...',
                    style: TextStyle(
                      color: CatppuccinMocha.subtext0,
                      fontSize: 12,
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}

/// Fade transition wrapper for smooth page transitions
class FadeTransitionWrapper extends StatefulWidget {
  final Widget child;
  final Duration duration;
  final bool visible;

  const FadeTransitionWrapper({
    super.key,
    required this.child,
    this.duration = const Duration(milliseconds: 200),
    this.visible = true,
  });

  @override
  State<FadeTransitionWrapper> createState() =>
      _FadeTransitionWrapperState();
}

class _FadeTransitionWrapperState extends State<FadeTransitionWrapper>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: widget.duration,
    );
    _animation = CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    );

    if (widget.visible) {
      _controller.forward();
    }
  }

  @override
  void didUpdateWidget(FadeTransitionWrapper oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.visible != oldWidget.visible) {
      if (widget.visible) {
        _controller.forward();
      } else {
        _controller.reverse();
      }
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _animation,
      child: widget.child,
    );
  }
}

/// Scale animation for button presses
class ScalePressAnimation extends StatefulWidget {
  final Widget child;
  final VoidCallback? onTap;
  final double scaleDown;

  const ScalePressAnimation({
    super.key,
    required this.child,
    this.onTap,
    this.scaleDown = 0.95,
  });

  @override
  State<ScalePressAnimation> createState() => _ScalePressAnimationState();
}

class _ScalePressAnimationState extends State<ScalePressAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scale;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 100),
    );
    _scale = Tween<double>(begin: 1.0, end: widget.scaleDown).animate(
      CurvedAnimation(
        parent: _controller,
        curve: Curves.easeOut,
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
    _controller.forward();
  }

  void _handleTapUp(TapUpDetails details) {
    _controller.reverse();
  }

  void _handleTapCancel() {
    _controller.reverse();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: _handleTapDown,
      onTapUp: _handleTapUp,
      onTapCancel: _handleTapCancel,
      onTap: widget.onTap,
      child: ScaleTransition(
        scale: _scale,
        child: widget.child,
      ),
    );
  }
}

================
File: lib/features/vibe/vibe_session_page.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/theme.dart';
import '../../bridge/bridge_wrapper.dart';
import '../connection/connection_providers.dart';
import '../project/models/project.dart';
import '../project/models/session_metadata.dart';
import 'models/vibe_session_state.dart';
import 'vibe_session_providers.dart';
import 'widgets/input_bar.dart';
import 'widgets/output_view.dart';
import 'widgets/search_overlay.dart';
import 'widgets/session_tab_bar.dart';

/// Vibe Session Page - Chat-style interface for Claude Code CLI
///
/// Phase 01: Core Vibe UI (MVP)
/// - Chat-style output display with xterm
/// - Input bar with prompt field
/// - Quick keys toolbar
/// - Dual-mode toggle (Raw / Parsed)
///
/// Phase 02: Enhanced Features
/// - Enhanced output parsing (files, diffs, collapsible)
/// - Output search functionality
///
/// Phase 05: Multi-session support
/// - Accept optional Project and SessionMetadata context
/// - Re-attach/re-spawn logic for session restoration
class VibeSessionPage extends ConsumerStatefulWidget {
  /// Project context (optional - null for direct connection)
  final Project? project;

  /// Session metadata (optional - null for direct connection)
  final SessionMetadata? session;

  const VibeSessionPage({
    this.project,
    this.session,
    super.key,
  });

  @override
  ConsumerState<VibeSessionPage> createState() => _VibeSessionPageState();
}

class _VibeSessionPageState extends ConsumerState<VibeSessionPage> {
  bool _showSearch = false;
  bool _isRestoring = false;
  String? _restoreMessage;

  @override
  void initState() {
    super.initState();
    // Phase 05: Initialize session with re-attach/re-spawn logic
    if (widget.project != null && widget.session != null) {
      _initializeSessionWithRetry();
    }
  }

  /// Initialize session with re-attach/re-spawn logic
  ///
  /// Phase 05: When app restarts, mobile has session metadata but server PTYs may be dead.
  /// Strategy:
  /// 1. Check if session exists on server
  /// 2. If exists  Re-attach (reuse existing PTY)
  /// 3. If not exists  Re-spawn (create new PTY with same config)
  Future<void> _initializeSessionWithRetry() async {
    setState(() => _isRestoring = true);

    try {
      final sessionId = widget.session!.id;
      final projectPath = widget.project!.path;

      setState(() => _restoreMessage = 'Checking session...');

      // Step 1: Check if session exists on server
      final bridge = ref.read(bridgeWrapperProvider);
      final exists = await bridge.checkSession(sessionId);

      if (exists) {
        // Re-attach: Server PTY still alive, just connect
        setState(() => _restoreMessage = 'Restoring session...');
        await _attachToExistingSession(sessionId);
      } else {
        // Re-spawn: Create new PTY with same config
        setState(() => _restoreMessage = 'Starting new session...');
        await bridge.createSession(
          projectPath: projectPath,
          sessionId: sessionId,
        );
      }

      // Step 2: Switch to this session on server
      setState(() => _restoreMessage = 'Connecting...');
      await bridge.switchSession(sessionId);

      // Step 3: Clear restore message after delay
      if (mounted) {
        Future.delayed(const Duration(seconds: 1), () {
          if (mounted) setState(() => _restoreMessage = null);
        });
      }

    } catch (e) {
      if (mounted) {
        setState(() => _restoreMessage = 'Failed: $e');
      }
    } finally {
      if (mounted) {
        setState(() => _isRestoring = false);
      }
    }
  }

  Future<void> _attachToExistingSession(String sessionId) async {
    // Subscribe to TaggedOutput for this session_id
    // Local output buffer will be populated from history
    // TODO: Implement when FRB bindings support history receive
  }

  @override
  Widget build(BuildContext context) {
    final connectionState = ref.watch(connectionStateProvider);
    final vibeState = ref.watch(vibeSessionProvider);

    // Phase 05: Show restoring state
    if (_isRestoring) {
      return Scaffold(
        backgroundColor: CatppuccinMocha.base,
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              CircularProgressIndicator(color: CatppuccinMocha.blue),
              const SizedBox(height: 16),
              Text(
                _restoreMessage ?? 'Restoring session...',
                style: TextStyle(
                  color: CatppuccinMocha.text,
                  fontSize: 16,
                ),
              ),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: CatppuccinMocha.base,
      appBar: AppBar(
        title: Text(
          connectionState.isConnected
              ? (widget.session?.name ?? 'Vibe Session')
              : 'Not Connected',
          style: TextStyle(
            color: CatppuccinMocha.text,
            fontWeight: FontWeight.w600,
          ),
        ),
        backgroundColor: CatppuccinMocha.mantle,
        elevation: 0,
        actions: [
          // Connection status indicator
          _ConnectionStatusBadge(state: connectionState),
          const SizedBox(width: 8),
          // Search button (Phase 02)
          if (connectionState.isConnected)
            IconButton(
              icon: Icon(Icons.search, color: CatppuccinMocha.text),
              onPressed: () {
                setState(() {
                  _showSearch = !_showSearch;
                });
              },
              tooltip: 'Search in output',
            ),
          const SizedBox(width: 4),
          // Mode toggle
          _ModeToggle(
            isRaw: vibeState.isOutputModeRaw,
            onTap: () =>
                ref.read(vibeSessionProvider.notifier).toggleOutputMode(),
          ),
          const SizedBox(width: 8),
          // Menu
          PopupMenuButton<String>(
            icon: Icon(Icons.more_vert, color: CatppuccinMocha.text),
            color: CatppuccinMocha.surface,
            onSelected: (value) {
              if (value == 'disconnect') {
                ref.read(connectionStateProvider.notifier).disconnect();
                if (context.mounted) {
                  // Phase 07: Navigate all the way back to HomePage on disconnect
                  Navigator.of(context).popUntil((route) => route.isFirst);
                }
              } else if (value == 'clear') {
                vibeState.terminal.eraseDisplay();
              }
            },
            itemBuilder: (context) => [
              const PopupMenuItem(
                value: 'clear',
                child: ListTile(
                  leading: Icon(Icons.clear, color: CatppuccinMocha.text),
                  title: Text(
                    'Clear Terminal',
                    style: TextStyle(color: CatppuccinMocha.text),
                  ),
                  contentPadding: EdgeInsets.zero,
                ),
              ),
              const PopupMenuItem(
                value: 'disconnect',
                child: ListTile(
                  leading: Icon(Icons.close, color: CatppuccinMocha.red),
                  title: Text(
                    'Disconnect',
                    style: TextStyle(color: CatppuccinMocha.red),
                  ),
                  contentPadding: EdgeInsets.zero,
                ),
              ),
            ],
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: connectionState.isConnected
          ? _buildConnected(context, ref, vibeState)
          : _buildDisconnected(context, connectionState),
    );
  }

  Widget _buildConnected(BuildContext context, WidgetRef ref,
      VibeSessionState vibeState) {
    return Stack(
      children: [
        Column(
          children: [
            // Tab bar for multi-session (Phase 02)
            const SessionTabBar(),
            // Output display (xterm or parsed)
            Expanded(
              child: vibeState.isOutputModeRaw
                  ? OutputView(
                      terminal: vibeState.terminal,
                      isParsedMode: false,
                    )
                  : _buildParsedOutput(context, ref, vibeState),
            ),
            // Input bar + Quick keys
            const InputBar(),
            // Error banner
            if (vibeState.error != null)
              Container(
                padding: const EdgeInsets.all(12),
                color: CatppuccinMocha.red.withValues(alpha: 0.2),
                child: Row(
                  children: [
                    Icon(Icons.error_outline, color: CatppuccinMocha.red, size: 20),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        vibeState.error!,
                        style: TextStyle(color: CatppuccinMocha.red),
                      ),
                    ),
                    IconButton(
                      icon: Icon(Icons.close, color: CatppuccinMocha.red, size: 18),
                      onPressed: () =>
                          ref.read(vibeSessionProvider.notifier).clearError(),
                    ),
                  ],
                ),
              ),
          ],
        ),
        // Search overlay (Phase 02)
        if (_showSearch)
          Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: OutputSearchOverlay(
              output: '', // Terminal output is accessed via xterm
              terminal: vibeState.terminal,
              onClose: () {
                setState(() {
                  _showSearch = false;
                });
              },
            ),
          ),
      ],
    );
  }

  Widget _buildParsedOutput(BuildContext context, WidgetRef ref,
      VibeSessionState vibeState) {
    // For now, use xterm in parsed mode with highlighting enabled
    // Full parsed output view would require capturing terminal buffer
    return OutputView(
      terminal: vibeState.terminal,
      isParsedMode: true,
      onFileTap: () {
        // TODO: Navigate to VFS with file path
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('File tap detected'),
            backgroundColor: CatppuccinMocha.blue,
            duration: Duration(seconds: 1),
          ),
        );
      },
    );
  }

  Widget _buildDisconnected(BuildContext context, ConnectionModel state) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.wifi_off,
            size: 64,
            color: CatppuccinMocha.red,
          ),
          const SizedBox(height: 16),
          Text(
            'Not connected',
            style: TextStyle(
              color: CatppuccinMocha.text,
              fontSize: 20,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 32),
            child: Text(
              state.errorMessage ?? 'Please connect to a host first',
              style: TextStyle(
                color: CatppuccinMocha.subtext0,
                fontSize: 14,
              ),
              textAlign: TextAlign.center,
            ),
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            onPressed: () => Navigator.of(context).pop(),
            icon: const Icon(Icons.qr_code_scanner),
            label: const Text('Scan QR Code'),
            style: ElevatedButton.styleFrom(
              backgroundColor: CatppuccinMocha.mauve,
              foregroundColor: CatppuccinMocha.crust,
            ),
          ),
        ],
      ),
    );
  }
}

class _ConnectionStatusBadge extends StatelessWidget {
  final ConnectionModel state;

  const _ConnectionStatusBadge({required this.state});

  @override
  Widget build(BuildContext context) {
    final color = switch (state.status) {
      ConnectionStatus.connected => CatppuccinMocha.green,
      ConnectionStatus.connecting => CatppuccinMocha.yellow,
      ConnectionStatus.error => CatppuccinMocha.red,
      ConnectionStatus.disconnected => CatppuccinMocha.surface1,
    };

    final label = switch (state.status) {
      ConnectionStatus.connected => 'Connected',
      ConnectionStatus.connecting => 'Connecting...',
      ConnectionStatus.error => 'Error',
      ConnectionStatus.disconnected => 'Disconnected',
    };

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
      decoration: BoxDecoration(
        color: CatppuccinMocha.surface0,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color, width: 1.5),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 6,
            height: 6,
            decoration: BoxDecoration(
              color: color,
              shape: BoxShape.circle,
            ),
          ),
          const SizedBox(width: 6),
          Text(
            label,
            style: TextStyle(
              color: CatppuccinMocha.text,
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}

class _ModeToggle extends StatelessWidget {
  final bool isRaw;
  final VoidCallback onTap;

  const _ModeToggle({
    required this.isRaw,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: CatppuccinMocha.surface0,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: CatppuccinMocha.surface1,
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              isRaw ? 'Raw' : 'Parsed',
              style: TextStyle(
                color: CatppuccinMocha.text,
                fontSize: 12,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(width: 4),
            Icon(
              Icons.swap_horiz,
              size: 16,
              color: CatppuccinMocha.overlay1,
            ),
          ],
        ),
      ),
    );
  }
}

================
File: lib/features/vibe/vibe_session_providers.dart
================
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../bridge/bridge_wrapper.dart';
import 'models/output_buffer.dart';
import 'models/special_key.dart';
import 'models/vibe_session_state.dart';

/// Vibe session state provider
final vibeSessionProvider =
    StateNotifierProvider<VibeSessionNotifier, VibeSessionState>((ref) {
  return VibeSessionNotifier(ref.read(bridgeWrapperProvider));
});

/// Vibe session notifier
class VibeSessionNotifier extends StateNotifier<VibeSessionState> {
  final BridgeWrapper _bridge;

  VibeSessionNotifier(this._bridge)
      : super(VibeSessionState()) {
    // Initialize terminal
    _startEventLoop();
  }

  Timer? _eventLoopTimer;
  bool _isDisposed = false;

  /// Output buffer to prevent memory issues with large output
  final OutputBuffer _outputBuffer = OutputBuffer();

  /// Send prompt text to backend
  Future<void> sendPrompt(String prompt) async {
    state = state.copyWith(isSending: true, error: null);

    try {
      await _bridge.sendCommand(prompt);
      state = state.copyWith(isSending: false);
    } catch (e) {
      state = state.copyWith(
        isSending: false,
        error: 'Failed to send prompt: $e',
      );
    }
  }

  /// Send special key to backend
  Future<void> sendSpecialKey(SpecialKey key) async {
    try {
      await _bridge.sendCommand(key.sequence);
    } catch (e) {
      state = state.copyWith(error: 'Failed to send key: $e');
    }
  }

  /// Toggle between Raw and Parsed mode
  void toggleOutputMode() {
    state = state.copyWith(isOutputModeRaw: !state.isOutputModeRaw);
  }

  /// Clear error state
  void clearError() {
    state = state.copyWith(error: null);
  }

  /// Start event loop to receive PTY output
  void _startEventLoop() {
    _eventLoopTimer = Timer.periodic(
      const Duration(milliseconds: 100),
      (timer) async {
        if (_isDisposed) {
          timer.cancel();
          return;
        }

        try {
          final event = await _bridge.receiveEvent();

          if (_isDisposed) return;

          if (isEventOutput(event)) {
            final data = getEventData(event);
            if (data.isNotEmpty) {
              try {
                final text = String.fromCharCodes(data);

                // Add to output buffer (limits memory growth)
                _outputBuffer.add(text);

                // Write to terminal for display
                state.terminal.write(text);

                // Log buffer stats periodically for monitoring
                if (_outputBuffer.length % 1000 == 0) {
                  final stats = _outputBuffer.stats;
                  if (stats['isFull'] == true) {
                    // Buffer at capacity - oldest lines being dropped
                    debugPrint('Output buffer at capacity: ${stats['lines']} lines');
                  }
                }
              } catch (e) {
                // Ignore decode errors
              }
            }
          } else if (isEventError(event)) {
            final message = getEventErrorMessage(event);
            final errorText = '\x1b[31mError: $message\x1b[0m\r\n';
            _outputBuffer.add(errorText);
            state.terminal.write(errorText);
          } else if (isEventExit(event)) {
            final code = getEventExitCode(event);
            final exitText = '\r\n\x1b[33mProcess exited with code $code\x1b[0m\r\n';
            _outputBuffer.add(exitText);
            state.terminal.write(exitText);
          }
        } catch (e) {
          // Silent ignore
        }
      },
    );
  }

  /// Get buffered output (for search/export features)
  String getBufferedOutput() {
    return _outputBuffer.toString();
  }

  /// Get buffer statistics
  Map<String, dynamic> getBufferStats() {
    return _outputBuffer.stats;
  }

  /// Clear output buffer and terminal
  void clearOutput() {
    _outputBuffer.clear();
    state.terminal.eraseDisplay();
  }

  @override
  void dispose() {
    _isDisposed = true;
    _eventLoopTimer?.cancel();
    super.dispose();
  }
}

// Temporary helper functions - will be replaced with proper bridge methods
bool isEventOutput(dynamic event) => false;
List<int> getEventData(dynamic event) => [];
bool isEventError(dynamic event) => false;
String getEventErrorMessage(dynamic event) => '';
bool isEventExit(dynamic event) => false;
int getEventExitCode(dynamic event) => 0;

================
File: lib/models/dir_entry.dart
================
import '../bridge/ffi_helpers.dart';

/// Directory entry for VFS browsing
///
/// Phase VFS-2: Flutter UI for file system browser
class VfsEntry {
  final String name;
  final String path;
  final bool isDir;
  final bool isSymlink;
  final int? size;
  final int? modified;
  final String? permissions;

  VfsEntry({
    required this.name,
    required this.path,
    required this.isDir,
    this.isSymlink = false,
    this.size,
    this.modified,
    this.permissions,
  });

  /// Create VfsEntry from FFI-generated DirEntry
  factory VfsEntry.fromFrb(DirEntry frbEntry) {
    // Parse FFI response using helper functions
    return VfsEntry(
      name: getDirEntryName(frbEntry),
      path: getDirEntryPath(frbEntry),
      isDir: isDirEntryDir(frbEntry),
      isSymlink: isDirEntrySymlink(frbEntry),
      size: getDirEntrySize(frbEntry),
      modified: getDirEntryModified(frbEntry),
      permissions: getDirEntryPermissions(frbEntry),
    );
  }

  /// Format file size for display (KB, MB, GB)
  String get formattedSize {
    if (size == null) return '';
    final bytes = size!;
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }

  /// Get formatted modified time
  String get formattedModified {
    if (modified == null) return '';
    final date = DateTime.fromMillisecondsSinceEpoch(modified! * 1000);
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} '
        '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }

  @override
  String toString() => 'VfsEntry(name: $name, path: $path, isDir: $isDir)';

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VfsEntry &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          path == other.path;

  @override
  int get hashCode => name.hashCode ^ path.hashCode;
}

================
File: lib/main.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated_io.dart';
import 'core/theme.dart';
import 'features/connection/home_page.dart';
import 'features/vibe/vibe_session_page.dart';
import 'bridge/frb_generated.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Static library (.a) is linked via -force_load, symbols are in main process
  await RustLib.init(
    externalLibrary: ExternalLibrary.process(iKnowHowToUseIt: true),
  );

  runApp(
    const ProviderScope(
      child: ComacodeApp(),
    ),
  );
}

class ComacodeApp extends StatelessWidget {
  const ComacodeApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Comacode',
      debugShowCheckedModeBanner: false,
      theme: CatppuccinMocha.lightTheme,
      darkTheme: CatppuccinMocha.darkTheme,
      themeMode: ThemeMode.dark,
      home: const HomePage(),
      routes: {
        '/vibe': (context) => const VibeSessionPage(),
      },
    );
  }
}

================
File: macos/Flutter/Flutter-Debug.xcconfig
================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"

================
File: macos/Flutter/Flutter-Release.xcconfig
================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"

================
File: macos/Flutter/GeneratedPluginRegistrant.swift
================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import connectivity_plus
import flutter_secure_storage_macos
import mobile_scanner
import package_info_plus
import path_provider_foundation
import shared_preferences_foundation
import speech_to_text_macos
import wakelock_plus

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  ConnectivityPlusPlugin.register(with: registry.registrar(forPlugin: "ConnectivityPlusPlugin"))
  FlutterSecureStoragePlugin.register(with: registry.registrar(forPlugin: "FlutterSecureStoragePlugin"))
  MobileScannerPlugin.register(with: registry.registrar(forPlugin: "MobileScannerPlugin"))
  FPPPackageInfoPlusPlugin.register(with: registry.registrar(forPlugin: "FPPPackageInfoPlusPlugin"))
  PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
  SharedPreferencesPlugin.register(with: registry.registrar(forPlugin: "SharedPreferencesPlugin"))
  SpeechToTextMacosPlugin.register(with: registry.registrar(forPlugin: "SpeechToTextMacosPlugin"))
  WakelockPlusMacosPlugin.register(with: registry.registrar(forPlugin: "WakelockPlusMacosPlugin"))
}

================
File: macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

================
File: macos/Runner/Base.lproj/MainMenu.xib
================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>

================
File: macos/Runner/Configs/AppInfo.xcconfig
================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = comacode

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright  2026 com.comacode. All rights reserved.

================
File: macos/Runner/Configs/Debug.xcconfig
================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"

================
File: macos/Runner/Configs/Release.xcconfig
================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"

================
File: macos/Runner/Configs/Warnings.xcconfig
================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES

================
File: macos/Runner/AppDelegate.swift
================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}

================
File: macos/Runner/DebugProfile.entitlements
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>

================
File: macos/Runner/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>

================
File: macos/Runner/MainFlutterWindow.swift
================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}

================
File: macos/Runner/Release.entitlements
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>

================
File: macos/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

================
File: macos/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "33CC10EC2044A3C60003C045"
               BuildableName = "comacode.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "comacode.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C80D4294CF70F00263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "comacode.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "comacode.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: macos/Runner.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXAggregateTarget section */
		33CC111A2044C6BA0003C045 /* Flutter Assemble */ = {
			isa = PBXAggregateTarget;
			buildConfigurationList = 33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */;
			buildPhases = (
				33CC111E2044C6BF0003C045 /* ShellScript */,
			);
			dependencies = (
			);
			name = "Flutter Assemble";
			productName = FLX;
		};
/* End PBXAggregateTarget section */

/* Begin PBXBuildFile section */
		331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C80D7294CF71000263BE5 /* RunnerTests.swift */; };
		335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */ = {isa = PBXBuildFile; fileRef = 335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */; };
		33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC10F02044A3C60003C045 /* AppDelegate.swift */; };
		33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F22044A3C60003C045 /* Assets.xcassets */; };
		33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F42044A3C60003C045 /* MainMenu.xib */; };
		33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC11122044BFA00003C045 /* MainFlutterWindow.swift */; };
		C16BA9B3E33F942F59013E27 /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7D94B782703CE624ED06E3B7 /* Pods_RunnerTests.framework */; };
		E8C52F8F81C7EBD48D507226 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 62DA17457561B6519A98427C /* Pods_Runner.framework */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C80D9294CF71000263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC10EC2044A3C60003C045;
			remoteInfo = Runner;
		};
		33CC111F2044C79F0003C045 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC111A2044C6BA0003C045;
			remoteInfo = FLX;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		33CC110E2044A8840003C045 /* Bundle Framework */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Bundle Framework";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		025D043821349AD53747993B /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
		0E04D7ECAC16450617A737DC /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
		27085F75900832318BE4B2C4 /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
		331C80D5294CF71000263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		331C80D7294CF71000263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		333000ED22D3DE5D00554162 /* Warnings.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Warnings.xcconfig; sourceTree = "<group>"; };
		335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GeneratedPluginRegistrant.swift; sourceTree = "<group>"; };
		33CC10ED2044A3C60003C045 /* comacode.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = comacode.app; sourceTree = BUILT_PRODUCTS_DIR; };
		33CC10F02044A3C60003C045 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		33CC10F22044A3C60003C045 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Assets.xcassets; path = Runner/Assets.xcassets; sourceTree = "<group>"; };
		33CC10F52044A3C60003C045 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
		33CC10F72044A3C60003C045 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; name = Info.plist; path = Runner/Info.plist; sourceTree = "<group>"; };
		33CC11122044BFA00003C045 /* MainFlutterWindow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainFlutterWindow.swift; sourceTree = "<group>"; };
		33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Debug.xcconfig"; sourceTree = "<group>"; };
		33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Release.xcconfig"; sourceTree = "<group>"; };
		33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = "Flutter-Generated.xcconfig"; path = "ephemeral/Flutter-Generated.xcconfig"; sourceTree = "<group>"; };
		33E51913231747F40026EE4D /* DebugProfile.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = DebugProfile.entitlements; sourceTree = "<group>"; };
		33E51914231749380026EE4D /* Release.entitlements */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.entitlements; path = Release.entitlements; sourceTree = "<group>"; };
		33E5194F232828860026EE4D /* AppInfo.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = AppInfo.xcconfig; sourceTree = "<group>"; };
		62DA17457561B6519A98427C /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		7D94B782703CE624ED06E3B7 /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
		C8304D3C5EC0B1D2E65EEA62 /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
		DE26FDD0484896112E35F6E9 /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
		E6E98780F9173F63E6AF3466 /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		331C80D2294CF70F00263BE5 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				C16BA9B3E33F942F59013E27 /* Pods_RunnerTests.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EA2044A3C60003C045 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E8C52F8F81C7EBD48D507226 /* Pods_Runner.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C80D6294CF71000263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C80D7294CF71000263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		33BA886A226E78AF003329D5 /* Configs */ = {
			isa = PBXGroup;
			children = (
				33E5194F232828860026EE4D /* AppInfo.xcconfig */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				333000ED22D3DE5D00554162 /* Warnings.xcconfig */,
			);
			path = Configs;
			sourceTree = "<group>";
		};
		33CC10E42044A3C60003C045 = {
			isa = PBXGroup;
			children = (
				33FAB671232836740065AC1E /* Runner */,
				33CEB47122A05771004F2AC0 /* Flutter */,
				331C80D6294CF71000263BE5 /* RunnerTests */,
				33CC10EE2044A3C60003C045 /* Products */,
				D73912EC22F37F3D000D13A0 /* Frameworks */,
				5334D018371D7136A03CE6C4 /* Pods */,
			);
			sourceTree = "<group>";
		};
		33CC10EE2044A3C60003C045 /* Products */ = {
			isa = PBXGroup;
			children = (
				33CC10ED2044A3C60003C045 /* comacode.app */,
				331C80D5294CF71000263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		33CC11242044D66E0003C045 /* Resources */ = {
			isa = PBXGroup;
			children = (
				33CC10F22044A3C60003C045 /* Assets.xcassets */,
				33CC10F42044A3C60003C045 /* MainMenu.xib */,
				33CC10F72044A3C60003C045 /* Info.plist */,
			);
			name = Resources;
			path = ..;
			sourceTree = "<group>";
		};
		33CEB47122A05771004F2AC0 /* Flutter */ = {
			isa = PBXGroup;
			children = (
				335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */,
				33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */,
				33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */,
				33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */,
			);
			path = Flutter;
			sourceTree = "<group>";
		};
		33FAB671232836740065AC1E /* Runner */ = {
			isa = PBXGroup;
			children = (
				33CC10F02044A3C60003C045 /* AppDelegate.swift */,
				33CC11122044BFA00003C045 /* MainFlutterWindow.swift */,
				33E51913231747F40026EE4D /* DebugProfile.entitlements */,
				33E51914231749380026EE4D /* Release.entitlements */,
				33CC11242044D66E0003C045 /* Resources */,
				33BA886A226E78AF003329D5 /* Configs */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		5334D018371D7136A03CE6C4 /* Pods */ = {
			isa = PBXGroup;
			children = (
				DE26FDD0484896112E35F6E9 /* Pods-Runner.debug.xcconfig */,
				E6E98780F9173F63E6AF3466 /* Pods-Runner.release.xcconfig */,
				025D043821349AD53747993B /* Pods-Runner.profile.xcconfig */,
				C8304D3C5EC0B1D2E65EEA62 /* Pods-RunnerTests.debug.xcconfig */,
				0E04D7ECAC16450617A737DC /* Pods-RunnerTests.release.xcconfig */,
				27085F75900832318BE4B2C4 /* Pods-RunnerTests.profile.xcconfig */,
			);
			name = Pods;
			path = Pods;
			sourceTree = "<group>";
		};
		D73912EC22F37F3D000D13A0 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				62DA17457561B6519A98427C /* Pods_Runner.framework */,
				7D94B782703CE624ED06E3B7 /* Pods_RunnerTests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C80D4294CF70F00263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				E07766B617804C60C53295E8 /* [CP] Check Pods Manifest.lock */,
				331C80D1294CF70F00263BE5 /* Sources */,
				331C80D2294CF70F00263BE5 /* Frameworks */,
				331C80D3294CF70F00263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C80DA294CF71000263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C80D5294CF71000263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		33CC10EC2044A3C60003C045 /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				D9D4D51ABCE3E239591EAB7B /* [CP] Check Pods Manifest.lock */,
				33CC10E92044A3C60003C045 /* Sources */,
				33CC10EA2044A3C60003C045 /* Frameworks */,
				33CC10EB2044A3C60003C045 /* Resources */,
				33CC110E2044A8840003C045 /* Bundle Framework */,
				3399D490228B24CF009A79C7 /* ShellScript */,
				EF28B3FFCF1FD2FFA4152167 /* [CP] Embed Pods Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
				33CC11202044C79F0003C045 /* PBXTargetDependency */,
			);
			name = Runner;
			productName = Runner;
			productReference = 33CC10ED2044A3C60003C045 /* comacode.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		33CC10E52044A3C60003C045 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastSwiftUpdateCheck = 0920;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C80D4294CF70F00263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 33CC10EC2044A3C60003C045;
					};
					33CC10EC2044A3C60003C045 = {
						CreatedOnToolsVersion = 9.2;
						LastSwiftMigration = 1100;
						ProvisioningStyle = Automatic;
						SystemCapabilities = {
							com.apple.Sandbox = {
								enabled = 1;
							};
						};
					};
					33CC111A2044C6BA0003C045 = {
						CreatedOnToolsVersion = 9.2;
						ProvisioningStyle = Manual;
					};
				};
			};
			buildConfigurationList = 33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 33CC10E42044A3C60003C045;
			productRefGroup = 33CC10EE2044A3C60003C045 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				33CC10EC2044A3C60003C045 /* Runner */,
				331C80D4294CF70F00263BE5 /* RunnerTests */,
				33CC111A2044C6BA0003C045 /* Flutter Assemble */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C80D3294CF70F00263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EB2044A3C60003C045 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */,
				33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3399D490228B24CF009A79C7 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "echo \"$PRODUCT_NAME.app\" > \"$PROJECT_DIR\"/Flutter/ephemeral/.app_filename && \"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh embed\n";
		};
		33CC111E2044C6BF0003C045 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				Flutter/ephemeral/FlutterInputs.xcfilelist,
			);
			inputPaths = (
				Flutter/ephemeral/tripwire,
			);
			outputFileListPaths = (
				Flutter/ephemeral/FlutterOutputs.xcfilelist,
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh && touch Flutter/ephemeral/tripwire";
		};
		D9D4D51ABCE3E239591EAB7B /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		E07766B617804C60C53295E8 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		EF28B3FFCF1FD2FFA4152167 /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Embed Pods Frameworks";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C80D1294CF70F00263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10E92044A3C60003C045 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */,
				33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */,
				335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C80DA294CF71000263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC10EC2044A3C60003C045 /* Runner */;
			targetProxy = 331C80D9294CF71000263BE5 /* PBXContainerItemProxy */;
		};
		33CC11202044C79F0003C045 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC111A2044C6BA0003C045 /* Flutter Assemble */;
			targetProxy = 33CC111F2044C79F0003C045 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		33CC10F42044A3C60003C045 /* MainMenu.xib */ = {
			isa = PBXVariantGroup;
			children = (
				33CC10F52044A3C60003C045 /* Base */,
			);
			name = MainMenu.xib;
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		331C80DB294CF71000263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = C8304D3C5EC0B1D2E65EEA62 /* Pods-RunnerTests.debug.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/comacode.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/comacode";
			};
			name = Debug;
		};
		331C80DC294CF71000263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 0E04D7ECAC16450617A737DC /* Pods-RunnerTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/comacode.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/comacode";
			};
			name = Release;
		};
		331C80DD294CF71000263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 27085F75900832318BE4B2C4 /* Pods-RunnerTests.profile.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.comacode.comacode.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/comacode.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/comacode";
			};
			name = Profile;
		};
		338D0CE9231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Profile;
		};
		338D0CEA231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Profile;
		};
		338D0CEB231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Profile;
		};
		33CC10F92044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		33CC10FA2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Release;
		};
		33CC10FC2044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		33CC10FD2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Release.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		33CC111C2044C6BA0003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Debug;
		};
		33CC111D2044C6BA0003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C80DB294CF71000263BE5 /* Debug */,
				331C80DC294CF71000263BE5 /* Release */,
				331C80DD294CF71000263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10F92044A3C60003C045 /* Debug */,
				33CC10FA2044A3C60003C045 /* Release */,
				338D0CE9231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10FC2044A3C60003C045 /* Debug */,
				33CC10FD2044A3C60003C045 /* Release */,
				338D0CEA231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC111C2044C6BA0003C045 /* Debug */,
				33CC111D2044C6BA0003C045 /* Release */,
				338D0CEB231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 33CC10E52044A3C60003C045 /* Project object */;
}

================
File: macos/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

================
File: macos/Runner.xcworkspace/contents.xcworkspacedata
================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>

================
File: macos/RunnerTests/RunnerTests.swift
================
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}

================
File: macos/.gitignore
================
# Flutter-related
**/Flutter/ephemeral/
**/Pods/

# Xcode-related
**/dgph
**/xcuserdata/

================
File: macos/Podfile
================
platform :osx, '10.15'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'ephemeral', 'Flutter-Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure \"flutter pub get\" is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Flutter-Generated.xcconfig, then run \"flutter pub get\""
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_macos_podfile_setup

target 'Runner' do
  use_frameworks!

  flutter_install_all_macos_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_macos_build_settings(target)
  end
end

================
File: macos/Podfile.lock
================
PODS:
  - connectivity_plus (0.0.1):
    - FlutterMacOS
  - flutter_secure_storage_macos (6.1.3):
    - FlutterMacOS
  - FlutterMacOS (1.0.0)
  - mobile_scanner (3.5.6):
    - FlutterMacOS
  - package_info_plus (0.0.1):
    - FlutterMacOS
  - path_provider_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - shared_preferences_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - wakelock_plus (0.0.1):
    - FlutterMacOS

DEPENDENCIES:
  - connectivity_plus (from `Flutter/ephemeral/.symlinks/plugins/connectivity_plus/macos`)
  - flutter_secure_storage_macos (from `Flutter/ephemeral/.symlinks/plugins/flutter_secure_storage_macos/macos`)
  - FlutterMacOS (from `Flutter/ephemeral`)
  - mobile_scanner (from `Flutter/ephemeral/.symlinks/plugins/mobile_scanner/macos`)
  - package_info_plus (from `Flutter/ephemeral/.symlinks/plugins/package_info_plus/macos`)
  - path_provider_foundation (from `Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin`)
  - shared_preferences_foundation (from `Flutter/ephemeral/.symlinks/plugins/shared_preferences_foundation/darwin`)
  - wakelock_plus (from `Flutter/ephemeral/.symlinks/plugins/wakelock_plus/macos`)

EXTERNAL SOURCES:
  connectivity_plus:
    :path: Flutter/ephemeral/.symlinks/plugins/connectivity_plus/macos
  flutter_secure_storage_macos:
    :path: Flutter/ephemeral/.symlinks/plugins/flutter_secure_storage_macos/macos
  FlutterMacOS:
    :path: Flutter/ephemeral
  mobile_scanner:
    :path: Flutter/ephemeral/.symlinks/plugins/mobile_scanner/macos
  package_info_plus:
    :path: Flutter/ephemeral/.symlinks/plugins/package_info_plus/macos
  path_provider_foundation:
    :path: Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin
  shared_preferences_foundation:
    :path: Flutter/ephemeral/.symlinks/plugins/shared_preferences_foundation/darwin
  wakelock_plus:
    :path: Flutter/ephemeral/.symlinks/plugins/wakelock_plus/macos

SPEC CHECKSUMS:
  connectivity_plus: 4adf20a405e25b42b9c9f87feff8f4b6fde18a4e
  flutter_secure_storage_macos: 7f45e30f838cf2659862a4e4e3ee1c347c2b3b54
  FlutterMacOS: d0db08ddef1a9af05a5ec4b724367152bb0500b1
  mobile_scanner: 2f0c13d5ef778c4e5121348d775dce17f18e79d0
  package_info_plus: f0052d280d17aa382b932f399edf32507174e870
  path_provider_foundation: bb55f6dbba17d0dccd6737fe6f7f34fbd0376880
  shared_preferences_foundation: 7036424c3d8ec98dfe75ff1667cb0cd531ec82bb
  wakelock_plus: 917609be14d812ddd9e9528876538b2263aaa03b

PODFILE CHECKSUM: 54d867c82ac51cbd61b565781b9fada492027009

COCOAPODS: 1.16.2

================
File: test/features/project/models_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:comacode/features/project/models/project.dart';
import 'package:comacode/features/project/models/session_metadata.dart';

void main() {
  group('Project', () {
    test('should create project with correct properties', () {
      final project = Project.create(
        name: 'test-app',
        path: '/Users/dev/test-app',
      );

      expect(project.name, 'test-app');
      expect(project.path, '/Users/dev/test-app');
      expect(project.sessions, isEmpty);
      expect(project.id, isNotEmpty);
      expect(project.createdAt, isNotNull);
      expect(project.lastAccessed, isNotNull);
    });

    test('should copy with modified fields', () {
      final project = Project.create(
        name: 'original',
        path: '/path',
      );

      final updated = project.copyWith(name: 'updated');

      expect(updated.name, 'updated');
      expect(updated.path, '/path');
      expect(project.name, 'original'); // Original unchanged
    });

    test('should add session to project', () {
      final project = Project.create(
        name: 'test',
        path: '/path',
      );
      final session = SessionMetadata.create(name: 'Session 1');

      final updated = project.addSession(session);

      expect(updated.sessions.length, 1);
      expect(updated.sessions.first.name, 'Session 1');
      expect(project.sessions, isEmpty); // Original unchanged
    });

    test('should remove session from project', () {
      final session1 = SessionMetadata.create(name: 'S1');
      final session2 = SessionMetadata.create(name: 'S2');
      final project = Project.create(name: 'test', path: '/path')
          .addSession(session1)
          .addSession(session2);

      final updated = project.removeSession(session1.id);

      expect(updated.sessions.length, 1);
      expect(updated.sessions.first.id, session2.id);
    });

    test('should serialize and deserialize to JSON', () {
      final session = SessionMetadata.create(name: 'Test Session');
      final project = Project.create(
        name: 'my-app',
        path: '/Users/dev/my-app',
      ).addSession(session);

      final json = project.toJson();
      final restored = Project.fromJson(json);

      expect(restored.id, project.id);
      expect(restored.name, project.name);
      expect(restored.path, project.path);
      expect(restored.sessions.length, 1);
      expect(restored.sessions.first.name, 'Test Session');
    });

    test('should equality check by id', () {
      final project1 = Project.create(name: 'a', path: '/a');
      final project2 = Project(
        id: project1.id,
        name: 'b',
        path: '/b',
        createdAt: project1.createdAt,
        lastAccessed: project1.lastAccessed,
      );

      expect(project1, project2); // Same id
      expect(project1 == Project.create(name: 'x', path: '/y'), isFalse);
    });
  });

  group('SessionMetadata', () {
    test('should create session with correct properties', () {
      final session = SessionMetadata.create(name: 'Test Session');

      expect(session.name, 'Test Session');
      expect(session.id, isNotEmpty);
      expect(session.createdAt, isNotNull);
    });

    test('should serialize and deserialize to JSON', () {
      final session = SessionMetadata.create(name: 'My Session');

      final json = session.toJson();
      final restored = SessionMetadata.fromJson(json);

      expect(restored.id, session.id);
      expect(restored.name, session.name);
      expect(restored.createdAt, session.createdAt);
    });
  });
}

================
File: test/features/project/project_models_test.dart
================
import 'package:flutter_test/flutter_test.dart';
import 'package:comacode/features/project/models/models.dart';

void main() {
  group('SessionMetadata', () {
    test('create generates UUID', () {
      final session = SessionMetadata.create(name: 'Test Session');
      expect(session.id, isNotEmpty);
      expect(session.name, 'Test Session');
      expect(session.createdAt, isNotNull);
    });

    test('copyWith updates fields', () {
      final session = SessionMetadata.create(name: 'Original');
      final updated = session.copyWith(name: 'Updated');
      expect(updated.id, session.id);
      expect(updated.name, 'Updated');
    });

    test('toJson/fromJson roundtrip', () {
      final original = SessionMetadata.create(name: 'Roundtrip');
      final json = original.toJson();
      final restored = SessionMetadata.fromJson(json);
      expect(restored.id, original.id);
      expect(restored.name, original.name);
      expect(restored.createdAt, original.createdAt);
    });

    test('equality by id', () {
      final s1 = SessionMetadata(id: 'same', name: 'A', createdAt: DateTime.now());
      final s2 = SessionMetadata(id: 'same', name: 'B', createdAt: DateTime.now());
      expect(s1, equals(s2));
      expect(s1.hashCode, equals(s2.hashCode));
    });
  });

  group('Project', () {
    test('create generates UUID', () {
      final project = Project.create(name: 'test-app', path: '/dev/test');
      expect(project.id, isNotEmpty);
      expect(project.name, 'test-app');
      expect(project.path, '/dev/test');
      expect(project.sessions, isEmpty);
    });

    test('touch updates lastAccessed', () {
      final project = Project.create(name: 'test', path: '/tmp');
      final touched = project.touch();
      expect(touched.lastAccessed.isAfter(project.lastAccessed), isTrue);
    });

    test('addSession appends session', () {
      final project = Project.create(name: 'test', path: '/tmp');
      final session = SessionMetadata.create(name: 'Session 1');
      final withSession = project.addSession(session);
      expect(withSession.sessions, hasLength(1));
      expect(withSession.sessions.first.name, 'Session 1');
    });

    test('removeSession removes by id', () {
      final session1 = SessionMetadata.create(name: 'S1');
      final session2 = SessionMetadata.create(name: 'S2');
      final project = Project.create(name: 'test', path: '/tmp')
          .addSession(session1)
          .addSession(session2);
      final without = project.removeSession(session1.id);
      expect(without.sessions, hasLength(1));
      expect(without.sessions.first.id, session2.id);
    });

    test('updateSession replaces session', () {
      final original = SessionMetadata.create(name: 'Original');
      final project = Project.create(name: 'test', path: '/tmp').addSession(original);
      final updated = original.copyWith(name: 'Updated');
      final withUpdate = project.updateSession(updated);
      expect(withUpdate.sessions, hasLength(1));
      expect(withUpdate.sessions.first.name, 'Updated');
    });

    test('toJson/fromJson roundtrip', () {
      final original = Project.create(name: 'app', path: '/dev/app')
          .addSession(SessionMetadata.create(name: 'S1'));
      final json = original.toJson();
      final restored = Project.fromJson(json);
      expect(restored.id, original.id);
      expect(restored.name, original.name);
      expect(restored.path, original.path);
      expect(restored.sessions, hasLength(1));
      expect(restored.sessions.first.name, 'S1');
    });

    test('equality by id', () {
      final p1 = Project(
        id: 'same',
        name: 'A',
        path: '/a',
        createdAt: DateTime.now(),
        lastAccessed: DateTime.now(),
      );
      final p2 = Project(
        id: 'same',
        name: 'B',
        path: '/b',
        createdAt: DateTime.now(),
        lastAccessed: DateTime.now(),
      );
      expect(p1, equals(p2));
    });
  });
}

================
File: test/widget_test.dart
================
// Comacode widget tests
//
// Phase 04: Mobile App
// Phase 06: Riverpod update - wrap test with ProviderScope

import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'package:comacode/main.dart';

void main() {
  testWidgets('ComacodeApp smoke test', (WidgetTester tester) async {
    // Wrap with ProviderScope for Riverpod
    await tester.pumpWidget(
      const ProviderScope(
        child: ComacodeApp(),
      ),
    );

    // Trigger a frame after ProviderScope is set up
    await tester.pumpAndSettle();

    // Verify that the app title is displayed.
    expect(find.text('Comacode'), findsOneWidget);

    // Verify that "Vibe Coding" text is present (HomePage title + button).
    expect(find.text('Vibe Coding'), findsWidgets);
  });
}

================
File: web/index.html
================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="comacode">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>comacode</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>

================
File: web/manifest.json
================
{
    "name": "comacode",
    "short_name": "comacode",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

================
File: .metadata
================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "3b62efc2a3da49882f43c372e0bc53daef7295a6"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
      base_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
    - platform: web
      create_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
      base_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

================
File: analysis_options.yaml
================
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

================
File: bridge_generated.frb.lsp.yaml
================
# Flutter Rust Bridge Language Server Protocol config
# Enables IDE support for FRB generated code

frb-version: 2.4.0
rust-input: crates/mobile_bridge/src/lib.rs
dart-output: mobile/lib/bridge/
dart-root: mobile/

================
File: frb_config.yaml
================
# Flutter Rust Bridge configuration
# See: https://github.com/fzyzcjy/flutter_rust_bridge

rust_input: crate::api
rust_root: ../crates/mobile_bridge
dart_output: lib/bridge/
dart_root: ./

================
File: pubspec.lock
================
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: da0d9209ca76bde579f2da330aeb9df62b6319c834fa7baae052021b0462401f
      url: "https://pub.dev"
    source: hosted
    version: "85.0.0"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: f4ad0fea5f102201015c9aae9d93bc02f75dd9491529a8c21f88d17a8523d44c
      url: "https://pub.dev"
    source: hosted
    version: "7.6.0"
  analyzer_plugin:
    dependency: transitive
    description:
      name: analyzer_plugin
      sha256: a5ab7590c27b779f3d4de67f31c4109dbe13dd7339f86461a6f2a8ab2594d8ce
      url: "https://pub.dev"
    source: hosted
    version: "0.13.4"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "51dc711996cbf609b90cbe5b335bbce83143875a9d58e4b5c6d3c4f684d3dda7"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  build_cli_annotations:
    dependency: transitive
    description:
      name: build_cli_annotations
      sha256: e563c2e01de8974566a1998410d3f6f03521788160a02503b0b1f1a46c7b3d95
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: "4ae2de3e1e67ea270081eaee972e1bd8f027d459f249e0f1186730784c2e7e33"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  build_daemon:
    dependency: transitive
    description:
      name: build_daemon
      sha256: bf05f6e12cfea92d3c09308d7bcdab1906cd8a179b023269eed00c071004b957
      url: "https://pub.dev"
    source: hosted
    version: "4.1.1"
  build_resolvers:
    dependency: transitive
    description:
      name: build_resolvers
      sha256: ee4257b3f20c0c90e72ed2b57ad637f694ccba48839a821e87db762548c22a62
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  build_runner:
    dependency: "direct dev"
    description:
      name: build_runner
      sha256: "382a4d649addbfb7ba71a3631df0ec6a45d5ab9b098638144faf27f02778eb53"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  build_runner_core:
    dependency: transitive
    description:
      name: build_runner_core
      sha256: "85fbbb1036d576d966332a3f5ce83f2ce66a40bea1a94ad2d5fc29a19a0d3792"
      url: "https://pub.dev"
    source: hosted
    version: "9.1.2"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: "426cf75afdb23aa74bd4e471704de3f9393f3c7b04c1e2d9c6f1073ae0b8b139"
      url: "https://pub.dev"
    source: hosted
    version: "8.12.1"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: "959525d3162f249993882720d52b7e0c833978df229be20702b33d48d91de70f"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.4"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: "6a6cab2ba4680d6423f34a9b972a4c9a94ebe1b62ecec4e1a1f2cba91fd1319d"
      url: "https://pub.dev"
    source: hosted
    version: "4.11.1"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  connectivity_plus:
    dependency: "direct main"
    description:
      name: connectivity_plus
      sha256: b5e72753cf63becce2c61fd04dfe0f1c430cc5278b53a1342dc5ad839eab29ec
      url: "https://pub.dev"
    source: hosted
    version: "6.1.5"
  connectivity_plus_platform_interface:
    dependency: transitive
    description:
      name: connectivity_plus_platform_interface
      sha256: "42657c1715d48b167930d5f34d00222ac100475f73d10162ddf43e714932f204"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: c8ea0233063ba03258fbcf2ca4d6dadfefe14f02fab57702265467a19f27fadf
      url: "https://pub.dev"
    source: hosted
    version: "3.0.7"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  custom_lint_core:
    dependency: transitive
    description:
      name: custom_lint_core
      sha256: "31110af3dde9d29fb10828ca33f1dce24d2798477b167675543ce3d208dee8be"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.5"
  custom_lint_visitor:
    dependency: transitive
    description:
      name: custom_lint_visitor
      sha256: "4a86a0d8415a91fbb8298d6ef03e9034dc8e323a599ddc4120a0e36c433983a2"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0+7.7.0"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "8a0e5fba27e8ee025d2ffb4ee820b4e6e2cf5e4246a6b1a477eb66866947e0bb"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.1"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: "79e0c23480ff85dc68de79e2cd6334add97e48f7f4865d17686dd6ea81a47e8c"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.11"
  equatable:
    dependency: transitive
    description:
      name: equatable
      sha256: "3e0141505477fd8ad55d6eb4e7776d3fe8430be8e497ccb1521370c3f21a3e2b"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.8"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  ffi:
    dependency: "direct main"
    description:
      name: ffi
      sha256: "289279317b4b16eb2bb7e271abccd4bf84ec9bdcbe999e278a94b804f5630418"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_driver:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "5398f14efa795ffb7a33e9b6a08798b26a180edac4ad7db3f231e40f82ce11e1"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  flutter_riverpod:
    dependency: "direct main"
    description:
      name: flutter_riverpod
      sha256: "9532ee6db4a943a1ed8383072a2e3eeda041db5657cdf6d2acecf3c21ecbe7e1"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  flutter_rust_bridge:
    dependency: "direct main"
    description:
      name: flutter_rust_bridge
      sha256: "37ef40bc6f863652e865f0b2563ea07f0d3c58d8efad803cc01933a4b2ee067e"
      url: "https://pub.dev"
    source: hosted
    version: "2.11.1"
  flutter_secure_storage:
    dependency: "direct main"
    description:
      name: flutter_secure_storage
      sha256: "9cad52d75ebc511adfae3d447d5d13da15a55a92c9410e50f67335b6d21d16ea"
      url: "https://pub.dev"
    source: hosted
    version: "9.2.4"
  flutter_secure_storage_linux:
    dependency: transitive
    description:
      name: flutter_secure_storage_linux
      sha256: be76c1d24a97d0b98f8b54bce6b481a380a6590df992d0098f868ad54dc8f688
      url: "https://pub.dev"
    source: hosted
    version: "1.2.3"
  flutter_secure_storage_macos:
    dependency: transitive
    description:
      name: flutter_secure_storage_macos
      sha256: "6c0a2795a2d1de26ae202a0d78527d163f4acbb11cde4c75c670f3a0fc064247"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  flutter_secure_storage_platform_interface:
    dependency: transitive
    description:
      name: flutter_secure_storage_platform_interface
      sha256: cf91ad32ce5adef6fba4d736a542baca9daf3beac4db2d04be350b87f69ac4a8
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  flutter_secure_storage_web:
    dependency: transitive
    description:
      name: flutter_secure_storage_web
      sha256: f4ebff989b4f07b2656fb16b47852c0aab9fed9b4ec1c70103368337bc1886a9
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  flutter_secure_storage_windows:
    dependency: transitive
    description:
      name: flutter_secure_storage_windows
      sha256: b20b07cb5ed4ed74fc567b78a72936203f587eba460af1df11281c9326cd3709
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  freezed_annotation:
    dependency: transitive
    description:
      name: freezed_annotation
      sha256: "7294967ff0a6d98638e7acb774aac3af2550777accd8149c90af5b014e6d44d8"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0"
  frontend_server_client:
    dependency: transitive
    description:
      name: frontend_server_client
      sha256: f64a0333a82f30b0cca061bc3d143813a486dc086b574bfb233b7c1372427694
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  fuchsia_remote_debug_protocol:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  graphs:
    dependency: transitive
    description:
      name: graphs
      sha256: "741bbf84165310a68ff28fe9e727332eef1407342fca52759cb21ad8177bb8d0"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  haptic_feedback:
    dependency: "direct main"
    description:
      name: haptic_feedback
      sha256: ef6df60bd92ac75c87774c3300dd19732f5fbd81734371ea62196c3f55013408
      url: "https://pub.dev"
    source: hosted
    version: "0.4.2"
  http:
    dependency: transitive
    description:
      name: http
      sha256: "87721a4a50b19c7f1d49001e51409bddc46303966ce89a65af4f4e6004896412"
      url: "https://pub.dev"
    source: hosted
    version: "1.6.0"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: aa6199f908078bb1c5efb8d8638d4ae191aac11b311132c3ef48ce352fb52ef8
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  integration_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  io:
    dependency: transitive
    description:
      name: io
      sha256: dfd5a80599cf0165756e3181807ed3e77daf6dd4137caaad72d0b7931597650b
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  js:
    dependency: transitive
    description:
      name: js
      sha256: f2c445dce49627136094980615a031419f7f3eb393237e4ecd97ac15dea343f3
      url: "https://pub.dev"
    source: hosted
    version: "0.6.7"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "33e2e26bdd85a0112ec15400c8cbffea70d0f9c3407491f672a2fad47915e2de"
      url: "https://pub.dev"
    source: hosted
    version: "11.0.2"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "1dbc140bb5a23c75ea9c4811222756104fbcd1a27173f0c34ca01e16bea473c1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.10"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "8d5a2d49f4a66b49744b23b018848400d23e54caf9463f4eb20df3eb8acb2eb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: c35bb79562d980e9a453fc715854e1ed39e24e7d0297a880ef54e17f9874a9d7
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  lucide_icons_flutter:
    dependency: "direct main"
    description:
      name: lucide_icons_flutter
      sha256: d9ee025290a82f39f3e3b54238b87cab07f100cbc8014126df5d51813d428654
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: "23f08335362185a5ea2ad3a4e597f1375e78bce8a040df5c600c8d3552ef2394"
      url: "https://pub.dev"
    source: hosted
    version: "1.17.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  mobile_scanner:
    dependency: "direct main"
    description:
      name: mobile_scanner
      sha256: "1b60b8f9d4ce0cb0e7d7bc223c955d083a0737bee66fa1fcfe5de48225e0d5b3"
      url: "https://pub.dev"
    source: hosted
    version: "3.5.7"
  nm:
    dependency: transitive
    description:
      name: nm
      sha256: "2c9aae4127bdc8993206464fcc063611e0e36e72018696cd9631023a31b24254"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  package_info_plus:
    dependency: transitive
    description:
      name: package_info_plus
      sha256: f69da0d3189a4b4ceaeb1a3defb0f329b3b352517f52bed4290f83d4f06bc08d
      url: "https://pub.dev"
    source: hosted
    version: "9.0.0"
  package_info_plus_platform_interface:
    dependency: transitive
    description:
      name: package_info_plus_platform_interface
      sha256: "202a487f08836a592a6bd4f901ac69b3a8f146af552bbd14407b6b41e1c3f086"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  path_provider:
    dependency: transitive
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: f2c65e21139ce2c3dad46922be8272bb5963516045659e71bb16e151c93b580e
      url: "https://pub.dev"
    source: hosted
    version: "2.2.22"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: "6d13aece7b3f5c5a9731eaf553ff9dcbc2eff41087fd2df587fd0fed9a3eb0c4"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.1"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  pedantic:
    dependency: transitive
    description:
      name: pedantic
      sha256: "67fc27ed9639506c856c840ccce7594d0bdcd91bc8d53d6e52359449a1d50602"
      url: "https://pub.dev"
    source: hosted
    version: "1.11.1"
  permission_handler:
    dependency: "direct main"
    description:
      name: permission_handler
      sha256: "59adad729136f01ea9e35a48f5d1395e25cba6cea552249ddbe9cf950f5d7849"
      url: "https://pub.dev"
    source: hosted
    version: "11.4.0"
  permission_handler_android:
    dependency: transitive
    description:
      name: permission_handler_android
      sha256: d3971dcdd76182a0c198c096b5db2f0884b0d4196723d21a866fc4cdea057ebc
      url: "https://pub.dev"
    source: hosted
    version: "12.1.0"
  permission_handler_apple:
    dependency: transitive
    description:
      name: permission_handler_apple
      sha256: f000131e755c54cf4d84a5d8bd6e4149e262cc31c5a8b1d698de1ac85fa41023
      url: "https://pub.dev"
    source: hosted
    version: "9.4.7"
  permission_handler_html:
    dependency: transitive
    description:
      name: permission_handler_html
      sha256: "38f000e83355abb3392140f6bc3030660cfaef189e1f87824facb76300b4ff24"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3+5"
  permission_handler_platform_interface:
    dependency: transitive
    description:
      name: permission_handler_platform_interface
      sha256: eb99b295153abce5d683cac8c02e22faab63e50679b937fa1bf67d58bb282878
      url: "https://pub.dev"
    source: hosted
    version: "4.3.0"
  permission_handler_windows:
    dependency: transitive
    description:
      name: permission_handler_windows
      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: "1a97266a94f7350d30ae522c0af07890c70b8e62c71e8e3920d1db4d23c057d1"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "978783255c543aa3586a1b3c21f6e9d720eb315376a915872c61ef8b5c20177d"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.2"
  process:
    dependency: transitive
    description:
      name: process
      sha256: c6248e4526673988586e8c00bb22a49210c258dc91df5227d5da9748ecf79744
      url: "https://pub.dev"
    source: hosted
    version: "5.0.5"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: "0560ba233314abbed0a48a2956f7f022cce7c3e1e73df540277da7544cad4082"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  quiver:
    dependency: transitive
    description:
      name: quiver
      sha256: ea0b925899e64ecdfbf9c7becb60d5b50e706ade44a85b2363be2a22d88117d2
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  riverpod:
    dependency: "direct main"
    description:
      name: riverpod
      sha256: "59062512288d3056b2321804332a13ffdd1bf16df70dcc8e506e411280a72959"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  riverpod_analyzer_utils:
    dependency: transitive
    description:
      name: riverpod_analyzer_utils
      sha256: "03a17170088c63aab6c54c44456f5ab78876a1ddb6032ffde1662ddab4959611"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.10"
  riverpod_annotation:
    dependency: "direct main"
    description:
      name: riverpod_annotation
      sha256: e14b0bf45b71326654e2705d462f21b958f987087be850afd60578fcd502d1b8
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  riverpod_generator:
    dependency: "direct dev"
    description:
      name: riverpod_generator
      sha256: "44a0992d54473eb199ede00e2260bd3c262a86560e3c6f6374503d86d0580e36"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.5"
  shared_preferences:
    dependency: "direct main"
    description:
      name: shared_preferences
      sha256: "2939ae520c9024cb197fc20dee269cd8cdbf564c8b5746374ec6cacdc5169e64"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: "83af5c682796c0f7719c2bbf74792d113e40ae97981b8f266fa84574573556bc"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.18"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: "4e7eaffc2b17ba398759f1151415869a34771ba11ebbccd1b0145472a619a64f"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.6"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: c49bd060261c9a3f0ff445892695d6212ff603ef3115edbb448509d407600019
      url: "https://pub.dev"
    source: hosted
    version: "2.4.3"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: e7dd780a7ffb623c57850b33f43309312fc863fb6aa3d276a754bb299839ef12
      url: "https://pub.dev"
    source: hosted
    version: "1.4.2"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: "3632775c8e90d6c9712f883e633716432a27758216dfb61bd86a8321c0580925"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "35c8150ece9e8c8d263337a265153c3329667640850b9304861faea59fc98f6b"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  speech_to_text:
    dependency: "direct main"
    description:
      name: speech_to_text
      sha256: "57fef1d41bdebe298e84842c89bb4ac91f31cdbec7830c8cb1fc6b91d03abd42"
      url: "https://pub.dev"
    source: hosted
    version: "6.6.0"
  speech_to_text_macos:
    dependency: transitive
    description:
      name: speech_to_text_macos
      sha256: e685750f7542fcaa087a5396ee471e727ec648bf681f4da83c84d086322173f6
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  speech_to_text_platform_interface:
    dependency: transitive
    description:
      name: speech_to_text_platform_interface
      sha256: a1935847704e41ee468aad83181ddd2423d0833abe55d769c59afca07adb5114
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  state_notifier:
    dependency: transitive
    description:
      name: state_notifier
      sha256: b8677376aa54f2d7c58280d5a007f9e8774f1968d1fb1c096adcb4792fba29bb
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  stream_transform:
    dependency: transitive
    description:
      name: stream_transform
      sha256: ad47125e588cfd37a9a7f86c7d6356dde8dfe89d071d293f80ca9e9273a33871
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  sync_http:
    dependency: transitive
    description:
      name: sync_http
      sha256: "7f0cd72eca000d2e026bcd6f990b81d0ca06022ef4e32fb257b30d3d1014a961"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: ab2726c1a94d3176a45960b6234466ec367179b87dd74f1611adb1f3b5fb9d55
      url: "https://pub.dev"
    source: hosted
    version: "0.7.7"
  timing:
    dependency: transitive
    description:
      name: timing
      sha256: "62ee18aca144e4a9f29d212f5a4c6a053be252b895ab14b5821996cff4ed90fe"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  uuid:
    dependency: "direct main"
    description:
      name: uuid
      sha256: a11b666489b1954e01d992f3d601b1804a33937b5a8fe677bd26b8a9f96f96e8
      url: "https://pub.dev"
    source: hosted
    version: "4.5.2"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: d530bd74fea330e6e364cda7a85019c434070188383e1cd8d9777ee586914c5b
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://pub.dev"
    source: hosted
    version: "15.0.2"
  wakelock_plus:
    dependency: "direct main"
    description:
      name: wakelock_plus
      sha256: "9296d40c9adbedaba95d1e704f4e0b434be446e2792948d0e4aa977048104228"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  wakelock_plus_platform_interface:
    dependency: transitive
    description:
      name: wakelock_plus_platform_interface
      sha256: "036deb14cd62f558ca3b73006d52ce049fabcdcb2eddfe0bf0fe4e8a943b5cf2"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: f52385d4f73589977c80797e60fe51014f7f2b957b5e9a62c3f6ada439889249
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  web_socket:
    dependency: transitive
    description:
      name: web_socket
      sha256: "34d64019aa8e36bf9842ac014bb5d2f5586ca73df5e4d9bf5c936975cae6982c"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.1"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: d645757fb0f4773d602444000a8131ff5d48c9e47adfe9772652dd1a4f2d45c8
      url: "https://pub.dev"
    source: hosted
    version: "3.0.3"
  webdriver:
    dependency: transitive
    description:
      name: webdriver
      sha256: "2f3a14ca026957870cfd9c635b83507e0e51d8091568e90129fbf805aba7cade"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: d7cb55e04cd34096cd3a79b3330245f54cb96a370a1c27adb3c84b917de8b08e
      url: "https://pub.dev"
    source: hosted
    version: "5.15.0"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: "971043b3a0d3da28727e40ed3e0b5d18b742fa5a68665cca88e74b7876d5e025"
      url: "https://pub.dev"
    source: hosted
    version: "6.6.1"
  xterm:
    dependency: "direct main"
    description:
      name: xterm
      sha256: "168dfedca77cba33fdb6f52e2cd001e9fde216e398e89335c19b524bb22da3a2"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  zmodem:
    dependency: transitive
    description:
      name: zmodem
      sha256: "3b7e5b29f3a7d8aee472029b05165a68438eff2f3f7766edf13daba1e297adbf"
      url: "https://pub.dev"
    source: hosted
    version: "0.0.6"
sdks:
  dart: ">=3.9.0 <4.0.0"
  flutter: ">=3.35.0"

================
File: pubspec.yaml
================
name: comacode
description: "Comacode - Remote terminal control via mobile"
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.9.0

dependencies:
  flutter:
    sdk: flutter

  # UI
  cupertino_icons: ^1.0.8
  lucide_icons_flutter: ^1.2.0

  # FFI Bridge to Rust
  flutter_rust_bridge: ^2.4.0
  ffi: ^2.1.0

  # State Management - Riverpod (Phase 06)
  flutter_riverpod: ^2.4.0
  riverpod: ^2.4.0
  riverpod_annotation: ^2.3.0

  # Terminal UI (Phase 06)
  xterm: ^4.0.0

  # QR Code Scanner
  mobile_scanner: ^3.5.0

  # Secure Storage
  flutter_secure_storage: ^9.0.0

  # Permissions
  permission_handler: ^11.0.0

  # Speech Recognition (Vibe Coding - Phase 02)
  speech_to_text: ^6.6.0

  # Wakelock (keep screen on)
  wakelock_plus: ^1.1.0

  # Haptic Feedback (Vibe Coding - Phase 03)
  haptic_feedback: ^0.4.0

  # Network utilities
  connectivity_plus: ^6.0.5

  # Storage
  shared_preferences: ^2.3.3

  # Utils
  uuid: ^4.5.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  build_runner: ^2.4.13
  riverpod_generator: ^2.3.0
  integration_test:
    sdk: flutter

flutter:
  uses-material-design: true

================
File: cli_client/src/main.rs
================
//! QUIC client for Comacode remote terminal
//! Features: SSH-like raw mode, eager spawn, proper resize

mod message_reader;
mod raw_mode;

use anyhow::Result;
use clap::Parser;
use comacode_core::{AuthToken, MessageCodec, NetworkMessage, TerminalEvent};
use message_reader::MessageReader;
use crossterm::terminal::size;
use quinn::{ClientConfig, Endpoint};
use rustls::client::danger::{HandshakeSignatureValid, ServerCertVerified, ServerCertVerifier};
use rustls::crypto::ring::default_provider;
use rustls::ClientConfig as RustlsClientConfig;
use rustls::DigitallySignedStruct;
use rustls::SignatureScheme;
use std::io::{Read, Write};
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::signal::unix::{signal, SignalKind};
use tokio::sync::mpsc;

// CLI argument parser and TLS verification
#[derive(Parser, Debug)]
struct Args {
    #[arg(short, long, default_value = "127.0.0.1:8443")]
    connect: SocketAddr,
    #[arg(short, long)]
    token: String,
    #[arg(long, default_value_t = false)]
    insecure: bool,
}

#[derive(Debug)]
struct SkipVerification;
impl ServerCertVerifier for SkipVerification {
    fn verify_server_cert(
        &self,
        _end_entity: &rustls::pki_types::CertificateDer<'_>,
        _intermediates: &[rustls::pki_types::CertificateDer<'_>],
        _server_name: &rustls::pki_types::ServerName<'_>,
        _ocsp_response: &[u8],
        _now: rustls::pki_types::UnixTime,
    ) -> Result<ServerCertVerified, rustls::Error> {
        Ok(ServerCertVerified::assertion())
    }
    fn verify_tls12_signature(
        &self,
        _message: &[u8],
        _cert: &rustls::pki_types::CertificateDer<'_>,
        _dss: &DigitallySignedStruct,
    ) -> Result<HandshakeSignatureValid, rustls::Error> {
        Ok(HandshakeSignatureValid::assertion())
    }
    fn verify_tls13_signature(
        &self,
        _message: &[u8],
        _cert: &rustls::pki_types::CertificateDer<'_>,
        _dss: &DigitallySignedStruct,
    ) -> Result<HandshakeSignatureValid, rustls::Error> {
        Ok(HandshakeSignatureValid::assertion())
    }
    fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
        vec![
            SignatureScheme::RSA_PKCS1_SHA1,
            SignatureScheme::ECDSA_SHA1_Legacy,
            SignatureScheme::RSA_PKCS1_SHA256,
            SignatureScheme::ECDSA_NISTP256_SHA256,
            SignatureScheme::RSA_PKCS1_SHA384,
            SignatureScheme::ECDSA_NISTP384_SHA384,
            SignatureScheme::RSA_PKCS1_SHA512,
            SignatureScheme::ECDSA_NISTP521_SHA512,
            SignatureScheme::RSA_PSS_SHA256,
            SignatureScheme::RSA_PSS_SHA384,
            SignatureScheme::RSA_PSS_SHA512,
            SignatureScheme::ED25519,
            SignatureScheme::ED448,
        ]
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    default_provider()
        .install_default()
        .expect("Failed to install crypto provider");
    let args = Args::parse();

    println!("Comacode CLI Client v{}", env!("CARGO_PKG_VERSION"));
    println!("Connecting to {}...", args.connect);
    let token = AuthToken::from_hex(&args.token).map_err(|_| anyhow::anyhow!("Invalid token"))?;
    let mut endpoint = Endpoint::client("0.0.0.0:0".parse()?)?;
    if !args.insecure {
        return Err(anyhow::anyhow!("Use --insecure"));
    }
    let crypto = RustlsClientConfig::builder()
        .dangerous()
        .with_custom_certificate_verifier(Arc::new(SkipVerification))
        .with_no_client_auth();
    let quic_crypto = quinn::crypto::rustls::QuicClientConfig::try_from(crypto).unwrap();
    endpoint.set_default_client_config(ClientConfig::new(Arc::new(quic_crypto)));

    let connecting = endpoint.connect(args.connect, "comacode.local")?;
    let connection = connecting.await?;
    let (mut send, recv) = connection.open_bi().await?;

    // Handshake: Send Hello, read response with proper framing
    let hello = NetworkMessage::hello(Some(token));
    send.write_all(&MessageCodec::encode(&hello)?).await?;
    let mut reader = MessageReader::new(recv);
    let _ = reader.read_message().await?;
    println!("Authenticated");

    // ===== 1. BANNER & RAW MODE =====
    let _ = std::io::stdout().write_all(b"\x1b]0;[COMACODE] Remote Session\x07");

    // Get current time for banner
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let datetime = chrono::DateTime::<chrono::Utc>::from_timestamp(now as i64, 0)
        .unwrap_or_default()
        .format("%Y-%m-%d %H:%M:%S UTC");

    let banner = format!(
        "\r\n\
        \x1b[1;36m\x1b[0m\r\n\
        \x1b[1;36m\x1b[1;33m          COMACODE REMOTE TERMINAL \x1b[1;36m              \x1b[0m\r\n\
        \x1b[1;36m\x1b[0m\r\n\
        \x1b[1;36m\x1b[0m \x1b[90mHost:\x1b[0m     {:<48} \x1b[1;36m\x1b[0m\r\n\
        \x1b[1;36m\x1b[0m \x1b[90mConnected:\x1b[0m {:<44} \x1b[1;36m\x1b[0m\r\n\
        \x1b[1;36m\x1b[0m \x1b[90mExit cmd:\x1b[0m  \x1b[33m/exit\x1b[0m \x1b[90m(disconnects gracefully)\x1b[0m      \x1b[1;36m\x1b[0m\r\n\
        \x1b[1;36m\x1b[0m\r\n\r\n",
        args.connect, datetime
    );
    let _ = std::io::stdout().write_all(banner.as_bytes());
    let _ = std::io::stdout().flush();

    // Enable raw mode for terminal input
    // Fallback: continue without raw mode in non-TTY environments
    let _guard = match raw_mode::RawModeGuard::enable() {
        Ok(guard) => Some(guard),
        Err(e) => {
            eprintln!("Warning: Raw mode not available: {}. Input may be slow.", e);
            None
        }
    };

    // ===== 2. EAGER SPAWN SEQUENCE (SSH-LIKE) =====
    // Send Resize -> Empty Input to spawn session
    if let Ok((cols, rows)) = size() {
        let resize = NetworkMessage::Resize { rows, cols };
        send.write_all(&MessageCodec::encode(&resize)?).await?;
    }

    // Trigger Spawn: Send empty Input to spawn session on server
    let spawn_trigger = NetworkMessage::Input { data: vec![] };
    send.write_all(&MessageCodec::encode(&spawn_trigger)?)
        .await?;

    // ===== 3. INTERACTIVE LOOP =====
    // Spawn stdin task immediately - no need to wait for prompt
    // User input is buffered and sent (type-ahead)

    let (stdin_tx, mut stdin_rx) = mpsc::channel::<Vec<u8>>(32);

    // Track if raw mode is enabled for stdin_task
    let raw_mode_enabled = _guard.is_some();

    // SIGWINCH handler for dynamic terminal resize
    let resize_tx = stdin_tx.clone();
    tokio::spawn(async move {
        match signal(SignalKind::window_change()) {
            Ok(mut stream) => {
                loop {
                    stream.recv().await;
                    if let Ok((cols, rows)) = size() {
                        let resize_msg = NetworkMessage::Resize { rows, cols };
                        if let Ok(encoded) = MessageCodec::encode(&resize_msg) {
                            let _ = resize_tx.send(encoded).await;
                        }
                    }
                }
            }
            Err(_) => {
                // SIGWINCH not available on this platform (e.g., Windows)
            }
        }
    });

    // stdin_task: Passive Observer pattern - send everything for PTY echo, only intercept Enter for /exit
    let mut stdin_task = if raw_mode_enabled {
        // === RAW MODE: byte-by-byte for interactive shell ===
        tokio::task::spawn_blocking(move || {
            let mut stdin = std::io::stdin();
            let mut buf = [0u8; 1024];
            let mut command_buffer = Vec::new(); // Buffer  theo di lnh g

            loop {
                match stdin.read(&mut buf) {
                    Ok(0) => break, // EOF
                    Ok(n) => {
                        let input = &buf[..n];

                        // Duyt tng byte  x l logic "/exit"
                        for &b in input {
                            if b == b'\r' || b == b'\n' {
                                // Khi nhn Enter: Kim tra xem c phi lnh /exit khng
                                let cmd = String::from_utf8_lossy(&command_buffer).trim().to_string();
                                if cmd == "/exit" {
                                    // User  thy "/exit" trn mn hnh (do cc k t trc  gi i)
                                    // KHNG gi phm Enter ny -> Shell khng execute lnh rc
                                    // Gi Close message  disconnect gracefully
                                    let close_msg = NetworkMessage::Close;
                                    if let Ok(encoded) = MessageCodec::encode(&close_msg) {
                                        let _ = stdin_tx.blocking_send(encoded);
                                    }
                                    std::thread::sleep(std::time::Duration::from_millis(100));
                                    return;
                                }

                                // Khng phi lnh exit -> Reset buffer v Gi Enter i
                                command_buffer.clear();
                                let msg = NetworkMessage::Input { data: vec![b] };
                                if let Ok(encoded) = MessageCodec::encode(&msg) {
                                    if stdin_tx.blocking_send(encoded).is_err() { return; }
                                }
                            }
                            else if b == 0x7F || b == 0x08 {
                                // Handle Backspace ( user c th sa lnh /exot -> /exit)
                                command_buffer.pop();
                                // Vn gi Backspace sang PTY  xa trn mn hnh
                                let msg = NetworkMessage::Input { data: vec![b] };
                                if let Ok(encoded) = MessageCodec::encode(&msg) {
                                    if stdin_tx.blocking_send(encoded).is_err() { return; }
                                }
                            }
                            else {
                                // K t thng: Lu vo buffer + Gi i ngay (PTY s echo)
                                command_buffer.push(b);
                                let msg = NetworkMessage::Input { data: vec![b] };
                                if let Ok(encoded) = MessageCodec::encode(&msg) {
                                    if stdin_tx.blocking_send(encoded).is_err() { return; }
                                }
                            }
                        }
                    }
                    Err(_) => break,
                }
            }
        })
    } else {
        // === LINE-BUFFERED: for piped input / non-TTY ===
        tokio::task::spawn_blocking(move || {
            use std::io::BufRead;

            let stdin = std::io::stdin();
            let reader = stdin.lock();
            let mut lines = reader.lines();

            loop {
                match lines.next() {
                    None => break,
                    Some(Ok(line)) => {
                        if line.trim() == "/exit" {
                            std::thread::sleep(std::time::Duration::from_secs(2));
                            break;
                        }
                        let full_line = format!("{}\n", line);
                        let msg = NetworkMessage::Input {
                            data: full_line.into_bytes(),
                        };
                        if let Ok(encoded) = MessageCodec::encode(&msg) {
                            if stdin_tx.blocking_send(encoded).is_err() {
                                break;
                            }
                        }
                    }
                    Some(Err(_)) => break,
                }
            }
        })
    };

    let mut stdin_eof = false;

    loop {
        tokio::select! {
            _ = &mut stdin_task => { stdin_eof = true; }
            Some(encoded) = stdin_rx.recv() => {
                if send.write_all(&encoded).await.is_err() { break; }
            }
            // Use MessageReader for proper framing
            result = reader.read_message() => {
                match result {
                    Ok(msg) => {
                        match msg {
                            NetworkMessage::Event(TerminalEvent::Output { data }) => {
                                let mut stdout = std::io::stdout();
                                let _ = stdout.write_all(&data);
                                let _ = stdout.flush();
                            }
                            NetworkMessage::Close => break,
                            _ => {}
                        }
                    }
                    Err(_) => break,
                }
            }
        }
        if stdin_eof && stdin_rx.is_empty() {
            // Give server time to send final responses (command output, etc.)
            // Commands can take time to execute
            tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
            if stdin_rx.is_empty() {
                break;
            }
        }
    }

    stdin_task.abort();

    // Reset Terminal
    let _ = std::io::stdout().write_all(b"\x1b]0;\x07\x1b[!p\x1bc\r\nConnection closed.\r\n");
    let _ = std::io::stdout().flush();
    let _ = send
        .write_all(&MessageCodec::encode(&NetworkMessage::Close)?)
        .await;

    Ok(())
}

================
File: cli_client/src/message_reader.rs
================
//! Message reader for length-prefixed QUIC messages
//!
//! Wraps framing logic to read complete messages from QUIC stream.
//! Protocol format: [4-byte big-endian length][N-byte payload]
//!
//! Note: MessageCodec::decode() expects the full buffer including length prefix.

use anyhow::Result;
use comacode_core::{MessageCodec, NetworkMessage};
use quinn::RecvStream;

/// Helper for reading length-prefixed messages from QUIC stream
pub struct MessageReader {
    recv: RecvStream,
}

impl MessageReader {
    /// Create new MessageReader from QUIC RecvStream
    pub fn new(recv: RecvStream) -> Self {
        Self { recv }
    }

    /// Read next complete message from stream
    /// Blocks until full message received
    pub async fn read_message(&mut self) -> Result<NetworkMessage> {
        // Read 4-byte length prefix
        let mut len_buf = [0u8; 4];
        self.recv.read_exact(&mut len_buf).await
            .map_err(|_| anyhow::anyhow!("Stream closed while reading length"))?;

        let len = u32::from_be_bytes(len_buf) as usize;

        // Validate size (prevent DoS)
        if len > 16 * 1024 * 1024 {
            return Err(anyhow::anyhow!("Message too large: {} bytes", len));
        }

        // Read payload
        let mut payload = vec![0u8; len];
        self.recv.read_exact(&mut payload).await
            .map_err(|_| anyhow::anyhow!("Stream closed while reading payload"))?;

        // Reconstruct full buffer: [length prefix][payload]
        // MessageCodec::decode() expects the complete format
        let mut full_buffer = Vec::with_capacity(4 + len);
        full_buffer.extend_from_slice(&len_buf);
        full_buffer.extend_from_slice(&payload);

        // Decode message from full buffer
        MessageCodec::decode(&full_buffer)
            .map_err(|e| anyhow::anyhow!("Decode failed: {}", e))
    }
}

================
File: cli_client/src/raw_mode.rs
================
//! Raw mode terminal wrapper for crossterm
//!
//! Ensures terminal is restored to normal mode on drop (even on panic).

use crossterm::terminal;
use anyhow::Result;

/// Guard that enables raw mode and restores normal mode on drop.
///
/// # Example
/// ```no_run
/// let _guard = RawModeGuard::enable()?;
/// // Terminal is now in raw mode
/// // ... do work ...
/// // Raw mode automatically disabled when guard is dropped
/// # Ok::<(), anyhow::Error>(())
/// ```
pub struct RawModeGuard;

impl RawModeGuard {
    /// Enable raw mode for the terminal.
    ///
    /// Raw mode disables:
    /// - Line buffering (input available immediately)
    /// - Local echo (characters not echoed locally)
    /// - Signal generation (Ctrl+C passed as 0x03 byte)
    ///
    /// The terminal is automatically restored when the guard is dropped.
    pub fn enable() -> Result<Self> {
        terminal::enable_raw_mode()?;
        Ok(Self)
    }
}

impl Drop for RawModeGuard {
    fn drop(&mut self) {
        // Best-effort restore - ignore errors during cleanup
        let _ = terminal::disable_raw_mode();
    }
}

================
File: cli_client/Cargo.toml
================
[package]
name = "cli_client"
version.workspace = true
edition.workspace = true

[[bin]]
name = "cli_client"
path = "src/main.rs"

[dependencies]
comacode-core = { path = "../core" }
anyhow = { workspace = true }
clap = { version = "4.5", features = ["derive"] }
tokio = { workspace = true }
quinn = { workspace = true }
rustls = { workspace = true }
crossterm = "0.28"
chrono = "0.4"

================
File: core/src/protocol/codec.rs
================
//! Postcard serialization codec for network messages

use crate::error::{CoreError, Result};
use crate::types::NetworkMessage;
use postcard::{from_bytes, to_allocvec};

/// Maximum message size (16MB)
const MAX_MESSAGE_SIZE: usize = 16 * 1024 * 1024;

/// Message codec for serialization/deserialization
pub struct MessageCodec;

impl MessageCodec {
    /// Encode network message to bytes
    ///
    /// Returns Vec<u8> with length-prefixed format:
    /// [4 bytes length (big endian)] [message payload]
    pub fn encode(msg: &NetworkMessage) -> Result<Vec<u8>> {
        let payload = to_allocvec(msg).map_err(CoreError::from)?;

        // Limit message size
        if payload.len() > MAX_MESSAGE_SIZE {
            return Err(CoreError::MessageTooLarge {
                size: payload.len(),
                max: MAX_MESSAGE_SIZE,
            });
        }

        // Add length prefix (4 bytes, big endian)
        let len = payload.len() as u32;
        let mut buf = Vec::with_capacity(4 + payload.len());
        buf.extend_from_slice(&len.to_be_bytes());
        buf.extend_from_slice(&payload);

        Ok(buf)
    }

    /// Decode network message from bytes
    ///
    /// Expects length-prefixed format
    pub fn decode(buf: &[u8]) -> Result<NetworkMessage> {
        if buf.len() < 4 {
            return Err(CoreError::InvalidMessageFormat(
                "Buffer too small for length prefix".into(),
            ));
        }

        // Read length prefix
        let len = u32::from_be_bytes([buf[0], buf[1], buf[2], buf[3]]) as usize;

        // Validate length
        if len > MAX_MESSAGE_SIZE {
            return Err(CoreError::MessageTooLarge {
                size: len,
                max: MAX_MESSAGE_SIZE,
            });
        }

        if buf.len() < 4 + len {
            return Err(CoreError::InvalidMessageFormat(
                "Buffer too small for payload".into(),
            ));
        }

        // Deserialize payload
        let payload = &buf[4..4 + len];
        from_bytes(payload).map_err(CoreError::from)
    }

    /// Decode slice into multiple messages (streaming)
    pub fn decode_stream(buf: &[u8]) -> Result<Vec<NetworkMessage>> {
        let mut messages = Vec::new();
        let mut offset = 0;

        while offset < buf.len() {
            if offset + 4 > buf.len() {
                break; // Incomplete message
            }

            let len = u32::from_be_bytes([
                buf[offset],
                buf[offset + 1],
                buf[offset + 2],
                buf[offset + 3],
            ]) as usize;

            if offset + 4 + len > buf.len() {
                break; // Incomplete message
            }

            let msg_buf = &buf[offset + 4..offset + 4 + len];
            let msg = from_bytes(msg_buf).map_err(CoreError::from)?;
            messages.push(msg);

            offset += 4 + len;
        }

        Ok(messages)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::TerminalCommand;

    #[test]
    fn test_encode_decode_roundtrip() {
        let msg = NetworkMessage::Close;
        let encoded = MessageCodec::encode(&msg).unwrap();
        let decoded = MessageCodec::decode(&encoded).unwrap();
        assert_eq!(msg, decoded);
    }

    #[test]
    fn test_command_message() {
        let cmd = TerminalCommand::new("echo hello".to_string());
        let msg = NetworkMessage::Command(cmd);
        let encoded = MessageCodec::encode(&msg).unwrap();
        let decoded = MessageCodec::decode(&encoded).unwrap();
        assert_eq!(msg, decoded);
    }

    #[test]
    fn test_ping_pong() {
        let ping = NetworkMessage::ping();
        let encoded = MessageCodec::encode(&ping).unwrap();
        let decoded = MessageCodec::decode(&encoded).unwrap();
        assert!(matches!(decoded, NetworkMessage::Ping { .. }));
    }

    #[test]
    fn test_stream_decode() {
        let msg1 = NetworkMessage::Close;
        let msg2 = NetworkMessage::ping();

        let enc1 = MessageCodec::encode(&msg1).unwrap();
        let enc2 = MessageCodec::encode(&msg2).unwrap();

        let mut stream = Vec::new();
        stream.extend_from_slice(&enc1);
        stream.extend_from_slice(&enc2);

        let messages = MessageCodec::decode_stream(&stream).unwrap();
        assert_eq!(messages.len(), 2);
        assert_eq!(messages[0], msg1);
        assert!(matches!(messages[1], NetworkMessage::Ping { .. }));
    }

    #[test]
    fn test_invalid_buffer() {
        let result = MessageCodec::decode(&[1, 2, 3]);
        assert!(result.is_err());
    }
}

================
File: core/src/protocol/mod.rs
================
//! Network protocol handling

mod codec;

pub use codec::MessageCodec;

================
File: core/src/terminal/mod.rs
================
//! Terminal abstraction

mod traits;

pub use traits::{Terminal, TerminalConfig, MockTerminal};

================
File: core/src/terminal/traits.rs
================
//! Terminal abstraction trait

use crate::error::{CoreError, Result};
use crate::types::TerminalEvent;
use async_trait::async_trait;

/// Terminal abstraction for PTY operations
#[async_trait]
pub trait Terminal: Send + Sync {
    /// Write data to terminal input
    async fn write(&mut self, data: &[u8]) -> Result<()>;

    /// Read output events from terminal
    async fn read(&mut self) -> Result<TerminalEvent>;

    /// Resize terminal
    fn resize(&mut self, rows: u16, cols: u16) -> Result<()>;

    /// Close/kill terminal process
    async fn kill(&mut self) -> Result<()>;

    /// Get current size
    fn size(&self) -> Result<(u16, u16)>;

    /// Get current terminal state for snapshot
    /// Returns (raw bytes, rows, cols) for maximum compatibility
    fn get_snapshot(&self) -> Result<(Vec<u8>, u16, u16)>;
}

/// Terminal configuration
#[derive(Debug, Clone)]
pub struct TerminalConfig {
    /// Initial rows
    pub rows: u16,

    /// Initial columns
    pub cols: u16,

    /// Shell command to run
    pub shell: String,

    /// Environment variables
    pub env: Vec<(String, String)>,
}

impl Default for TerminalConfig {
    fn default() -> Self {
        // FIX: Get system locale instead of hardcoding en_US.UTF-8
        // Fallback chain: LANG  LC_ALL  C.UTF-8  en_US.UTF-8
        let locale = std::env::var("LANG")
            .or_else(|_| std::env::var("LC_ALL"))
            .unwrap_or_else(|_| {
                // Try common UTF-8 locales
                if std::path::Path::new("/usr/share/locale/C.UTF-8").exists() {
                    "C.UTF-8".to_string()
                } else {
                    "en_US.UTF-8".to_string()
                }
            });
        
        Self {
            rows: 24,
            cols: 80,
            shell: Self::default_shell(),
            env: vec![
                ("TERM".to_string(), "xterm-256color".to_string()),
                // Use system locale for proper UTF-8 support (Vietnamese, emoji, etc.)
                ("LANG".to_string(), locale.clone()),
                ("LC_ALL".to_string(), locale),
            ],
        }
    }
}

impl TerminalConfig {
    #[cfg(unix)]
    fn default_shell() -> String {
        std::env::var("SHELL").unwrap_or_else(|_| "/bin/bash".to_string())
    }

    #[cfg(windows)]
    fn default_shell() -> String {
        std::env::var("COMSPEC").unwrap_or_else(|_| "cmd.exe".to_string())
    }

    /// Create with custom size
    pub fn with_size(rows: u16, cols: u16) -> Self {
        Self {
            rows,
            cols,
            ..Default::default()
        }
    }

    /// Set custom shell
    pub fn with_shell(mut self, shell: String) -> Self {
        self.shell = shell;
        self
    }

    /// Add configuration variable
    pub fn with_env(mut self, key: String, value: String) -> Self {
        self.env.push((key, value));
        self
    }
}

/// Mock terminal for testing
pub struct MockTerminal {
    config: TerminalConfig,
    alive: bool,
    snapshot_data: Vec<u8>,
}

impl MockTerminal {
    /// Create new mock terminal
    pub fn new(config: TerminalConfig) -> Self {
        Self {
            config,
            alive: true,
            snapshot_data: Vec::new(),
        }
    }

    /// Set snapshot data for testing
    pub fn set_snapshot_data(&mut self, data: Vec<u8>) {
        self.snapshot_data = data;
    }
}

#[async_trait]
impl Terminal for MockTerminal {
    async fn write(&mut self, _data: &[u8]) -> Result<()> {
        if !self.alive {
            return Err(CoreError::Terminal("Terminal is dead".into()));
        }
        Ok(())
    }

    async fn read(&mut self) -> Result<TerminalEvent> {
        if !self.alive {
            return Err(CoreError::Terminal("Terminal is dead".into()));
        }
        Ok(TerminalEvent::output(b"".to_vec()))
    }

    fn resize(&mut self, rows: u16, cols: u16) -> Result<()> {
        if !self.alive {
            return Err(CoreError::Terminal("Terminal is dead".into()));
        }
        self.config.rows = rows;
        self.config.cols = cols;
        Ok(())
    }

    async fn kill(&mut self) -> Result<()> {
        self.alive = false;
        Ok(())
    }

    fn size(&self) -> Result<(u16, u16)> {
        Ok((self.config.rows, self.config.cols))
    }

    fn get_snapshot(&self) -> Result<(Vec<u8>, u16, u16)> {
        if !self.alive {
            return Err(CoreError::Terminal("Terminal is dead".into()));
        }
        Ok((
            self.snapshot_data.clone(),
            self.config.rows,
            self.config.cols,
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_mock_terminal() {
        let mut term = MockTerminal::new(TerminalConfig::default());
        assert_eq!(term.size().unwrap(), (24, 80));
        term.resize(40, 120).unwrap();
        assert_eq!(term.size().unwrap(), (40, 120));
        term.write(b"test").await.unwrap();
        term.kill().await.unwrap();
    }

    #[tokio::test]
    async fn test_dead_terminal() {
        let mut term = MockTerminal::new(TerminalConfig::default());
        term.kill().await.unwrap();
        let result = term.write(b"test").await;
        assert!(result.is_err());
    }

    #[test]
    fn test_terminal_config() {
        let config = TerminalConfig::with_size(40, 120)
            .with_shell("/bin/zsh".to_string())
            .with_env("TEST".to_string(), "value".to_string());
        assert_eq!(config.rows, 40);
        assert_eq!(config.cols, 120);
        assert_eq!(config.shell, "/bin/zsh");
        // Default env has TERM, LANG, LC_ALL (3 vars) + 1 added = 4
        assert_eq!(config.env.len(), 4);
    }

    #[tokio::test]
    async fn test_get_snapshot() {
        let mut term = MockTerminal::new(TerminalConfig::default());
        let test_data = b"Terminal snapshot data".to_vec();
        term.set_snapshot_data(test_data.clone());
        let (data, rows, cols) = term.get_snapshot().unwrap();
        assert_eq!(data, test_data);
        assert_eq!(rows, 24);
        assert_eq!(cols, 80);
    }

    #[tokio::test]
    async fn test_get_snapshot_dead_terminal() {
        let mut term = MockTerminal::new(TerminalConfig::default());
        term.kill().await.unwrap();
        let result = term.get_snapshot();
        assert!(result.is_err());
    }
}

================
File: core/src/transport/heartbeat.rs
================
//! Heartbeat and timeout detection for QUIC connections
//!
//! This module provides periodic ping/pong for connection health monitoring
//! and automatic timeout detection.

use quinn::SendStream;
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::Duration;
use tokio::time::{interval, Instant};

use crate::protocol::MessageCodec;
use crate::types::NetworkMessage;
use crate::{CoreError, Result};

/// Heartbeat manager for connection health monitoring
///
/// Tracks last activity time and spawns a task to send periodic pings.
/// Uses simple timestamp-based timeout detection.
pub struct Heartbeat {
    last_activity: Arc<AtomicU64>,
    timeout: Duration,
}

impl Heartbeat {
    /// Create new heartbeat monitor
    ///
    /// # Arguments
    /// * `timeout` - Maximum idle time before considering connection dead
    pub fn new(timeout: Duration) -> Self {
        Self {
            last_activity: Arc::new(AtomicU64::new(
                Instant::now().elapsed().as_secs()
            )),
            timeout,
        }
    }

    /// Spawn heartbeat task
    ///
    /// This task:
    /// 1. Ticks every `interval`
    /// 2. Checks if idle time exceeds `timeout`
    /// 3. Sends ping if still alive
    ///
    /// # Arguments
    /// * `send` - QUIC send stream for pings
    /// * `interval` - Time between pings (e.g., 5s)
    /// * `timeout` - Maximum idle time before error
    /// * `last_activity` - Shared atomic with timestamp of last activity
    ///
    /// # Returns
    /// JoinHandle that resolves when timeout occurs or task fails
    pub fn spawn(
        mut send: SendStream,
        interval: Duration,
        timeout: Duration,
        last_activity: Arc<AtomicU64>,
    ) -> tokio::task::JoinHandle<std::result::Result<(), CoreError>> {
        tokio::spawn(async move {
            let mut ticker = interval(interval);

            loop {
                ticker.tick().await;

                //  CORRECT LOGIC: Compare current timestamp with last activity timestamp
                // Both are seconds since app start - simple subtraction works
                let current_secs = Instant::now().elapsed().as_secs();
                let last_secs = last_activity.load(Ordering::Relaxed);

                // Calculate time since last activity
                let idle_secs = current_secs.saturating_sub(last_secs);

                if idle_secs > timeout.as_secs() {
                    tracing::error!("Heartbeat timeout! Last activity was {}s ago", idle_secs);
                    return Err(CoreError::Timeout(idle_secs * 1000));
                }

                // Send ping
                let msg = NetworkMessage::ping();
                match MessageCodec::encode(&msg) {
                    Ok(encoded) => {
                        if let Err(e) = send.write_all(&encoded).await {
                            tracing::error!("Failed to send ping: {}", e);
                            return Err(CoreError::Connection(e.to_string()));
                        }
                        tracing::debug!("Heartbeat sent, idle time: {}s", idle_secs);
                    }
                    Err(e) => {
                        tracing::error!("Failed to encode ping: {}", e);
                        return Err(e);
                    }
                }
            }
        })
    }

    /// Record activity (update last activity timestamp)
    ///
    /// Call this when receiving any data from the connection.
    pub fn record_activity(&self) {
        self.last_activity.store(
            Instant::now().elapsed().as_secs(),
            Ordering::Relaxed
        );
    }

    /// Get shared Arc for passing to spawn()
    pub fn shared_activity(&self) -> Arc<AtomicU64> {
        self.last_activity.clone()
    }

    /// Get current idle time in seconds
    pub fn idle_secs(&self) -> u64 {
        let current_secs = Instant::now().elapsed().as_secs();
        let last_secs = self.last_activity.load(Ordering::Relaxed);
        current_secs.saturating_sub(last_secs)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_heartbeat_new_creates_valid_state() {
        let timeout = Duration::from_secs(30);
        let heartbeat = Heartbeat::new(timeout);
        assert_eq!(heartbeat.timeout, timeout);
        assert_eq!(heartbeat.idle_secs(), 0);
    }

    #[test]
    fn test_record_activity_updates_timestamp() {
        let heartbeat = Heartbeat::new(Duration::from_secs(30));

        // Initially idle time should be ~0
        let initial_idle = heartbeat.idle_secs();
        assert!(initial_idle < 2);

        // Record activity
        heartbeat.record_activity();

        // Idle time should reset to ~0
        let new_idle = heartbeat.idle_secs();
        assert!(new_idle < 2);
    }

    #[test]
    fn test_shared_activity_returns_cloned_arc() {
        let heartbeat = Heartbeat::new(Duration::from_secs(30));
        let shared = heartbeat.shared_activity();

        // Both should point to same value
        heartbeat.record_activity();
        let secs1 = heartbeat.last_activity.load(Ordering::Relaxed);
        let secs2 = shared.load(Ordering::Relaxed);
        assert_eq!(secs1, secs2);
    }
}

================
File: core/src/transport/mod.rs
================
//! QUIC transport configuration helpers
//!
//! This module provides QUIC client/server configuration with proper settings:
//! - Appropriate timeouts for mobile scenarios
//! - Keep-alive for NAT traversal
//! - Flow control settings

pub mod stream;

pub use stream::{BufferConfig, pump_pty_to_quic, pump_pty_to_quic_smart, pump_pty_to_quic_tagged};

use quinn::{ClientConfig, ServerConfig, TransportConfig};
use std::sync::Arc;
use std::time::Duration;

use crate::{CoreError, Result};

/// Configure QUIC client with proper settings for mobile use
///
/// # Features
/// - 30s idle timeout (elevator/tunnel scenarios)
/// - 5s keep-alive interval (NAT traversal)
pub fn configure_client(crypto_config: Arc<quinn::crypto::rustls::QuicClientConfig>) -> ClientConfig {
    let mut transport = TransportConfig::default();

    // Timeout 30s for elevator/tunnel scenarios
    // Mobile devices frequently lose signal briefly
    transport.max_idle_timeout(
        Some(Duration::from_secs(30).try_into().unwrap())
    );

    // Keep-alive interval (5s) to prevent NAT timeout
    // Most NAT devices timeout connections after 30-60s of inactivity
    transport.keep_alive_interval(Some(Duration::from_secs(5)));

    let mut config = ClientConfig::new(crypto_config);
    config.transport_config(Arc::new(transport));
    config
}

/// Configure QUIC server with proper settings
///
/// # Features
/// - 30s idle timeout (matches client)
/// - 5s keep-alive interval (matches client)
pub fn configure_server(cert: Vec<rustls::pki_types::CertificateDer<'static>>, key: rustls::pki_types::PrivateKeyDer<'static>) -> Result<ServerConfig> {
    let mut transport = TransportConfig::default();

    // Match client timeout settings
    transport.max_idle_timeout(
        Some(Duration::from_secs(30).try_into().unwrap())
    );

    // Keep-alive to detect dead clients
    transport.keep_alive_interval(Some(Duration::from_secs(5)));

    let mut config = ServerConfig::with_single_cert(cert, key)
        .map_err(|e| CoreError::Protocol(format!("Failed to configure TLS: {}", e)))?;

    config.transport_config(Arc::new(transport));
    Ok(config)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_configure_client_creates_valid_config() {
        // Note: Cannot easily test without actual crypto config
        // The function itself is tested via integration tests
    }

    #[test]
    fn test_configure_server_creates_valid_config() {
        // Generate a self-signed cert for testing
        let cert = rcgen::generate_simple_self_signed(["localhost".to_string()]).unwrap();
        let cert_der = rustls::pki_types::CertificateDer::from(cert.cert);
        let key_der = rustls::pki_types::PrivateKeyDer::Pkcs8(
            rustls::pki_types::PrivatePkcs8KeyDer::from(cert.key_pair.serialize_der())
        );

        let config = configure_server(vec![cert_der], key_der);
        assert!(config.is_ok());
    }
}

================
File: core/src/transport/reconnect.rs
================
//! Reconnection logic with exponential backoff
//!
//! This module provides automatic reconnection with exponential backoff
//! for handling temporary network failures.

use quinn::{Endpoint, Connection};
use std::time::Duration;
use tokio::time::sleep;

use crate::{CoreError, Result};

/// Reconnection configuration
#[derive(Debug, Clone)]
pub struct ReconnectConfig {
    /// Maximum backoff time between attempts
    pub max_backoff: Duration,
    /// Initial backoff time
    pub initial_backoff: Duration,
    /// Maximum number of reconnection attempts (None = infinite)
    pub max_attempts: Option<usize>,
}

impl Default for ReconnectConfig {
    fn default() -> Self {
        Self {
            max_backoff: Duration::from_secs(30),
            initial_backoff: Duration::from_secs(1),
            max_attempts: Some(10),
        }
    }
}

/// Attempt reconnection with exponential backoff
///
/// # Arguments
/// * `endpoint` - QUIC endpoint to use for connection
/// * `host` - Target hostname or IP (used as both address and SNI server name)
/// * `port` - Target port
/// * `config` - Reconnection configuration
///
/// # Behavior
/// 1. Try to connect immediately
/// 2. On failure, wait with exponential backoff (1s, 2s, 4s, ..., max 30s)
/// 3. Retry up to max_attempts (or forever if None)
/// 4. Return connection on success
///
/// # Returns
/// * `Ok(Connection)` - Successfully reconnected
/// * `Err(CoreError::MaxReconnectAttemptsReached)` - Exceeded max attempts
/// * `Err(...)` - Other error
pub async fn reconnect_with_backoff(
    endpoint: &Endpoint,
    host: &str,
    port: u16,
    config: ReconnectConfig,
) -> Result<Connection> {
    let mut backoff = config.initial_backoff;
    let mut attempt = 0;

    loop {
        attempt += 1;

        // Validate host is not empty
        if host.is_empty() {
            return Err(CoreError::Connection("Host cannot be empty".to_string()));
        }

        // Try to connect
        let addr = format!("{}:{}", host, port)
            .parse::<std::net::SocketAddr>()
            .map_err(|e| CoreError::Connection(format!("Invalid address: {}", e)))?;

        let connecting = endpoint.connect(addr, host)
            .map_err(|e| CoreError::Connection(format!("Failed to initiate connection: {}", e)))?;

        match connecting.await {
            Ok(conn) => {
                tracing::info!("Reconnected after {} attempts", attempt);
                return Ok(conn);
            }
            Err(e) => {
                // Check if we've exceeded max attempts
                if let Some(max) = config.max_attempts {
                    if attempt >= max {
                        tracing::error!("Max reconnection attempts ({}) reached", max);
                        return Err(CoreError::Connection(format!(
                            "Max reconnection attempts ({}) reached. Last error: {}",
                            max, e
                        )));
                    }
                }

                tracing::warn!("Reconnect attempt {} failed: {}, retrying in {:?}",
                    attempt, e, backoff);

                // Wait before retrying (exponential backoff)
                sleep(backoff).await;

                // Exponential backoff: double the backoff, capped at max_backoff
                backoff = std::cmp::min(backoff * 2, config.max_backoff);
            }
        }
    }
}

/// Create reconnect config with custom values
pub fn reconnect_config(
    max_backoff: Duration,
    initial_backoff: Duration,
    max_attempts: Option<usize>,
) -> ReconnectConfig {
    ReconnectConfig {
        max_backoff,
        initial_backoff,
        max_attempts,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reconnect_config_default() {
        let config = ReconnectConfig::default();
        assert_eq!(config.max_backoff, Duration::from_secs(30));
        assert_eq!(config.initial_backoff, Duration::from_secs(1));
        assert_eq!(config.max_attempts, Some(10));
    }

    #[test]
    fn test_reconnect_config_custom() {
        let config = reconnect_config(
            Duration::from_secs(60),
            Duration::from_secs(2),
            Some(5),
        );
        assert_eq!(config.max_backoff, Duration::from_secs(60));
        assert_eq!(config.initial_backoff, Duration::from_secs(2));
        assert_eq!(config.max_attempts, Some(5));
    }

    #[test]
    fn test_reconnect_config_infinite_attempts() {
        let config = reconnect_config(
            Duration::from_secs(30),
            Duration::from_secs(1),
            None,
        );
        assert_eq!(config.max_attempts, None);
    }
}

================
File: core/src/transport/stream.rs
================
//! QUIC stream pumps for terminal I/O
//!
//! This module provides bidirectional data pumping between PTY and QUIC streams.
//! It uses Quinn's built-in flow control for natural backpressure.

use quinn::{RecvStream, SendStream};
use std::sync::Arc;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::sync::Mutex;

use crate::protocol::MessageCodec;
use crate::types::{NetworkMessage, TerminalEvent, TaggedOutput};
use crate::{CoreError, Result};

/// Smart buffering configuration for PTYQUIC streaming
///
/// Balances latency (interactive typing) vs throughput (bulk output).
#[derive(Debug, Clone, Copy)]
pub struct BufferConfig {
    /// Maximum batch size before forcing flush
    pub max_batch_size: usize,

    /// Maximum time to wait before flushing (milliseconds)
    pub max_flush_delay_ms: u64,

    /// Flush immediately on newline (for interactive mode)
    pub flush_on_newline: bool,
}

impl Default for BufferConfig {
    fn default() -> Self {
        Self {
            max_batch_size: 16 * 1024,  // 16KB
            max_flush_delay_ms: 10,     // 10ms
            flush_on_newline: true,     // Interactive-friendly
        }
    }
}

impl BufferConfig {
    /// Interactive mode: low latency, small batches
    /// Best for: shell interaction, command typing
    pub fn interactive() -> Self {
        Self {
            max_batch_size: 4 * 1024,   // 4KB
            max_flush_delay_ms: 5,      // 5ms
            flush_on_newline: true,
        }
    }

    /// Bulk mode: high throughput, large batches
    /// Best for: cat large files, logs, install scripts
    pub fn bulk() -> Self {
        Self {
            max_batch_size: 64 * 1024,  // 64KB
            max_flush_delay_ms: 50,     // 50ms
            flush_on_newline: false,
        }
    }
}

/// Pump data from PTY to QUIC stream
///
/// This is the CRITICAL function for terminal I/O.
/// Quinn's write_all() automatically handles backpressure:
/// - When network is slow, write_all() awaits
/// - Loop stops  no more PTY reads  natural backpressure
///
/// # Arguments
/// * `pty` - Async reader from PTY
/// * `send` - QUIC send stream (mutable reference for shared use)
///
/// # Behavior
/// 1. Read from PTY in 8KB chunks
/// 2. Encode as NetworkMessage::Event
/// 3. Send via QUIC (with automatic flow control)
pub async fn pump_pty_to_quic<R>(
    mut pty: R,
    send: &mut SendStream,
) -> Result<()>
where
    R: AsyncReadExt + Unpin + Send,
{
    let mut buf = vec![0u8; 8192];

    loop {
        let n = pty.read(&mut buf).await?;
        if n == 0 {
            tracing::debug!("PTY EOF, closing stream");
            break;
        }

        // Encode as NetworkMessage FIRST (do NOT send raw bytes!)
        // MessageCodec already handles length prefixing
        let msg = NetworkMessage::Event(TerminalEvent::Output {
            data: buf[..n].to_vec()
        });
        let encoded = MessageCodec::encode(&msg)?;

        // Send ONCE - Quinn handles flow control automatically
        send.write_all(&encoded).await?;

        tracing::trace!("Sent {} bytes from PTY to QUIC", n);
    }

    // Finish the stream gracefully
    let _ = send.finish();
    Ok(())
}

/// Pump data from PTY to QUIC stream with smart buffering
///
/// Optimizes throughput vs latency trade-off by batching small reads.
/// Uses tokio::select! to avoid blocking on read when timeout expires.
///
/// Flush conditions:
/// - Size threshold reached (max_batch_size)
/// - Newline detected (if flush_on_newline=true)
/// - Timeout exceeded (max_flush_delay_ms) - CRITICAL: checked via select!
///
/// # Arguments
/// * `pty` - Async reader from PTY
/// * `send` - QUIC send stream
/// * `config` - Buffering strategy
pub async fn pump_pty_to_quic_smart<R>(
    mut pty: R,
    send: &mut SendStream,
    config: BufferConfig,
) -> Result<()>
where
    R: AsyncReadExt + Unpin + Send,
{
    let mut read_buf = vec![0u8; 8192];
    let mut batch_buf = Vec::with_capacity(config.max_batch_size);

    loop {
        // Calculate timeout: only flush if we have buffered data
        let flush_timeout = if !batch_buf.is_empty() {
            std::time::Duration::from_millis(config.max_flush_delay_ms)
        } else {
            // No data buffered, wait indefinitely for new data
            std::time::Duration::from_secs(3600)
        };

        tokio::select! {
            // Case 1: PTY has data
            result = pty.read(&mut read_buf) => {
                let n = result?;
                if n == 0 {
                    // EOF - flush remaining and exit
                    if !batch_buf.is_empty() {
                        send_batch(&batch_buf, send).await?;
                    }
                    break;
                }

                // Check for newline in this chunk
                let chunk_has_newline = read_buf[..n].contains(&b'\n');

                // Accumulate data
                if batch_buf.len() + n <= config.max_batch_size {
                    batch_buf.extend_from_slice(&read_buf[..n]);
                } else {
                    // Batch full - send current, start new
                    if !batch_buf.is_empty() {
                        send_batch(&batch_buf, send).await?;
                    }
                    batch_buf = read_buf[..n].to_vec();
                }

                // Immediate flush conditions (no waiting)
                let should_flush = if config.flush_on_newline && chunk_has_newline {
                    true  // Interactive mode - flush on newline
                } else if batch_buf.len() >= config.max_batch_size {
                    true  // Size threshold - flush to avoid oversized batches
                } else {
                    false
                };

                if should_flush {
                    send_batch(&batch_buf, send).await?;
                    batch_buf.clear();
                }
            }

            // Case 2: Timeout expired - flush buffered data
            _ = tokio::time::sleep(flush_timeout), if !batch_buf.is_empty() => {
                send_batch(&batch_buf, send).await?;
                batch_buf.clear();
            }
        }
    }

    let _ = send.finish();
    Ok(())
}

/// Pump data from PTY to QUIC stream with session tagging (Phase 04)
///
/// Multi-session variant that wraps output in TaggedOutput for routing.
/// Also captures output to history buffer for session replay.
///
/// # Arguments
/// * `pty` - Async reader from PTY
/// * `send` - QUIC send stream
/// * `session_id` - UUID of the session generating this output
/// * `history_tx` - Optional channel sender to push history lines (for inactive sessions)
///
/// # History Capture
/// - Splits output by newlines (\n)
/// - Maintains incomplete UTF-8 sequences between chunks
/// - Max 100 lines in history buffer
pub async fn pump_pty_to_quic_tagged<R>(
    mut pty: R,
    send: &mut SendStream,
    session_id: String,
    history_tx: Option<tokio::sync::mpsc::Sender<String>>,
) -> Result<()>
where
    R: AsyncReadExt + Unpin + Send,
{
    let mut buf = vec![0u8; 8192];
    let mut line_accumulator = Vec::new(); // For handling split UTF-8

    loop {
        let n = pty.read(&mut buf).await?;
        if n == 0 {
            tracing::debug!("PTY EOF for session {}, closing stream", session_id);
            break;
        }

        let data = &buf[..n];

        // FAST PATH: Send to network immediately (no waiting for history)
        let msg = NetworkMessage::TaggedOutput(TaggedOutput {
            session_id: session_id.clone(),
            data: data.to_vec(),
        });
        let encoded = MessageCodec::encode(&msg)?;
        send.write_all(&encoded).await?;

        // SLOW PATH: Capture to history (best effort, non-blocking)
        if let Some(ref tx) = history_tx {
            // Accumulate bytes and try to extract complete lines
            line_accumulator.extend_from_slice(data);

            // Try to parse as UTF-8 and extract lines
            if let Ok(text) = String::from_utf8(line_accumulator.clone()) {
                let mut lines = text.split('\n').peekable();
                let mut has_incomplete = false;

                while let Some(line) = lines.next() {
                    if lines.peek().is_some() {
                        // Complete line (before \n)
                        let _ = tx.try_send(line.to_string()); // Non-blocking, drops if full
                    } else {
                        // Last segment (may be incomplete if no trailing \n)
                        if !text.ends_with('\n') && !line.is_empty() {
                            line_accumulator = line.as_bytes().to_vec();
                            has_incomplete = true;
                        }
                    }
                }

                if !has_incomplete {
                    line_accumulator.clear();
                }
            } else {
                // Invalid UTF-8 - this happens when multi-byte char is split across chunks
                // Keep the bytes and wait for next chunk to complete the character
                // Safety: Prevent unbounded growth from binary garbage
                if line_accumulator.len() > 10000 {
                    line_accumulator.clear();
                }
            }

            tracing::trace!("Sent {} bytes from PTY session {} to QUIC (history captured)", n, session_id);
        } else {
            tracing::trace!("Sent {} bytes from PTY session {} to QUIC (no history)", n, session_id);
        }
    }

    let _ = send.finish();
    Ok(())
}

/// Helper: send a batch of data as a single NetworkMessage
async fn send_batch(data: &[u8], send: &mut SendStream) -> Result<()> {
    if data.is_empty() {
        return Ok(());
    }

    // DEBUG: Log PTY output
    eprintln!("[DEBUG] PTY output: {:02X?}", data);

    let msg = NetworkMessage::Event(TerminalEvent::Output {
        data: data.to_vec(),
    });
    let encoded = MessageCodec::encode(&msg)?;
    send.write_all(&encoded).await?;
    Ok(())
}

/// Pump data from QUIC stream to PTY
///
/// Reads NetworkMessages from QUIC stream and writes commands to PTY.
///
/// # Arguments
/// * `recv` - QUIC receive stream
/// * `pty` - Async writer to PTY
/// * `send` - Optional QUIC send stream for control messages (Pong, etc.)
///
/// # Message Handling
/// - Command: Write text to PTY
/// - Resize: Handle terminal resize (implemented in server)
/// - Ping: Respond with Pong (if send stream provided)
/// - Other: Ignore with debug log
pub async fn pump_quic_to_pty<W>(
    mut recv: RecvStream,
    mut pty: W,
    send: Option<Arc<Mutex<SendStream>>>,
) -> Result<()>
where
    W: AsyncWriteExt + Unpin + Send,
{
    let mut len_buf = [0u8; 4];

    loop {
        // Read length prefix (4 bytes, big endian)
        recv.read_exact(&mut len_buf).await
            .map_err(|_| CoreError::Connection("Stream closed by peer".to_string()))?;

        let len = u32::from_be_bytes(len_buf) as usize;

        // Validate message size (max 16MB as per MessageCodec)
        if len > 16 * 1024 * 1024 {
            return Err(CoreError::MessageTooLarge {
                size: len,
                max: 16 * 1024 * 1024,
            });
        }

        // Read payload
        let mut data = vec![0u8; len];
        recv.read_exact(&mut data).await
            .map_err(|_| CoreError::Connection("Stream closed while reading payload".to_string()))?;

        // Decode message
        let msg = MessageCodec::decode(&data)?;

        match msg {
            NetworkMessage::Command(cmd) => {
                // Write command text to PTY
                pty.write_all(cmd.text.as_bytes()).await?;
                tracing::trace!("Wrote command to PTY: {}", cmd.text.trim());
            }
            NetworkMessage::Resize { rows, cols } => {
                // TODO: Handle PTY resize
                tracing::debug!("Resize request: {}x{} (not yet implemented)", rows, cols);
            }
            NetworkMessage::Ping { timestamp } => {
                // Respond to ping with pong
                tracing::trace!("Received ping with timestamp {}, sending pong", timestamp);
                if let Some(send) = &send {
                    let pong = NetworkMessage::pong(timestamp);
                    let encoded = MessageCodec::encode(&pong)?;
                    let mut send = send.lock().await;
                    send.write_all(&encoded).await
                        .map_err(|e| CoreError::Connection(format!("Failed to send pong: {}", e)))?;
                    tracing::trace!("Sent pong response");
                } else {
                    tracing::warn!("Received ping but no send stream available to respond");
                }
            }
            NetworkMessage::Pong { timestamp: _ } => {
                tracing::trace!("Received pong");
            }
            NetworkMessage::Close => {
                tracing::info!("Received close message");
                return Ok(());
            }
            _ => {
                tracing::debug!("Ignoring message: {:?}", msg);
            }
        }
    }
}

/// Bidirectional stream pump
///
/// Spawns two tasks to handle bidirectional PTY  QUIC communication.
/// Returns when either direction completes or fails.
///
/// # Arguments
/// * `pty_reader` - Async reader from PTY
/// * `pty_writer` - Async writer to PTY
/// * `send` - QUIC send stream
/// * `recv` - QUIC receive stream
pub async fn bidirectional_pump<R, W>(
    pty_reader: R,
    pty_writer: W,
    send: SendStream,
    recv: RecvStream,
) -> Result<()>
where
    R: AsyncReadExt + Unpin + Send + 'static,
    W: AsyncWriteExt + Unpin + Send + 'static,
{
    // Share send stream so both pumps can use it
    // PTYQUIC uses it for terminal output
    // QUICPTY uses it for control messages (Pong)
    let send_shared = Arc::new(Mutex::new(send));

    let pty_task = tokio::spawn({
        let send = send_shared.clone();
        async move {
            let mut send_lock = send.lock().await;
            pump_pty_to_quic(pty_reader, &mut *send_lock).await
        }
    });

    let quic_task = tokio::spawn(async move {
        pump_quic_to_pty(recv, pty_writer, Some(send_shared)).await
    });

    tokio::select! {
        r = pty_task => {
            match r {
                Ok(Ok(())) => tracing::debug!("PTYQUIC pump completed"),
                Ok(Err(e)) => tracing::error!("PTYQUIC pump failed: {}", e),
                Err(e) => tracing::error!("PTYQUIC task panicked: {}", e),
            }
        }
        r = quic_task => {
            match r {
                Ok(Ok(())) => tracing::debug!("QUICPTY pump completed"),
                Ok(Err(e)) => tracing::error!("QUICPTY pump failed: {}", e),
                Err(e) => tracing::error!("QUICPTY task panicked: {}", e),
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_size_validation() {
        // Test that max size check works
        let max_size = 16 * 1024 * 1024;
        assert!(max_size == 16 * 1024 * 1024);
    }

    // Note: Full integration tests require async runtime and mock streams
    // These are better suited as integration tests in the test suite
}

================
File: core/src/types/command.rs
================
//! Terminal command types for mobile input

use serde::{Deserialize, Serialize};

/// Terminal command sent from mobile to host
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct TerminalCommand {
    /// Unique command ID
    pub id: u64,
    /// Command text or keystroke input
    pub text: String,
    /// Unix timestamp (milliseconds)
    pub timestamp: u64,
}

impl TerminalCommand {
    /// Create new terminal command
    pub fn new(text: String) -> Self {
        Self {
            id: Self::generate_id(),
            text,
            timestamp: Self::now(),
        }
    }

    fn generate_id() -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_micros() as u64)
            .unwrap_or(0)
    }

    fn now() -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_millis() as u64)
            .unwrap_or(0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_command_creation() {
        let cmd = TerminalCommand::new("ls -la".to_string());
        assert_eq!(cmd.text, "ls -la");
        assert!(cmd.id > 0);
        assert!(cmd.timestamp > 0);
    }

    #[test]
    fn test_command_serialization() {
        let cmd = TerminalCommand::new("echo test".to_string());
        let serialized = postcard::to_allocvec(&cmd).unwrap();
        let deserialized: TerminalCommand = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(cmd, deserialized);
    }
}

================
File: core/src/types/event.rs
================
//! Terminal event types for host output

use serde::{Deserialize, Serialize};

/// Terminal event sent from host to mobile
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum TerminalEvent {
    /// Terminal output data (UTF-8 bytes)
    Output { data: Vec<u8> },

    /// Terminal error message
    Error { message: String },

    /// Terminal process exited
    Exit { code: i32 },

    /// Terminal resize acknowledgement
    Resized { rows: u16, cols: u16 },

    // ===== Multi-Session Events - Phase 04 =====

    /// Session created successfully
    SessionCreated { session_id: String },

    /// Session exists and can be re-attached
    SessionReAttach { session_id: String },

    /// Session not found (need to re-spawn)
    SessionNotFound { session_id: String },

    /// Active session switched
    SessionSwitched { session_id: String },

    /// Session closed successfully
    SessionClosed { session_id: String },
}

impl TerminalEvent {
    /// Create output event from bytes
    pub fn output(data: Vec<u8>) -> Self {
        Self::Output { data }
    }

    /// Create output event from string (UTF-8)
    pub fn output_str(s: &str) -> Self {
        Self::Output {
            data: s.as_bytes().to_vec(),
        }
    }

    /// Create error event
    pub fn error(message: String) -> Self {
        Self::Error { message }
    }

    /// Create exit event
    pub fn exit(code: i32) -> Self {
        Self::Exit { code }
    }

    /// Create resized event
    pub fn resized(rows: u16, cols: u16) -> Self {
        Self::Resized { rows, cols }
    }

    // ===== Session event helpers - Phase 04 =====

    /// Create session created event
    pub fn session_created(session_id: String) -> Self {
        Self::SessionCreated { session_id }
    }

    /// Create session re-attach event
    pub fn session_reattach(session_id: String) -> Self {
        Self::SessionReAttach { session_id }
    }

    /// Create session not found event
    pub fn session_not_found(session_id: String) -> Self {
        Self::SessionNotFound { session_id }
    }

    /// Create session switched event
    pub fn session_switched(session_id: String) -> Self {
        Self::SessionSwitched { session_id }
    }

    /// Create session closed event
    pub fn session_closed(session_id: String) -> Self {
        Self::SessionClosed { session_id }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_output() {
        let event = TerminalEvent::output_str("Hello, World!");
        assert_eq!(event, TerminalEvent::Output {
            data: b"Hello, World!".to_vec()
        });
    }

    #[test]
    fn test_event_serialization() {
        let event = TerminalEvent::exit(0);
        let serialized = postcard::to_allocvec(&event).unwrap();
        let deserialized: TerminalEvent = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(event, deserialized);
    }
}

================
File: core/src/types/message.rs
================
//! Network protocol messages

use serde::{Deserialize, Serialize};
use crate::{AuthToken, CoreError, PROTOCOL_VERSION, APP_VERSION_STRING, Result};
use super::{TerminalCommand, TerminalEvent};

/// Network message type for QUIC protocol
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum NetworkMessage {
    /// Protocol handshake
    /// Phase E03: auth_token is Option<AuthToken> for authentication
    Hello {
        protocol_version: u32,  // MUST match PROTOCOL_VERSION
        app_version: String,     // For logging only
        capabilities: u32,
        auth_token: Option<AuthToken>,  // Phase E03: Token for authentication
    },

    /// Terminal command from client
    Command(TerminalCommand),

    /// Raw input bytes for pure passthrough (Phase 08+)
    /// Client sends raw keystrokes, server writes directly to PTY
    /// PTY handles echo & signal generation (Ctrl+C = SIGINT)
    /// This avoids String conversion overhead and preserves control bytes
    Input {
        /// Raw bytes from stdin (including control chars like 0x03 for Ctrl+C)
        data: Vec<u8>,
    },

    /// Terminal event from host
    Event(TerminalEvent),

    /// Heartbeat/ping
    Ping { timestamp: u64 },

    /// Pong response
    Pong { timestamp: u64 },

    /// Resize terminal request
    Resize { rows: u16, cols: u16 },

    /// Explicit PTY allocation request (SSH-like protocol)
    /// Client sends this after Hello to allocate PTY with correct size
    RequestPty {
        rows: u16,
        cols: u16,
        /// Optional: override default shell
        shell: Option<String>,
        /// Optional: additional env vars
        env: Vec<(String, String)>,
    },

    /// Explicit shell start command (SSH-like protocol)
    /// Client sends this after RequestPty to start the shell
    StartShell,

    /// Request full terminal snapshot (client  host)
    RequestSnapshot,

    /// Full terminal snapshot response (host  client)
    /// Dng Vec<u8>  an ton vi binary data, ANSI codes, invalid UTF-8
    Snapshot {
        /// Raw terminal data (scrollback + screen gom li)
        data: Vec<u8>,
        /// Terminal size khi snapshot
        rows: u16,
        cols: u16,
    },

    /// Connection close
    Close,

    // ===== VFS (Virtual File System) Messages - Phase 1 =====

    /// Request directory listing
    ListDir {
        path: String,
        depth: Option<u32>,  // Reserved for future recursive listing
    },

    /// Directory entry (part of DirChunk response)
    DirChunk {
        chunk_index: u32,
        total_chunks: u32,
        entries: Vec<DirEntry>,
        has_more: bool,
    },

    // ===== VFS File Watcher - Phase 3 =====

    /// Request to watch a directory for changes
    WatchDir {
        path: String,
    },

    /// Watch started successfully
    WatchStarted {
        watcher_id: String,
    },

    /// File system event
    FileEvent {
        watcher_id: String,
        path: String,
        event_type: FileEventType,
        timestamp: u64,
    },

    /// Request to stop watching
    UnwatchDir {
        watcher_id: String,
    },

    /// Watch error occurred
    WatchError {
        watcher_id: String,
        error: String,
    },

    // ===== VFS File Reading - Phase 2 =====

    /// Request to read file content
    ReadFile {
        path: String,
        max_size: usize,  // Maximum file size in bytes
    },

    /// File content response
    FileContent {
        path: String,
        content: String,
        size: usize,
        truncated: bool,  // True if file was larger than max_size
    },

    // ===== Multi-Session Support - Phase 04 =====

    /// Tagged output for multi-session routing
    /// Only active session's output is pumped; inactive sessions get history buffer on switch
    TaggedOutput(TaggedOutput),

    /// Session management messages
    Session(SessionMessage),

    /// History buffer for inactive session (100 lines)
    /// Sent when switching to an inactive session
    SessionHistory {
        session_id: String,
        lines: Vec<String>,
    },
}

/// Tagged output for multi-session routing
/// Phase 04: Project & Session Management
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct TaggedOutput {
    /// UUID of the session that generated this output
    pub session_id: String,
    /// Raw output data from PTY
    pub data: Vec<u8>,
}

/// Session management messages
/// Phase 04: Project & Session Management
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum SessionMessage {
    /// Create new PTY session in specific directory
    /// session_id is UUID from mobile - server uses it directly as key
    CreateSession {
        project_path: String,
        session_id: String,
    },

    /// Check if session exists (for re-attach on app restart)
    CheckSession {
        session_id: String,
    },

    /// Switch active session (triggers history buffer send)
    SwitchSession {
        session_id: String,
    },

    /// Close session
    CloseSession {
        session_id: String,
    },

    /// List active sessions
    ListSessions,
}

/// Directory entry for VFS browsing
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct DirEntry {
    pub name: String,
    pub path: String,
    pub is_dir: bool,
    pub is_symlink: bool,
    pub size: Option<u64>,
    pub modified: Option<u64>,
    pub permissions: Option<String>,
}

/// File system event type for watcher
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum FileEventType {
    Created,
    Modified,
    Deleted,
    Renamed { old_name: String },
}

impl NetworkMessage {
    /// Create hello message
    /// Phase E03: Takes optional auth token
    pub fn hello(token: Option<AuthToken>) -> Self {
        Self::Hello {
            protocol_version: PROTOCOL_VERSION,
            app_version: APP_VERSION_STRING.to_string(),
            capabilities: 0,
            auth_token: token,
        }
    }

    /// Validate handshake message
    pub fn validate_handshake(&self) -> Result<()> {
        match self {
            NetworkMessage::Hello { protocol_version, .. } => {
                if *protocol_version == PROTOCOL_VERSION {
                    Ok(())
                } else {
                    Err(CoreError::ProtocolVersionMismatch {
                        expected: PROTOCOL_VERSION,
                        got: *protocol_version,
                    })
                }
            }
            _ => Err(CoreError::InvalidHandshake),
        }
    }

    /// Create ping message
    pub fn ping() -> Self {
        use std::time::{SystemTime, UNIX_EPOCH};
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_millis() as u64)
            .unwrap_or(0);
        Self::Ping { timestamp }
    }

    /// Create pong response
    pub fn pong(timestamp: u64) -> Self {
        Self::Pong { timestamp }
    }

    /// Create resize message
    pub fn resize(rows: u16, cols: u16) -> Self {
        Self::Resize { rows, cols }
    }

    /// Create RequestPty message (SSH-like explicit PTY allocation)
    pub fn request_pty(rows: u16, cols: u16) -> Self {
        Self::RequestPty {
            rows,
            cols,
            shell: None,
            env: vec![],
        }
    }

    /// Create RequestPty message with custom shell and env vars
    pub fn request_pty_with_config(rows: u16, cols: u16, shell: Option<String>, env: Vec<(String, String)>) -> Self {
        Self::RequestPty {
            rows,
            cols,
            shell,
            env,
        }
    }

    /// Create StartShell message (SSH-like explicit shell start)
    pub fn start_shell() -> Self {
        Self::StartShell
    }

    /// Create request snapshot message
    pub fn request_snapshot() -> Self {
        Self::RequestSnapshot
    }

    /// Create snapshot message
    pub fn snapshot(data: Vec<u8>, rows: u16, cols: u16) -> Self {
        Self::Snapshot { data, rows, cols }
    }

    /// Create ReadFile message
    pub fn read_file(path: String, max_size: usize) -> Self {
        Self::ReadFile { path, max_size }
    }

    /// Create FileContent response
    pub fn file_content(path: String, content: String, size: usize, truncated: bool) -> Self {
        Self::FileContent { path, content, size, truncated }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_creation() {
        let msg = NetworkMessage::hello(None);
        assert!(matches!(msg, NetworkMessage::Hello { .. }));
    }

    #[test]
    fn test_message_with_token() {
        let token = AuthToken::generate();
        let msg = NetworkMessage::hello(Some(token));
        assert!(matches!(msg, NetworkMessage::Hello { .. }));
    }

    #[test]
    fn test_message_serialization() {
        let msg = NetworkMessage::Close;
        let serialized = postcard::to_allocvec(&msg).unwrap();
        let deserialized: NetworkMessage = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(msg, deserialized);
    }

    #[test]
    fn test_command_message_roundtrip() {
        let cmd = TerminalCommand::new("test".to_string());
        let msg = NetworkMessage::Command(cmd.clone());
        let serialized = postcard::to_allocvec(&msg).unwrap();
        let deserialized: NetworkMessage = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(msg, deserialized);
    }

    #[test]
    fn test_handshake_validation_valid() {
        let msg = NetworkMessage::hello(None);
        assert!(msg.validate_handshake().is_ok());
    }

    #[test]
    fn test_handshake_validation_invalid_version() {
        let msg = NetworkMessage::Hello {
            protocol_version: 999,
            app_version: "0.0.0".to_string(),
            capabilities: 0,
            auth_token: None,
        };
        let result = msg.validate_handshake();
        assert!(result.is_err());
        match result.unwrap_err() {
            CoreError::ProtocolVersionMismatch { expected, got } => {
                assert_eq!(expected, 1);
                assert_eq!(got, 999);
            }
            _ => panic!("Expected ProtocolVersionMismatch error"),
        }
    }

    #[test]
    fn test_handshake_validation_invalid_message_type() {
        let msg = NetworkMessage::Ping { timestamp: 0 };
        let result = msg.validate_handshake();
        assert!(matches!(result.unwrap_err(), CoreError::InvalidHandshake));
    }

    #[test]
    fn test_snapshot_messages() {
        let data = vec![1, 2, 3, 4];
        let msg = NetworkMessage::snapshot(data.clone(), 24, 80);

        assert!(matches!(msg, NetworkMessage::Snapshot { .. }));

        let serialized = postcard::to_allocvec(&msg).unwrap();
        let deserialized: NetworkMessage = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(msg, deserialized);
    }

    #[test]
    fn test_request_snapshot() {
        let msg = NetworkMessage::request_snapshot();
        assert!(matches!(msg, NetworkMessage::RequestSnapshot));
    }

    #[test]
    fn test_hello_with_auth_token_serialization() {
        let token = AuthToken::generate();
        let msg = NetworkMessage::hello(Some(token));

        let serialized = postcard::to_allocvec(&msg).unwrap();
        let deserialized: NetworkMessage = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(msg, deserialized);
    }

    #[test]
    fn test_request_pty_message() {
        let msg = NetworkMessage::request_pty(24, 80);
        assert!(matches!(msg, NetworkMessage::RequestPty { .. }));

        let serialized = postcard::to_allocvec(&msg).unwrap();
        let deserialized: NetworkMessage = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(msg, deserialized);
    }

    #[test]
    fn test_request_pty_with_config_message() {
        let shell = Some("/bin/bash".to_string());
        let env = vec![("TERM".to_string(), "xterm-256color".to_string())];
        let msg = NetworkMessage::request_pty_with_config(24, 80, shell, env);

        assert!(matches!(msg, NetworkMessage::RequestPty { rows: 24, cols: 80, .. }));

        let serialized = postcard::to_allocvec(&msg).unwrap();
        let deserialized: NetworkMessage = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(msg, deserialized);
    }

    #[test]
    fn test_start_shell_message() {
        let msg = NetworkMessage::start_shell();
        assert!(matches!(msg, NetworkMessage::StartShell));

        let serialized = postcard::to_allocvec(&msg).unwrap();
        let deserialized: NetworkMessage = postcard::from_bytes(&serialized).unwrap();
        assert_eq!(msg, deserialized);
    }
}

================
File: core/src/types/mod.rs
================
//! Domain types for terminal control

mod command;
mod event;
mod message;
mod qr;

pub use command::TerminalCommand;
pub use event::TerminalEvent;
pub use message::{NetworkMessage, DirEntry, FileEventType, TaggedOutput, SessionMessage};
pub use qr::QrPayload;

================
File: core/src/types/qr.rs
================
//! QR code payload for terminal pairing
//!
//! # Phase E04 - Certificate Persistence + TOFU
//!
//! QrPayload contains connection information encoded as QR code
//! for mobile clients to scan and establish initial trust.

use crate::error::{CoreError, Result};
use crate::PROTOCOL_VERSION;
use serde::{Deserialize, Serialize};

/// QR code payload for pairing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QrPayload {
    /// Host IP address
    pub ip: String,

    /// Host port
    pub port: u16,

    /// Certificate fingerprint (SHA-256, hex format with colons)
    pub fingerprint: String,

    /// Auth token (hex format)
    pub token: String,

    /// Protocol version
    pub protocol_version: u32,
}

impl QrPayload {
    /// Create new QR payload
    pub fn new(ip: String, port: u16, fingerprint: String, token: String) -> Self {
        Self {
            ip,
            port,
            fingerprint,
            token,
            protocol_version: PROTOCOL_VERSION,
        }
    }

    /// Serialize to JSON string (for QR encoding)
    pub fn to_json(&self) -> Result<String> {
        serde_json::to_string(self)
            .map_err(|e| CoreError::Protocol(format!("JSON serialization failed: {}", e)))
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self> {
        serde_json::from_str(json)
            .map_err(|e| CoreError::Protocol(format!("JSON deserialization failed: {}", e)))
    }

    /// Render QR code as Unicode string (for terminal display)
    ///
    /// **IMPORTANT**: Uses Dense1x2 Unicode renderer for terminal.
    /// NOT SVG - SVG will print as garbage XML text.
    ///
    /// # Example
    /// ```
    /// # use comacode_core::QrPayload;
    /// let payload = QrPayload::new(
    ///     "192.168.1.1".to_string(),
    ///     8443,
    ///     "AA:BB:CC".to_string(),
    ///     "deadbeef".to_string(),
    /// );
    /// let qr = payload.to_qr_terminal().unwrap();
    /// println!("{}", qr);
    /// ```
    pub fn to_qr_terminal(&self) -> Result<String> {
        use qrcode::render::unicode;

        let json = self.to_json()?;

        // Generate QR code
        let qr_code = qrcode::QrCode::new(json)
            .map_err(|e| CoreError::QrGenerationError(e.to_string()))?;

        // Render to Unicode (Dense1x2 = high density, scan-able)
        // Note: Dark on terminal = Light char, Light background = Dark char
        let image = qr_code
            .render::<unicode::Dense1x2>()
            .dark_color(unicode::Dense1x2::Light)
            .light_color(unicode::Dense1x2::Dark)
            .build();

        Ok(image)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_qr_payload_creation() {
        let payload = QrPayload::new(
            "192.168.1.1".to_string(),
            8443,
            "AA:BB:CC:DD".to_string(),
            "deadbeef".to_string(),
        );
        assert_eq!(payload.ip, "192.168.1.1");
        assert_eq!(payload.port, 8443);
        assert_eq!(payload.fingerprint, "AA:BB:CC:DD");
        assert_eq!(payload.token, "deadbeef");
        assert_eq!(payload.protocol_version, PROTOCOL_VERSION);
    }

    #[test]
    fn test_qr_payload_json_roundtrip() {
        let original = QrPayload::new(
            "192.168.1.1".to_string(),
            8443,
            "AA:BB:CC:DD".to_string(),
            "deadbeef".to_string(),
        );

        let json = original.to_json().unwrap();
        let decoded = QrPayload::from_json(&json).unwrap();

        assert_eq!(decoded.ip, original.ip);
        assert_eq!(decoded.port, original.port);
        assert_eq!(decoded.fingerprint, original.fingerprint);
        assert_eq!(decoded.token, original.token);
        assert_eq!(decoded.protocol_version, original.protocol_version);
    }

    #[test]
    fn test_qr_payload_to_qr_terminal() {
        let payload = QrPayload::new(
            "127.0.0.1".to_string(),
            8443,
            "AA:BB:CC".to_string(),
            "test".to_string(),
        );

        let qr = payload.to_qr_terminal();
        assert!(qr.is_ok());

        let qr_string = qr.unwrap();
        // Unicode QR should contain visible characters
        assert!(!qr_string.is_empty());
        assert!(qr_string.len() > 100);
    }

    #[test]
    fn test_qr_payload_serialize() {
        let payload = QrPayload::new(
            "10.0.0.1".to_string(),
            9000,
            "FF:EE:DD".to_string(),
            "cafe".to_string(),
        );

        let json = payload.to_json().unwrap();
        // JSON should contain all fields
        assert!(json.contains("\"ip\":"));
        assert!(json.contains("\"port\":"));
        assert!(json.contains("\"fingerprint\":"));
        assert!(json.contains("\"token\":"));
        assert!(json.contains("\"protocol_version\":"));
    }

    #[test]
    fn test_qr_payload_deserialize_invalid() {
        let result = QrPayload::from_json("invalid json");
        assert!(result.is_err());
    }

    #[test]
    fn test_qr_payload_empty_json() {
        let result = QrPayload::from_json("{}");
        // Missing required fields should fail
        assert!(result.is_err());
    }
}

================
File: core/src/auth.rs
================
//! Authentication token types for secure session access
//!
//! # Phase E03 - Security Hardening
//!
//! AuthToken provides 256-bit random token generation with hex encoding/decoding.
//!
//! ## Security Notes
//!
//! - **Copy trait**: Token is only 32 bytes, cheap to copy
//! - **Hash trait**: Enables HashSet storage for O(1) lookup
//! - **Random generation**: Uses thread_rng() from rand crate
//! - **Timing attack**: HashSet::contains() accepted for MVP (see validate() docs)

use crate::error::CoreError;
use rand::Rng;
use serde::{Deserialize, Serialize};

/// Token size in bytes (256-bit)
const TOKEN_SIZE: usize = 32;

/// Authentication token for session access
///
/// 256-bit random token used for authenticating mobile clients.
///
/// ## Derives
/// - `Copy`: 32 bytes is cheap to copy by value
/// - `Hash`: Enables HashSet storage for O(1) lookup
/// - `Eq`: Required for Hash, enables exact comparison
/// - `Serialize/Deserialize`: For Postcard protocol encoding
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct AuthToken([u8; TOKEN_SIZE]);

impl AuthToken {
    /// Generate a new random authentication token
    ///
    /// Uses cryptographically secure random number generation
    /// from rand::thread_rng().
    ///
    /// # Example
    /// ```
    /// # use comacode_core::auth::AuthToken;
    /// let token = AuthToken::generate();
    /// assert_eq!(token.as_bytes().len(), 32);
    /// ```
    pub fn generate() -> Self {
        let mut bytes = [0u8; TOKEN_SIZE];
        rand::thread_rng().fill(&mut bytes);
        Self(bytes)
    }

    /// Create token from hexadecimal string
    ///
    /// # Errors
    /// - `InvalidTokenFormat` if hex string is not exactly 64 characters
    /// - `InvalidTokenFormat` if hex string contains non-hex characters
    ///
    /// # Example
    /// ```
    /// # use comacode_core::auth::AuthToken;
    /// let token = AuthToken::generate();
    /// let hex = token.to_hex();
    /// let decoded = AuthToken::from_hex(&hex).unwrap();
    /// assert_eq!(token, decoded);
    /// ```
    pub fn from_hex(hex: &str) -> Result<Self, CoreError> {
        if hex.len() != TOKEN_SIZE * 2 {
            return Err(CoreError::InvalidTokenFormat);
        }

        let mut bytes = [0u8; TOKEN_SIZE];
        for i in 0..TOKEN_SIZE {
            bytes[i] = u8::from_str_radix(&hex[i * 2..i * 2 + 2], 16)
                .map_err(|_| CoreError::InvalidTokenFormat)?;
        }
        Ok(Self(bytes))
    }

    /// Export token as hexadecimal string
    ///
    /// Returns a 64-character hex string (lowercase).
    ///
    /// # Example
    /// ```
    /// # use comacode_core::auth::AuthToken;
    /// let token = AuthToken::generate();
    /// let hex = token.to_hex();
    /// assert_eq!(hex.len(), 64);
    /// ```
    pub fn to_hex(&self) -> String {
        self.0.iter().map(|b| format!("{:02x}", b)).collect()
    }

    /// Get raw bytes reference
    ///
    /// Returns reference to the 32-byte array.
    pub fn as_bytes(&self) -> &[u8; TOKEN_SIZE] {
        &self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_token_generation() {
        let token1 = AuthToken::generate();
        let token2 = AuthToken::generate();
        assert_ne!(token1, token2, "Tokens should be unique");
    }

    #[test]
    fn test_token_size() {
        let token = AuthToken::generate();
        assert_eq!(token.as_bytes().len(), 32);
    }

    #[test]
    fn test_token_hex_length() {
        let token = AuthToken::generate();
        let hex = token.to_hex();
        assert_eq!(hex.len(), 64);
    }

    #[test]
    fn test_token_hex_roundtrip() {
        let token = AuthToken::generate();
        let hex = token.to_hex();
        let decoded = AuthToken::from_hex(&hex).unwrap();
        assert_eq!(token, decoded);
    }

    #[test]
    fn test_token_from_hex_invalid_length() {
        let result = AuthToken::from_hex("abc123");
        assert!(matches!(result, Err(CoreError::InvalidTokenFormat)));
    }

    #[test]
    fn test_token_from_hex_invalid_chars() {
        let result = AuthToken::from_hex("gggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg");
        assert!(matches!(result, Err(CoreError::InvalidTokenFormat)));
    }

    #[test]
    fn test_token_copy() {
        let token1 = AuthToken::generate();
        let token2 = token1; // Copy, not move
        assert_eq!(token1, token2);
    }

    #[test]
    fn test_token_hash() {
        use std::collections::HashSet;
        let mut set = HashSet::new();
        let token = AuthToken::generate();
        set.insert(token);
        assert!(set.contains(&token));
    }
}

================
File: core/src/error.rs
================
//! Error types for comacode-core

use thiserror::Error;

/// Core error type
#[derive(Debug, Error)]
pub enum CoreError {
    #[error("Serialization failed: {0}")]
    Serialization(#[from] postcard::Error),

    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Protocol error: {0}")]
    Protocol(String),

    #[error("Invalid message format: {0}")]
    InvalidMessageFormat(String),

    #[error("Message too large: {size} bytes (max: {max})")]
    MessageTooLarge { size: usize, max: usize },

    #[error("Terminal error: {0}")]
    Terminal(String),

    #[error("Connection error: {0}")]
    Connection(String),

    #[error("Timeout after {0}ms")]
    Timeout(u64),

    #[error("Not connected")]
    NotConnected,

    #[error("Already connected")]
    AlreadyConnected,

    #[error("Invalid state: {0}")]
    InvalidState(String),

    #[error("Protocol version mismatch: expected {expected}, got {got}")]
    ProtocolVersionMismatch { expected: u32, got: u32 },

    #[error("Invalid handshake message")]
    InvalidHandshake,

    // Phase E03: Authentication errors
    #[error("Authentication failed: invalid token")]
    AuthFailed,

    #[error("Missing authentication token")]
    MissingAuthToken,

    #[error("Invalid token format")]
    InvalidTokenFormat,

    #[error("IP address {ip} is banned")]
    IpBanned { ip: std::net::IpAddr },

    #[error("Rate limit exceeded")]
    RateLimitExceeded,

    // Phase E04: Certificate & QR errors
    #[error("Certificate parse error: {0}")]
    CertParseError(String),

    #[error("No data directory found")]
    NoDataDir,

    #[error("QR code generation error: {0}")]
    QrGenerationError(String),

    #[error("Fingerprint mismatch for host {host}: expected {expected}, got {got}")]
    FingerprintMismatch {
        host: String,
        expected: String,
        got: String,
    },

    #[error("Network error: {0}")]
    NetworkError(String),

    // ===== VFS Errors - Phase 1 =====
    #[error("Path not found: {0}")]
    PathNotFound(String),

    #[error("Permission denied: {0}")]
    PermissionDenied(String),

    #[error("Not a directory: {0}")]
    NotADirectory(String),

    #[error("VFS I/O error: {0}")]
    VfsIoError(String),
}

/// Result type alias
pub type Result<T> = std::result::Result<T, CoreError>;

impl From<quinn::ConnectionError> for CoreError {
    fn from(err: quinn::ConnectionError) -> Self {
        CoreError::Connection(err.to_string())
    }
}

impl From<quinn::WriteError> for CoreError {
    fn from(err: quinn::WriteError) -> Self {
        CoreError::Io(std::io::Error::new(std::io::ErrorKind::BrokenPipe, err))
    }
}

impl From<quinn::ReadError> for CoreError {
    fn from(err: quinn::ReadError) -> Self {
        CoreError::Io(std::io::Error::new(std::io::ErrorKind::BrokenPipe, err))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_error_display() {
        let err = CoreError::NotConnected;
        assert_eq!(err.to_string(), "Not connected");
    }

    #[test]
    fn test_error_conversion() {
        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "test");
        let core_err: CoreError = io_err.into();
        assert!(matches!(core_err, CoreError::Io(_)));
    }

    #[test]
    fn test_protocol_version_mismatch_error() {
        let err = CoreError::ProtocolVersionMismatch { expected: 1, got: 2 };
        assert_eq!(err.to_string(), "Protocol version mismatch: expected 1, got 2");
    }

    #[test]
    fn test_invalid_handshake_error() {
        let err = CoreError::InvalidHandshake;
        assert_eq!(err.to_string(), "Invalid handshake message");
    }
}

================
File: core/src/lib.rs
================
//! Comacode Core - Shared business logic for terminal control
//!
//! This crate provides:
//! - Domain types (commands, events, messages)
//! - Protocol handling (Postcard serialization)
//! - Terminal abstraction trait
//! - Error types
//! - Authentication types (Phase E03)

// Version constants
pub const PROTOCOL_VERSION: u32 = 1;
pub const APP_VERSION_STRING: &str = "0.1.0-mvp";
pub const SNAPSHOT_BUFFER_LINES: usize = 1000;

pub mod auth;
pub mod error;
pub mod protocol;
pub mod streaming;
pub mod terminal;
pub mod transport;
pub mod types;

// Re-export common types
pub use auth::AuthToken;
pub use error::{CoreError, Result};
pub use protocol::MessageCodec;
pub use streaming::OutputStream;
pub use terminal::{Terminal, TerminalConfig, MockTerminal};
pub use types::{NetworkMessage, TerminalCommand, TerminalEvent, QrPayload, FileEventType};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_constants_defined() {
        assert_eq!(PROTOCOL_VERSION, 1);
        assert!(APP_VERSION_STRING.starts_with("0.1.0"));
    }
}

================
File: core/src/streaming.rs
================
//! Channel-based output streaming with zero-copy bytes
//!
//! This module provides a bounded channel-based architecture for terminal output
//! streaming, eliminating race conditions from shared state and creating natural
//! backpressure.

use bytes::Bytes;
use tokio::sync::mpsc;

/// Bounded channel for terminal output streaming
///
/// Uses `Bytes` instead of `Vec<u8>` for zero-copy cloning.
/// Channel capacity creates natural backpressure when buffer fills.
pub struct OutputStream {
    tx: mpsc::Sender<Bytes>,
}

impl OutputStream {
    /// Create new stream with specified buffer capacity
    ///
    /// # Arguments
    /// * `capacity` - Maximum number of messages in channel buffer
    ///
    /// # Returns
    /// * `(OutputStream, mpsc::Receiver<Bytes>)` - Sender and receiver halves
    pub fn new(capacity: usize) -> (Self, mpsc::Receiver<Bytes>) {
        let (tx, rx) = mpsc::channel(capacity);
        (Self { tx }, rx)
    }

    /// Send PTY output asynchronously
    ///
    /// Returns error if buffer full (backpressure) or receiver dropped.
    pub async fn send(&self, data: Bytes) -> Result<(), mpsc::error::SendError<Bytes>> {
        self.tx.send(data).await
    }

    /// Try send without waiting (non-blocking)
    ///
    /// Returns immediately with error if buffer full.
    pub fn try_send(&self, data: Bytes) -> Result<(), mpsc::error::TrySendError<Bytes>> {
        self.tx.try_send(data)
    }

    /// Get current channel capacity (for monitoring)
    #[inline]
    pub fn capacity(&self) -> usize {
        self.tx.capacity()
    }

    /// Get approximate remaining slots in buffer
    ///
    /// Useful for backpressure monitoring and logging.
    /// Note: This is an approximation based on channel capacity.
    #[inline]
    pub fn remaining(&self) -> usize {
        // Tokio mpsc doesn't expose remaining count directly
        // Return capacity as approximation (conservative estimate)
        self.capacity()
    }

    /// Get sender for cloning (needed for spawn_blocking)
    ///
    /// # Note
    /// Cloning sender is cheap (Arc-based), allows multiple producers.
    pub fn sender(&self) -> mpsc::Sender<Bytes> {
        self.tx.clone()
    }

    /// Check if channel is closed
    #[inline]
    pub fn is_closed(&self) -> bool {
        self.tx.is_closed()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::{timeout, Duration};

    #[tokio::test]
    async fn test_basic_send_receive() {
        let (stream, mut rx) = OutputStream::new(10);

        let data = Bytes::from("hello");
        stream.send(data.clone()).await.unwrap();

        let received = rx.recv().await.unwrap();
        assert_eq!(data, received);
    }

    #[tokio::test]
    async fn test_backpressure_blocking() {
        let (stream, mut rx) = OutputStream::new(2); // Small buffer

        // Fill buffer
        stream.send(Bytes::from("msg1")).await.unwrap();
        stream.send(Bytes::from("msg2")).await.unwrap();

        // This send should block until we drain
        let send_task = tokio::spawn(async move {
            stream.send(Bytes::from("msg3")).await.unwrap();
        });

        // Verify send doesn't complete immediately (would timeout if blocking)
        let result = timeout(Duration::from_millis(100), send_task).await;
        assert!(result.is_err(), "Send should block when buffer full");

        // Drain one message
        rx.recv().await.unwrap();

        // Now send should complete
        let _ = timeout(Duration::from_millis(100), rx.recv()).await.unwrap();
    }

    #[tokio::test]
    async fn test_try_send_fails_when_full() {
        let (stream, _rx) = OutputStream::new(2);

        stream.try_send(Bytes::from("msg1")).unwrap();
        stream.try_send(Bytes::from("msg2")).unwrap();

        // Should fail immediately
        let result = stream.try_send(Bytes::from("msg3"));
        assert!(result.is_err(), "try_send should fail when buffer full");
    }

    #[tokio::test]
    async fn test_remaining_capacity() {
        let (stream, _rx) = OutputStream::new(10);

        assert_eq!(stream.remaining(), 10);

        stream.send(Bytes::from("msg1")).await.unwrap();
        assert_eq!(stream.remaining(), 9);

        stream.send(Bytes::from("msg2")).await.unwrap();
        assert_eq!(stream.remaining(), 8);
    }

    #[tokio::test]
    async fn test_bytes_zero_copy() {
        let (stream, mut rx) = OutputStream::new(10);

        let data = Bytes::from(vec![1u8, 2, 3, 4, 5]);

        // Clone is cheap (just ref count increment)
        stream.send(data.clone()).await.unwrap();
        stream.send(data.clone()).await.unwrap();

        // Both clones should be identical
        let recv1 = rx.recv().await.unwrap();
        let recv2 = rx.recv().await.unwrap();

        assert_eq!(recv1, data);
        assert_eq!(recv2, data);
        assert_eq!(recv1.as_ptr(), recv2.as_ptr(), "Same underlying memory");
    }

    #[tokio::test]
    async fn test_channel_close_detection() {
        let (stream, rx) = OutputStream::new(10);

        assert!(!stream.is_closed());

        // Drop receiver
        drop(rx);

        // Give time for close to propagate
        tokio::task::yield_now().await;

        // Sender should detect closed channel
        assert!(stream.is_closed());

        // Send should fail
        let result = stream.send(Bytes::from("msg")).await;
        assert!(result.is_err());
    }
}

================
File: core/Cargo.toml
================
[package]
name = "comacode-core"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true

[dependencies]
# Workspace dependencies
serde = { workspace = true }
postcard = { workspace = true }
anyhow = { workspace = true }
thiserror = { workspace = true }
tracing = { workspace = true }
# Networking
quinn = { workspace = true }
rustls = { workspace = true, features = ["ring"] }
# Async
tokio = { workspace = true, features = ["sync"] }
async-trait = "0.1"
# Bytes for zero-copy
bytes = "1.8"
# Security (Phase E03)
rand = { workspace = true }
# Certificate & QR (Phase E04)
qrcode = { workspace = true }
serde_json = { workspace = true }

[dev-dependencies]
tokio = { workspace = true, features = ["test-util"] }
rcgen = "0.13"

================
File: hostagent/examples/test_qr.rs
================
use qrcode_generator::QrCodeEcc;

fn main() {
    let data = r#"{"ip":"192.168.1.1","port":8443,"fp":"abc123","token":"xyz"}"#;
    
    println!("Testing QR generation with different sizes:");
    
    for size in [21, 25, 29, 33, 37, 41] {
        match qrcode_generator::to_svg_to_string(
            data.as_bytes(),
            QrCodeEcc::Low,
            size,
            None::<&str>,
        ) {
            Ok(svg) => {
                let preview = if svg.len() > 100 { &svg[..100] } else { &svg };
                println!("Size {}: OK (total {} chars)\n  Preview: {}", size, svg.len(), preview);
            }
            Err(e) => println!("Size {}: ERR - {}", size, e),
        }
    }
}

================
File: hostagent/src/auth.rs
================
//! Token storage and validation for Phase E03 Security Hardening
//!
//! # TokenStore
//!
//! Manages valid authentication tokens with expiry time using HashMap for O(1) lookup.
//!
//! ## Security Note: Timing Attack Consideration
//!
//! HashMap::contains() is NOT constant-time comparison.
//!
//! ### Why this is ACCEPTED for MVP:
//! - Token is 256-bit random (2^256 entropy) - brute force infeasible
//! - Attacker does NOT control token content (server-generated)
//! - HashMap hash first  timing variation smaller than direct string compare
//! - Token is like a random API key, not a user-chosen password
//!
//! ### Future Enhancement:
//! - Use constant_time_eq crate if compliance requires (FIPS, etc.)

use comacode_core::auth::AuthToken;
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, SystemTime};
use tokio::sync::RwLock;

/// Default token TTL: 7 days
const DEFAULT_TOKEN_TTL: Duration = Duration::from_secs(7 * 24 * 60 * 60);

/// Token storage for validating authentication with expiry tracking
#[derive(Clone)]
pub struct TokenStore {
    /// Maps token -> creation time (for expiry check)
    valid_tokens: Arc<RwLock<HashMap<AuthToken, SystemTime>>>,
}

impl TokenStore {
    /// Create new empty token store
    pub fn new() -> Self {
        Self {
            valid_tokens: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Add valid token with current timestamp (e.g., from QR code scan)
    pub async fn add_token(&self, token: AuthToken) {
        let created_at = SystemTime::now();
        self.valid_tokens.write().await.insert(token, created_at);
    }

    /// Remove token (e.g., after disconnect or session expiry)
    #[allow(dead_code)]
    pub async fn remove_token(&self, token: &AuthToken) {
        self.valid_tokens.write().await.remove(token);
    }

    /// Validate token AND check expiry
    ///
    /// Returns true if token exists AND has not expired.
    /// Expired tokens are automatically removed (lazy cleanup).
    ///
    /// **Security Note**: See module-level docs about timing attack consideration.
    #[allow(dead_code)]
    pub async fn validate(&self, token: &AuthToken) -> bool {
        let tokens = self.valid_tokens.read().await;

        if let Some(created_at) = tokens.get(token) {
            // Check expiry
            match created_at.elapsed() {
                Ok(elapsed) => elapsed < DEFAULT_TOKEN_TTL,
                Err(_) => false,  // Clock went backwards? Treat as expired.
            }
        } else {
            false  // Token not found
        }
    }

    /// Generate and add new token
    pub async fn generate_token(&self) -> AuthToken {
        let token = AuthToken::generate();
        self.add_token(token).await; // Must await the async add_token
        token
    }

    /// Get count of valid tokens
    #[allow(dead_code)]
    pub async fn token_count(&self) -> usize {
        self.valid_tokens.read().await.len()
    }

    /// Clear all tokens (e.g., for testing or admin reset)
    #[allow(dead_code)]
    pub async fn clear(&self) {
        self.valid_tokens.write().await.clear();
    }

    /// Remove expired tokens and return count cleaned
    ///
    /// Call periodically (e.g., hourly) to prevent memory leak from old tokens.
    pub async fn cleanup_expired(&self) -> usize {
        let mut tokens = self.valid_tokens.write().await;

        let before = tokens.len();
        tokens.retain(|_token, created_at| {
            created_at.elapsed().unwrap_or(Duration::MAX) < DEFAULT_TOKEN_TTL
        });

        before - tokens.len()
    }
}

impl Default for TokenStore {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_token_store_new() {
        let store = TokenStore::new();
        assert_eq!(store.token_count().await, 0);
    }

    #[tokio::test]
    async fn test_add_token() {
        let store = TokenStore::new();
        let token = AuthToken::generate();
        store.add_token(token).await;
        assert_eq!(store.token_count().await, 1);
    }

    #[tokio::test]
    async fn test_validate_valid_token() {
        let store = TokenStore::new();
        let token = AuthToken::generate();
        store.add_token(token).await;
        assert!(store.validate(&token).await);
    }

    #[tokio::test]
    async fn test_validate_invalid_token() {
        let store = TokenStore::new();
        let token1 = AuthToken::generate();
        let token2 = AuthToken::generate();
        store.add_token(token1).await;
        assert!(!store.validate(&token2).await);
    }

    #[tokio::test]
    async fn test_remove_token() {
        let store = TokenStore::new();
        let token = AuthToken::generate();
        store.add_token(token).await;
        assert_eq!(store.token_count().await, 1);
        store.remove_token(&token).await;
        assert_eq!(store.token_count().await, 0);
        assert!(!store.validate(&token).await);
    }

    #[tokio::test]
    async fn test_generate_token() {
        let store = TokenStore::new();
        let token = store.generate_token().await;
        assert!(store.validate(&token).await);
        assert_eq!(store.token_count().await, 1);
    }

    #[tokio::test]
    async fn test_clear_tokens() {
        let store = TokenStore::new();
        store.generate_token().await;
        store.generate_token().await;
        assert_eq!(store.token_count().await, 2);
        store.clear().await;
        assert_eq!(store.token_count().await, 0);
    }

    #[tokio::test]
    async fn test_clone_token_store() {
        let store1 = TokenStore::new();
        let token = AuthToken::generate();
        store1.add_token(token).await;

        let store2 = store1.clone();
        assert!(store2.validate(&token).await);
    }

    #[tokio::test]
    async fn test_token_not_expired() {
        let store = TokenStore::new();
        let token = store.generate_token().await;
        // Token should be valid immediately
        assert!(store.validate(&token).await);
    }

    #[tokio::test]
    async fn test_cleanup_expired_removes_old_tokens() {
        let store = TokenStore::new();

        // Add a token manually (we can't test actual expiry without mocking SystemTime)
        let token = AuthToken::generate();
        store.add_token(token).await;

        // Cleanup should not remove recent tokens
        let cleaned = store.cleanup_expired().await;
        assert_eq!(cleaned, 0);
        assert!(store.validate(&token).await);
    }
}

================
File: hostagent/src/cert.rs
================
//! Certificate storage for Phase E04
//!
//! # CertStore
//!
//! Manages persistent storage of TLS certificates and private keys
//! using platform-specific data directories.
//!
//! ## Storage Location
//!
//! - **macOS**: `~/Library/Application Support/comacode/`
//! - **Linux**: `~/.local/share/comacode/`
//! - **Windows**: `%LOCALAPPDATA%\comacode\`
//!
//! ## Files
//!
//! - `host.crt` - Certificate (DER format)
//! - `host.key` - Private key (DER format, permissions 0600 on Unix)

use comacode_core::{CoreError, Result};
use rustls::pki_types::CertificateDer;
use sha2::{Digest, Sha256};
use std::fs;
use std::path::PathBuf;

/// Certificate storage
///
/// Persists certificates to disk to avoid repeated pairing.
#[allow(dead_code)]
pub struct CertStore {
    data_dir: PathBuf,
}

impl CertStore {
    /// Initialize certificate store
    ///
    /// Creates data directory if it doesn't exist.
    ///
    /// # Example
    /// ```
    /// # use hostagent::cert::CertStore;
    /// let store = CertStore::new().unwrap();
    /// assert!(store.data_dir().ends_with("comacode"));
    /// ```
    pub fn new() -> Result<Self> {
        let data_dir = dirs::data_local_dir()
            .ok_or(CoreError::NoDataDir)?
            .join("comacode");

        // Create directory if not exists
        fs::create_dir_all(&data_dir)
            .map_err(|e| CoreError::Io(std::io::Error::other(e)))?;

        Ok(Self { data_dir })
    }

    /// Get data directory path
    #[allow(dead_code)]
    pub fn data_dir(&self) -> PathBuf {
        self.data_dir.clone()
    }

    /// Path to certificate file
    #[allow(dead_code)]
    fn cert_path(&self) -> PathBuf {
        self.data_dir.join("host.crt")
    }

    /// Path to private key file
    #[allow(dead_code)]
    fn key_path(&self) -> PathBuf {
        self.data_dir.join("host.key")
    }

    /// Load existing certificate pair
    #[allow(dead_code)]
    ///
    /// Returns `None` if either file doesn't exist.
    ///
    /// # Example
    /// ```
    /// # use hostagent::cert::CertStore;
    /// # let store = CertStore::new().unwrap();
    /// let result = store.load();
    /// // Ok(None) if files don't exist
    /// // Ok(Some((cert, key_bytes))) if they do
    /// ```
    pub fn load(&self) -> Result<Option<(CertificateDer<'static>, Vec<u8>)>> {
        let cert_path = self.cert_path();
        let key_path = self.key_path();

        if !cert_path.exists() || !key_path.exists() {
            return Ok(None);
        }

        let cert_bytes = fs::read(&cert_path)?;
        let key_bytes = fs::read(&key_path)?;

        // Return certificate as DER (no parsing needed)
        let cert = CertificateDer::from(cert_bytes);

        Ok(Some((cert, key_bytes)))
    }

    /// Save new certificate pair
    ///
    /// Writes certificate and key to disk.
    /// Sets key file permissions to 0600 on Unix.
    #[allow(dead_code)]
    pub fn save(&self, cert: &CertificateDer<'_>, key: &[u8]) -> Result<()> {
        fs::write(self.cert_path(), cert.as_ref())?;
        fs::write(self.key_path(), key)?;

        // Set permissions (read-only by owner)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perm = fs::metadata(self.key_path())?.permissions();
            perm.set_mode(0o600); // rw-------
            fs::set_permissions(self.key_path(), perm)?;
        }

        Ok(())
    }

    /// Get certificate fingerprint (SHA-256) - static convenience method
    ///
    /// Returns fingerprint as colon-separated hex string without requiring a CertStore instance.
    /// Useful when you only have a certificate reference and don't need persistence.
    ///
    /// # Example
    /// ```
    /// # use hostagent::cert::CertStore;
    /// # use rustls::pki_types::CertificateDer;
    /// let cert_der = CertificateDer::from(vec![/* DER bytes */]);
    /// let fp = CertStore::fingerprint_from_cert_der(&cert_der);
    /// ```
    pub fn fingerprint_from_cert_der(cert: &CertificateDer<'_>) -> String {
        let der = cert.as_ref();
        let hash = Sha256::digest(der);

        hash.iter()
            .map(|b| format!("{:02x}", b))
            .collect::<Vec<_>>()
            .join(":")
    }

    /// Get certificate fingerprint (SHA-256)
    ///
    /// Returns fingerprint as colon-separated hex string
    /// (e.g., "AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33")
    #[allow(dead_code)]
    pub fn fingerprint(&self, cert: &CertificateDer<'_>) -> String {
        let der = cert.as_ref();
        let hash = Sha256::digest(der);

        // Format as hex with colons
        hash.iter()
            .map(|b| format!("{:02x}", b))
            .collect::<Vec<_>>()
            .join(":")
    }

    /// Clear stored certificates (for testing/reset)
    #[allow(dead_code)]
    pub fn clear(&self) -> Result<()> {
        let _ = fs::remove_file(self.cert_path());
        let _ = fs::remove_file(self.key_path());
        Ok(())
    }
}

impl Default for CertStore {
    fn default() -> Self {
        Self::new().expect("Failed to create CertStore")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cert_store_new() {
        let store = CertStore::new().unwrap();
        assert!(store.data_dir().ends_with("comacode"));
    }

    #[test]
    fn test_cert_store_paths() {
        let store = CertStore::new().unwrap();
        assert!(store.cert_path().ends_with("host.crt"));
        assert!(store.key_path().ends_with("host.key"));
    }

    #[test]
    fn test_cert_store_load_missing() {
        let store = CertStore::new().unwrap();
        // Clear any existing files
        store.clear().unwrap();
        // Loading non-existent files should return Ok(None)
        let result = store.load().unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn test_fingerprint_format() {
        let store = CertStore::new().unwrap();

        // Create a dummy cert (just for testing fingerprint format)
        let dummy_der = b"test certificate data";
        let hash = Sha256::digest(dummy_der);
        let expected: String = hash.iter()
            .map(|b| format!("{:02x}", b))
            .collect::<Vec<_>>()
            .join(":");

        // fingerprint should be 32 bytes = 64 hex chars + 31 colons = 95 chars
        assert_eq!(expected.len(), 95);
        assert_eq!(expected.chars().filter(|c| *c == ':').count(), 31);
    }

    #[test]
    fn test_cert_store_clear() {
        let store = CertStore::new().unwrap();
        // clear should not error even if files don't exist
        assert!(store.clear().is_ok());
    }
}

================
File: hostagent/src/main.rs
================
//! Comacode Host Agent
//!
//! Standalone PC binary that manages PTY sessions and exposes them via QUIC server.
//!
//! Desktop-only - not available on iOS.

#![cfg(not(target_os = "ios"))]

mod auth;
mod cert;
mod pty;
mod quic_server;
mod ratelimit;
mod session;
mod snapshot;
mod vfs;
mod vfs_watcher;
mod web_ui;

use anyhow::{Context, Result};
use clap::Parser;
use comacode_core::{CoreError, QrPayload};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use tokio::signal;
use tracing::{error, info, warn, Level};
use tracing_subscriber::{fmt, prelude::*, EnvFilter};

use crate::auth::TokenStore;
use crate::ratelimit::RateLimiterStore;
use std::sync::Arc;

/// Comacode Host Agent - Terminal server for mobile clients
#[derive(Parser, Debug)]
#[command(name = "hostagent")]
#[command(author = "Comacode Team")]
#[command(version = env!("CARGO_PKG_VERSION"))]
#[command(about = "Host agent for Comacode remote terminal", long_about = None)]
struct Args {
    /// Bind address for QUIC server
    #[arg(short, long, default_value = "0.0.0.0:8443")]
    bind: String,

    /// Log level (trace, debug, info, warn, error)
    #[arg(short, long, default_value = "info")]
    log_level: String,

    /// Disable browser auto-open (for web UI)
    #[arg(long, default_value = "false")]
    no_browser: bool,

    /// Use terminal QR instead of web dashboard
    #[arg(long, default_value = "false")]
    qr_terminal: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize rustls CryptoProvider with ring backend (required for rustls 0.23+)
    let _ = rustls::crypto::ring::default_provider().install_default();

    let args = Args::parse();

    // Setup logging
    setup_logging(&args.log_level)?;

    info!("Starting Comacode Host Agent v{}", env!("CARGO_PKG_VERSION"));

    // Parse bind address
    let bind_addr: SocketAddr = args
        .bind
        .parse()
        .with_context(|| format!("Invalid bind address: {}", args.bind))?;

    info!("Starting QUIC server on {}", bind_addr);

    // Generate auth token for QR pairing
    let token_store = Arc::new(TokenStore::new());
    let token = token_store.generate_token().await;
    info!("Auth token: {}", token.to_hex());

    // Create rate limiter for auth failure tracking
    let rate_limiter = Arc::new(RateLimiterStore::new());

    // Create and run QUIC server with auth stores
    let (mut server, cert, _key) = quic_server::QuicServer::new(bind_addr, token_store, rate_limiter).await?;

    // Get certificate fingerprint for QR code
    let cert_fingerprint = crate::cert::CertStore::fingerprint_from_cert_der(&cert);
    info!("Certificate fingerprint: {}", cert_fingerprint);

    // Get local IP for QR code
    let local_ip = get_local_ip()?;
    info!("Local IP: {}", local_ip);

    // Get actual port from server (may be different if binding to :0)
    let mut actual_port = bind_addr.port();
    if actual_port == 0 {
        // If binding to :0, OS assigns port - need to get it from server
        // For now, use default 8443
        actual_port = 8443;
    }

    // Create QR payload
    let qr_payload = QrPayload::new(
        local_ip.to_string(),
        actual_port,
        cert_fingerprint.clone(),
        token.to_hex(),
    );

    // Level 2: Web Dashboard (default)
    if !args.qr_terminal {
        // Create web server
        let web_server = web_ui::WebServer::new();
        let web_state = web_server.state();

        // Set QR payload for web UI
        web_state.set_qr_payload(qr_payload.clone()).await;

        // Start web server (binds to 127.0.0.1 only)
        let web_addr = web_server.start().await
            .context("Failed to start web server")?;

        info!("Web dashboard available at http://{}", web_addr);

        // Open browser if not disabled
        if !args.no_browser {
            let url = format!("http://{}", web_addr);
            if let Err(e) = web_ui::WebServer::open_browser(&url) {
                warn!("Failed to open browser: {}", e);
                println!("Open this URL in your browser: {}", url);
            }
        }

        println!("============================================");
        println!("Web Dashboard: http://{}", web_addr);
        println!("Scan QR code in browser to connect");
        println!("============================================");
    } else {
        // Level 1: Terminal QR (legacy)
        display_qr_code(&local_ip, actual_port, &cert_fingerprint, &token.to_hex());
    }

    // Spawn server task
    let server_handle = tokio::spawn(async move {
        if let Err(e) = server.run().await {
            error!("Server error: {}", e);
        }
    });

    // Wait for shutdown signal
    let mut sigterm = tokio::signal::unix::signal(signal::unix::SignalKind::terminate())
        .expect("Failed to setup SIGTERM handler");

    tokio::select! {
        _ = signal::ctrl_c() => {
            info!("Received Ctrl+C, shutting down...");
        }
        _ = sigterm.recv() => {
            info!("Received SIGTERM, shutting down...");
        }
        result = server_handle => {
            result.context("Server task failed")?;
        }
    }

    info!("Shutdown complete");
    Ok(())
}

/// Setup logging with tracing
fn setup_logging(level: &str) -> Result<()> {
    let log_level = level
        .parse::<Level>()
        .unwrap_or(Level::INFO);

    let filter = EnvFilter::builder()
        .with_default_directive(log_level.into())
        .from_env_lossy();

    tracing_subscriber::registry()
        .with(filter)
        .with(fmt::layer().with_writer(std::io::stderr))
        .init();

    Ok(())
}

/// Get local IP address for QR code
///
/// **IMPORTANT**: Filters out Docker bridge (172.17.x.x), loopback (127.x.x.x)
/// and falls back to 192.168.1.1 for typical LAN.
fn get_local_ip() -> Result<IpAddr> {
    use std::net::UdpSocket;

    // Create UDP socket to a non-local address (doesn't actually send data)
    let socket = UdpSocket::bind("0.0.0.0:0")
        .map_err(|e| CoreError::NetworkError(e.to_string()))?;

    // Connect to external DNS (doesn't send, just determines local interface)
    socket.connect("8.8.8.8:80")
        .map_err(|e| CoreError::NetworkError(e.to_string()))?;

    let local_ip = socket.local_addr()?.ip();

    // Filter: reject Docker bridge (172.17.x.x), loopback
    match local_ip {
        IpAddr::V4(ipv4) if is_docker_or_loopback(ipv4) => {
            warn!("Detected Docker/loopback IP {}, falling back to 192.168.1.1", local_ip);
            // Fallback: assume typical LAN
            Ok(IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1)))
        }
        _ => Ok(local_ip),
    }
}

/// Check if IP is Docker bridge or loopback
fn is_docker_or_loopback(ip: Ipv4Addr) -> bool {
    let octets = ip.octets();
    // Docker bridge: 172.17.x.x
    // Loopback: 127.x.x.x
    octets[0] == 172 && octets[1] == 17
        || octets[0] == 127
}

/// Display QR code for mobile pairing
fn display_qr_code(ip: &IpAddr, port: u16, fingerprint: &str, token: &str) {
    let qr_payload = QrPayload::new(
        ip.to_string(),
        port,
        fingerprint.to_string(),
        token.to_string(),
    );

    println!("============================================");
    println!("Scan QR code to connect:");
    println!();

    match qr_payload.to_qr_terminal() {
        Ok(qr) => println!("{}", qr),
        Err(e) => {
            warn!("Failed to generate QR code: {}", e);
            println!("QR code generation failed - see logs");
        }
    }

    println!();
    println!("============================================");
    println!("IP: {}", qr_payload.ip);
    println!("Port: {}", qr_payload.port);
    println!("Fingerprint: {}", qr_payload.fingerprint);
    println!("============================================");
    println!("TIP: If QR doesn't work, check IP with 'ifconfig' or 'ip addr'");
}

================
File: hostagent/src/pty.rs
================
//! PTY session management using portable-pty
//!
//! Provides cross-platform PTY spawning and I/O handling for terminal sessions.
//! Uses channel-based architecture with spawn_blocking for PTY reader.

use anyhow::{Context, Result};
use bytes::Bytes;
use comacode_core::terminal::TerminalConfig;
use comacode_core::OutputStream;
use portable_pty::{native_pty_system, CommandBuilder, PtySize};
use std::io::Read;
use std::sync::Arc;
use tokio::sync::Mutex;

/// PTY session wrapper
pub struct PtySession {
    /// PTY master handle
    _master: Box<dyn portable_pty::MasterPty + Send>,
    /// Child process handle
    child: Box<dyn portable_pty::Child + Send>,
    /// Session ID
    #[allow(dead_code)]
    id: u64,
    /// Current terminal size
    #[allow(dead_code)]
    size: (u16, u16),
    /// Writer handle
    #[allow(dead_code)]
    writer: Box<dyn std::io::Write + Send>,
    /// Output stream sender (legacy, replaced by channel-based streaming)
    #[allow(dead_code)]
    output_tx: tokio::sync::mpsc::Sender<Bytes>,
}

// Implement Send manually
unsafe impl Send for PtySession {}

impl PtySession {
    /// Spawn new PTY session with channel-based output streaming
    ///
    /// Returns `(Arc<Mutex<PtySession>>, Receiver<Bytes>)` where the receiver
    /// can be converted to AsyncRead for QUIC forwarding.
    pub fn spawn(id: u64, config: TerminalConfig) -> Result<(Arc<Mutex<Self>>, tokio::sync::mpsc::Receiver<Bytes>)> {
        let pty_system = native_pty_system();

        let pty_size = PtySize {
            rows: config.rows,
            cols: config.cols,
            pixel_width: 0,
            pixel_height: 0,
        };

        let pty_pair = pty_system
            .openpty(pty_size)
            .context("Failed to open PTY")?;

        // Build command with shell and env
        let mut cmd = CommandBuilder::new(config.shell.clone());
        for (key, value) in &config.env {
            cmd.env(key, value);
        }

        let child = pty_pair
            .slave
            .spawn_command(cmd)
            .context("Failed to spawn shell")?;

        // Get writer from master
        let writer = pty_pair.master.take_writer()?;

        // Create bounded output stream (channel capacity = 1024 messages)
        let (output_stream, output_rx) = OutputStream::new(1024);
        let output_tx = output_stream.sender();

        // PTY Reader Task: Uses spawn_blocking for blocking I/O
        // QUAN TRNG: portable-pty.read() is blocking - must use spawn_blocking
        let reader = pty_pair.master.try_clone_reader()?;
        let tx_clone = output_tx.clone();
        let session_id = id;

        let pty_reader = tokio::task::spawn_blocking(move || {
            let mut reader = reader;
            let mut buf = [0u8; 8192];

            loop {
                // Blocking read - blocks this thread but NOT the Tokio runtime
                match reader.read(&mut buf) {
                    Ok(0) => {
                        tracing::trace!("PTY reader EOF for session {}", session_id);
                        break;
                    }
                    Ok(n) => {
                        // Zero-cost conversion to Bytes (shares buffer if possible)
                        let data = Bytes::copy_from_slice(&buf[..n]);

                        // Blocking send OK because we're in spawn_blocking thread
                        match tx_clone.blocking_send(data) {
                            Ok(_) => {
                                // Log if send succeeds (backpressure is handled by blocking)
                                tracing::trace!("PTY output sent: {} bytes for session {}", n, session_id);
                            }
                            Err(_) => {
                                tracing::warn!("Output stream closed for session {}", session_id);
                                break;
                            }
                        }
                    }
                    Err(e) => {
                        tracing::error!("PTY read error for session {}: {}", session_id, e);
                        break;
                    }
                }
            }
            Ok::<(), anyhow::Error>(())
        });

        // Log reader task completion
        tokio::spawn(async move {
            match pty_reader.await {
                Ok(Ok(_)) => tracing::trace!("PTY reader task completed for session {}", session_id),
                Ok(Err(e)) => tracing::error!("PTY reader task error for session {}: {}", session_id, e),
                Err(e) => tracing::error!("PTY reader task panicked for session {}: {}", session_id, e),
            }
        });

        let session = Arc::new(Mutex::new(Self {
            _master: pty_pair.master,
            child,
            id,
            size: (config.rows, config.cols),
            writer,
            output_tx,
        }));

        tracing::info!(
            "PTY session {} spawned with shell {} (channel-based streaming)",
            id,
            config.shell
        );
        Ok((session, output_rx))
    }

    /// Get session ID
    #[allow(dead_code)]
    pub fn id(&self) -> u64 {
        self.id
    }

    /// Write data to PTY input
    pub fn write(&mut self, data: &[u8]) -> Result<()> {
        use std::io::Write;
        self.writer
            .write_all(data)
            .context("Failed to write to PTY")?;
        self.writer
            .flush()
            .context("Failed to flush PTY writer")?;
        Ok(())
    }

    /// Resize terminal
    pub fn resize(&mut self, rows: u16, cols: u16) -> Result<()> {
        let size = PtySize {
            rows,
            cols,
            pixel_width: 0,
            pixel_height: 0,
        };
        self._master
            .resize(size)
            .context("Failed to resize PTY")?;
        self.size = (rows, cols);
        Ok(())
    }

    /// Get current size
    #[allow(dead_code)]
    pub fn size(&self) -> (u16, u16) {
        self.size
    }

    /// Check if process is still alive
    pub fn is_alive(&mut self) -> bool {
        match self.child.try_wait() {
            Ok(None) => true,   // Process still running
            Ok(Some(_)) => false, // Process exited
            Err(_) => false,    // Error - treat as dead
        }
    }

    /// Kill child process explicitly
    pub fn kill(&mut self) -> Result<()> {
        self.child
            .kill()
            .map_err(|e| anyhow::anyhow!("Failed to kill process: {}", e))?;
        Ok(())
    }

    /// Get output stream sender for external forwarding
    ///
    /// This allows the QUIC server to subscribe to PTY output.
    #[allow(dead_code)]
    pub fn output_sender(&self) -> tokio::sync::mpsc::Sender<Bytes> {
        self.output_tx.clone()
    }

    /// Subscribe to PTY output stream (creates new receiver)
    ///
    /// Note: This is a convenience method that creates a new subscription.
    /// For production, use output_sender() directly for better performance.
    ///
    /// # Warning
    /// This method returns a dummy receiver for MVP.
    /// In Phase 03, we'll implement proper broadcast channel for multi-consumer support.
    #[allow(dead_code)]
    pub fn subscribe_output(&self) -> tokio::sync::broadcast::Receiver<Bytes> {
        // For MVP, return a dummy receiver
        // In Phase 03, we'll implement proper broadcast channel
        let (_tx, rx) = tokio::sync::broadcast::channel(1024);
        rx
    }
}

================
File: hostagent/src/quic_server.rs
================
//! QUIC server for terminal connections
//!
//! Provides encrypted QUIC endpoint for mobile client connections.

use anyhow::{Context, Result};
use comacode_core::{
    protocol::MessageCodec,
    transport::{configure_server, stream::pump_pty_to_quic, stream::pump_pty_to_quic_tagged},
    types::{NetworkMessage, SessionMessage, TerminalEvent},
};
use quinn::{Endpoint, TokioRuntime};
use rustls::pki_types::{CertificateDer, PrivateKeyDer};
use std::net::SocketAddr;
use std::path::PathBuf;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{oneshot, Mutex};
use tokio_stream::StreamExt;
use rcgen::KeyPair;

use crate::auth::TokenStore;
use crate::ratelimit::RateLimiterStore;
use crate::session::SessionManager;
use crate::vfs;
use crate::vfs_watcher::WatcherManager;

/// QUIC server for terminal connections
pub struct QuicServer {
    /// QUIC endpoint
    endpoint: Endpoint,
    /// Session manager for PTY instances
    session_mgr: Arc<SessionManager>,
    /// Token store for authentication validation
    token_store: Arc<TokenStore>,
    /// Rate limiter for auth failure tracking
    rate_limiter: Arc<RateLimiterStore>,
    /// File watcher manager for VFS (Phase VFS-3)
    watcher_mgr: Arc<WatcherManager>,
    /// Shutdown signal sender
    shutdown_tx: Option<oneshot::Sender<()>>,
}

impl QuicServer {
    /// Create new QUIC server with self-signed certificate
    pub async fn new(
        bind_addr: SocketAddr,
        token_store: Arc<TokenStore>,
        rate_limiter: Arc<RateLimiterStore>,
    ) -> Result<(Self, CertificateDer<'static>, PrivateKeyDer<'static>)> {
        // Generate self-signed certificate ONCE
        let (cert, key_pair) = generate_cert_with_keypair()?;

        // Serialize key twice - once for config, once for return
        let key_der = key_pair.serialize_der();
        let key_for_config = PrivateKeyDer::Pkcs8(key_der.clone().into());
        let key_for_return = PrivateKeyDer::Pkcs8(key_der.into());

        // Configure TLS using transport module (Phase 05.1)
        let cert_vec = vec![cert.clone()];
        let cfg = configure_server(cert_vec, key_for_config)
            .context("Failed to configure server")?;

        // Bind UDP socket
        let socket = std::net::UdpSocket::bind(bind_addr)
            .context("Failed to bind UDP socket")?;

        // Create endpoint with Tokio runtime
        let runtime = Arc::new(TokioRuntime);
        let endpoint = Endpoint::new(Default::default(), Some(cfg), socket, runtime)
            .context("Failed to create QUIC endpoint")?;

        tracing::info!("QUIC server listening on {}", bind_addr);

        Ok((
            Self {
                endpoint,
                session_mgr: Arc::new(SessionManager::new()),
                token_store,
                rate_limiter,
                watcher_mgr: Arc::new(WatcherManager::new()),
                shutdown_tx: None,
            },
            cert,
            key_for_return, // Return SAME key bytes, not regenerated
        ))
    }

    /// Run server (accepts connections indefinitely)
    pub async fn run(&mut self) -> Result<()> {
        let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
        self.shutdown_tx = Some(shutdown_tx);

        // Spawn session cleanup task
        let session_mgr = Arc::clone(&self.session_mgr);
        tokio::spawn(async move {
            let _cleanup_handle = session_mgr.spawn_cleanup_task();
            // Keep cleanup task running
            loop {
                tokio::time::sleep(Duration::from_secs(60)).await;
            }
        });

        // Spawn token cleanup task (hourly)
        let token_store = Arc::clone(&self.token_store);
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(3600));
            loop {
                interval.tick().await;
                let cleaned = token_store.cleanup_expired().await;
                if cleaned > 0 {
                    tracing::info!("Cleaned {} expired tokens", cleaned);
                }
            }
        });

        // Accept connections loop
        loop {
            tokio::select! {
                // Accept incoming connection
                incoming = self.endpoint.accept() => {
                    match incoming {
                        Some(incoming) => {
                            let session_mgr = Arc::clone(&self.session_mgr);
                            let token_store = Arc::clone(&self.token_store);
                            let rate_limiter = Arc::clone(&self.rate_limiter);
                            let watcher_mgr = Arc::clone(&self.watcher_mgr);
                            tokio::spawn(async move {
                                if let Err(e) = Self::handle_connection(incoming, session_mgr, token_store, rate_limiter, watcher_mgr).await {
                                    tracing::error!("Connection error: {}", e);
                                }
                            });
                        }
                        None => {
                            tracing::warn!("Endpoint closed");
                            break;
                        }
                    }
                }
                // Shutdown signal
                _ = &mut shutdown_rx => {
                    tracing::info!("Shutdown signal received");
                    break;
                }
            }
        }

        Ok(())
    }

    /// Handle single connection
    async fn handle_connection(
        incoming: quinn::Incoming,
        session_mgr: Arc<SessionManager>,
        token_store: Arc<TokenStore>,
        rate_limiter: Arc<RateLimiterStore>,
        watcher_mgr: Arc<WatcherManager>,
    ) -> Result<()> {
        // Accept the connection - returns Result<Connecting, ConnectionError>
        let connecting = incoming.accept()?;
        let connection = connecting.await?;

        let remote_addr = connection.remote_address();
        tracing::info!("Connection from {}", remote_addr);

        // Handle bi-directional streams
        loop {
            match connection.accept_bi().await {
                Ok((send, recv)) => {
                    let session_mgr = Arc::clone(&session_mgr);
                    let token_store = Arc::clone(&token_store);
                    let rate_limiter = Arc::clone(&rate_limiter);
                    let watcher_mgr = Arc::clone(&watcher_mgr);
                    tokio::spawn(async move {
                        if let Err(e) = Self::handle_stream(send, recv, session_mgr, token_store, rate_limiter, watcher_mgr, remote_addr).await {
                            tracing::error!("Stream error: {}", e);
                        }
                    });
                }
                Err(quinn::ConnectionError::ApplicationClosed(_)) | Err(quinn::ConnectionError::LocallyClosed) => {
                    tracing::info!("Connection closed");
                    break;
                }
                Err(e) => {
                    tracing::error!("Accept stream error: {}", e);
                    break;
                }
            }
        }

        Ok(())
    }

    /// Handle single bi-directional stream
    async fn handle_stream(
        send: quinn::SendStream,
        mut recv: quinn::RecvStream,
        session_mgr: Arc<SessionManager>,
        token_store: Arc<TokenStore>,
        rate_limiter: Arc<RateLimiterStore>,
        watcher_mgr: Arc<WatcherManager>,
        peer_addr: SocketAddr,
    ) -> Result<()> {
        let mut session_id: Option<u64> = None;  // Legacy session ID
        let mut active_session_id: Option<String> = None;  // Phase 04: Active UUID session
        let mut authenticated = false;
        let mut pty_task: Option<tokio::task::JoinHandle<()>> = None;
        let mut pending_resize: Option<(u16, u16)> = None; // Store (rows, cols) before session created

        // Share send stream for PTY output forwarding
        let send_shared = Arc::new(Mutex::new(send));

        // Message receive loop - read length-prefixed messages properly
        let mut recv_buffer = Vec::new(); // Buffer for incomplete reads

        loop {
            // Try to read some data
            let mut read_buf = [0u8; 8192];
            let n = match recv.read(&mut read_buf).await {
                Ok(Some(0)) => {
                    tracing::info!("Connection closed by client (EOF)");
                    break;
                }
                Ok(Some(n)) => n,
                Ok(None) => {
                    tracing::info!("Connection closed by client (None)");
                    break;
                }
                Err(e) => {
                    tracing::error!("Read error: {}", e);
                    break;
                }
            };

            // Append to recv buffer
            recv_buffer.extend_from_slice(&read_buf[..n]);
            tracing::debug!("Received {} bytes, buffer size: {}", n, recv_buffer.len());

            // Process all complete messages in buffer
            while let Some((msg, remaining)) = Self::try_decode_message(&recv_buffer) {
                recv_buffer = remaining.to_vec();

                tracing::info!("Received message: {:?}", std::mem::discriminant(&msg));

                // Handle message
                match msg {
                    NetworkMessage::Hello { ref protocol_version, ref app_version, auth_token, .. } => {
                    tracing::info!("Client hello protocol_version={}, app_version={}", protocol_version, app_version);

                    // Phase 07-A: AUTH VALIDATION (P0 fix)
                    let token_valid = if let Some(token) = auth_token {
                        token_store.validate(&token).await
                    } else {
                        tracing::warn!("No auth token provided from {}", peer_addr);
                        false
                    };

                    if !token_valid {
                        tracing::warn!("Auth failed for IP: {}", peer_addr);

                        // Record failure for rate limiting
                        let _ = rate_limiter.record_auth_failure(peer_addr.ip()).await;

                        // Send error response and close
                        let mut send_lock = send_shared.lock().await;
                        let _ = Self::send_message(&mut *send_lock, &NetworkMessage::hello(None)).await;
                        break;
                    }

                    // Reset auth failures on success
                    rate_limiter.reset_auth_failures(peer_addr.ip()).await;
                    authenticated = true;
                    tracing::info!("Client authenticated: {}", peer_addr);

                    // Validate protocol version
                    if let Err(e) = msg.validate_handshake() {
                        tracing::error!("Handshake validation failed: {}", e);
                        // Send error and close
                        let mut send_lock = send_shared.lock().await;
                        let _ = Self::send_message(&mut *send_lock, &NetworkMessage::hello(None)).await;
                        break;
                    }

                    // Respond with Hello
                    let response = NetworkMessage::hello(None);
                    let mut send_lock = send_shared.lock().await;
                    Self::send_message(&mut *send_lock, &response).await?;
                    }
                    NetworkMessage::Input { data } => {
                    // Raw input bytes - pure passthrough to PTY
                    // PTY handles echo & signal generation (Ctrl+C = SIGINT)
                    if !authenticated {
                        tracing::warn!("Input received before authentication from {}", peer_addr);
                        break;
                    }

                    // Phase 04: Check for active UUID session first, then legacy session
                    if let Some(ref uuid) = active_session_id {
                        // Write to UUID session
                        if let Err(e) = session_mgr.write_to_uuid_session(uuid, &data).await {
                            tracing::error!("Failed to write input to UUID session {}: {}", uuid, e);
                        }
                    } else if let Some(id) = session_id {
                        // Write raw bytes directly to legacy PTY
                        if let Err(e) = session_mgr.write_to_session(id, &data).await {
                            tracing::error!("Failed to write input to PTY: {}", e);
                        }
                    } else {
                        // Spawn new session with terminal configuration
                        let _ = Self::spawn_session_with_config(
                            &session_mgr,
                            pending_resize,
                            &mut pty_task,
                            &mut session_id,
                            &send_shared,
                            &data,
                        ).await;
                    }
                    }
                    NetworkMessage::Command(cmd) => {
                    // Legacy: Command with String text
                    // Still supported for backward compatibility
                    // Use Input instead for raw byte passthrough
                    if !authenticated {
                        tracing::warn!("Command received before authentication from {}", peer_addr);
                        break;
                    }

                    // Phase 04: Check for active UUID session first, then legacy session
                    if let Some(ref uuid) = active_session_id {
                        if let Err(e) = session_mgr.write_to_uuid_session(uuid, cmd.text.as_bytes()).await {
                            tracing::error!("Failed to write command to UUID session {}: {}", uuid, e);
                        }
                    } else if let Some(id) = session_id {
                        if let Err(e) = session_mgr.write_to_session(id, cmd.text.as_bytes()).await {
                            tracing::error!("Failed to write to PTY: {}", e);
                        }
                    } else {
                        // Spawn new session with terminal configuration (legacy Command path)
                        let _ = Self::spawn_session_with_config(
                            &session_mgr,
                            pending_resize,
                            &mut pty_task,
                            &mut session_id,
                            &send_shared,
                            cmd.text.as_bytes(),
                        ).await;
                    }
                    }
                    NetworkMessage::Ping { timestamp } => {
                    // Respond with Pong
                    let response = NetworkMessage::pong(timestamp);
                    let mut send_lock = send_shared.lock().await;
                    Self::send_message(&mut *send_lock, &response).await?;
                    }
                    NetworkMessage::Resize { rows, cols } => {
                    // Phase 04: Check for active UUID session first, then legacy session
                    if let Some(ref uuid) = active_session_id {
                        if let Err(e) = session_mgr.resize_uuid_session(uuid, rows, cols).await {
                            tracing::error!("Failed to resize UUID session {}: {}", uuid, e);
                        }
                    } else if let Some(id) = session_id {
                        if let Err(e) = session_mgr.resize_session(id, rows, cols).await {
                            tracing::error!("Failed to resize PTY: {}", e);
                        }
                    } else {
                        // Store pending resize for when session is created
                        pending_resize = Some((rows, cols));
                        tracing::debug!("Stored pending resize: {}x{}", rows, cols);
                    }
                    }
                    NetworkMessage::Close => {
                        tracing::info!("Received Close message");
                        break;
                    }
                    // ===== VFS: Directory Listing - Phase 1 =====
                    NetworkMessage::ListDir { path, depth: _ } => {
                        if !authenticated {
                            tracing::warn!("ListDir received before authentication from {}", peer_addr);
                            break;
                        }

                        tracing::info!("ListDir request: {}", path);

                        let path_buf = PathBuf::from(&path);

                        // Check if path exists
                        if !path_buf.exists() {
                            let error_msg = format!("Path not found: {}", path);
                            tracing::warn!("{}", error_msg);
                            let mut send_lock = send_shared.lock().await;
                            let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                comacode_core::types::TerminalEvent::Error {
                                    message: error_msg,
                                }
                            )).await;
                            break;
                        }

                        // Read directory
                        match vfs::read_directory(&path_buf).await {
                            Ok(entries) => {
                                // Security: Limit total entries to prevent DoS (max 10,000 entries)
                                const MAX_ENTRIES: usize = 10_000;
                                let (entries, entry_count) = if entries.len() > MAX_ENTRIES {
                                    tracing::warn!("Directory has {} entries, limiting to {}", entries.len(), MAX_ENTRIES);
                                    (entries.into_iter().take(MAX_ENTRIES).collect::<Vec<_>>(), MAX_ENTRIES)
                                } else {
                                    let count = entries.len();
                                    (entries, count)
                                };

                                // Chunk into batches of 150
                                let mut chunks = vfs::chunk_entries(entries, 150);

                                // Phase VFS-Fix: ALWAYS send at least one chunk, even if empty
                                // This prevents client timeout on empty directories
                                if chunks.is_empty() {
                                    tracing::info!("Directory empty, sending empty chunk");
                                    chunks = vec![vec![]];
                                }

                                let total = chunks.len() as u32;

                                tracing::info!("Sending {} chunks ({} entries)", total, entry_count);

                                for (i, chunk) in chunks.iter().enumerate() {
                                    let msg = NetworkMessage::DirChunk {
                                        chunk_index: i as u32,
                                        total_chunks: total,
                                        entries: chunk.clone(),
                                        has_more: i < chunks.len() - 1,
                                    };
                                    let mut send_lock = send_shared.lock().await;
                                    if let Err(e) = Self::send_message(&mut *send_lock, &msg).await {
                                        tracing::error!("Failed to send DirChunk: {}", e);
                                        break;
                                    }
                                }

                                tracing::info!("ListDir completed: {} chunks sent", total);
                            }
                            Err(e) => {
                                let error_msg = format!("Failed to read directory: {}", e);
                                tracing::error!("{}", error_msg);
                                let mut send_lock = send_shared.lock().await;
                                let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                    comacode_core::types::TerminalEvent::Error {
                                        message: error_msg,
                                    }
                                )).await;
                            }
                        }
                    }
                    // ===== VFS: File Watcher - Phase 3 =====
                    NetworkMessage::WatchDir { path } => {
                        if !authenticated {
                            tracing::warn!("WatchDir received before authentication from {}", peer_addr);
                            break;
                        }

                        tracing::info!("WatchDir request: {}", path);

                        let path_buf = PathBuf::from(&path);

                        // Check if path exists and is a directory
                        if !path_buf.exists() {
                            let error_msg = format!("Path not found: {}", path);
                            tracing::warn!("{}", error_msg);
                            let mut send_lock = send_shared.lock().await;
                            let _ = Self::send_message(&mut *send_lock, &NetworkMessage::WatchError {
                                watcher_id: format!("watch_{}", session_id.unwrap_or(0)),
                                error: error_msg,
                            }).await;
                            break;
                        }

                        if !path_buf.is_dir() {
                            let error_msg = format!("Path is not a directory: {}", path);
                            tracing::warn!("{}", error_msg);
                            let mut send_lock = send_shared.lock().await;
                            let _ = Self::send_message(&mut *send_lock, &NetworkMessage::WatchError {
                                watcher_id: format!("watch_{}", session_id.unwrap_or(0)),
                                error: error_msg,
                            }).await;
                            break;
                        }

                        // Start watching
                        let watcher_id = format!("watch_{}", session_id.unwrap_or(0));
                        let watcher_mgr_clone: Arc<WatcherManager> = Arc::clone(&watcher_mgr);
                        let send_clone = send_shared.clone();

                        // Spawn watch task
                        if let Err(e) = watcher_mgr_clone.watch_directory(
                            watcher_id.clone(),
                            &path_buf,
                            move |event| {
                                let msg = NetworkMessage::FileEvent {
                                    watcher_id: event.watcher_id.clone(),
                                    path: event.path,
                                    event_type: event.event_type,
                                    timestamp: event.timestamp,
                                };

                                // Send event to client
                                let send = send_clone.clone();
                                tokio::spawn(async move {
                                    let mut send_lock = send.lock().await;
                                    let _ = Self::send_message(&mut *send_lock, &msg).await;
                                });
                            },
                        ).await {
                            tracing::error!("Failed to start watcher: {}", e);
                            let mut send_lock = send_shared.lock().await;
                            let _ = Self::send_message(&mut *send_lock, &NetworkMessage::WatchError {
                                watcher_id: watcher_id.clone(),
                                error: format!("Failed to start watcher: {}", e),
                            }).await;
                            break;
                        }

                        // Send WatchStarted confirmation
                        let mut send_lock = send_shared.lock().await;
                        let _ = Self::send_message(&mut *send_lock, &NetworkMessage::WatchStarted {
                            watcher_id,
                        }).await;
                    }
                    NetworkMessage::UnwatchDir { watcher_id } => {
                        if !authenticated {
                            tracing::warn!("UnwatchDir received before authentication from {}", peer_addr);
                            break;
                        }

                        tracing::info!("UnwatchDir request: {}", watcher_id);

                        // Stop watching
                        if let Err(e) = watcher_mgr.unwatch(&watcher_id).await {
                            tracing::warn!("Failed to unwatch {}: {}", watcher_id, e);
                        }
                    }
                    // ===== VFS: File Reading - Phase 2 =====
                    NetworkMessage::ReadFile { path, max_size } => {
                        if !authenticated {
                            tracing::warn!("ReadFile received before authentication from {}", peer_addr);
                            break;
                        }

                        tracing::info!("ReadFile request: {} (max_size: {})", path, max_size);

                        let path_buf = PathBuf::from(&path);

                        // Security: Validate path is within allowed boundaries
                        // Use current directory as allowed_base to prevent path traversal attacks
                        let current_dir = std::env::current_dir()
                            .unwrap_or_else(|_| PathBuf::from("/"));

                        if let Err(e) = crate::vfs::validate_path(&path_buf, &current_dir) {
                            tracing::warn!("ReadFile path validation failed: {}", e);
                            // Return error response
                            let response = NetworkMessage::FileContent {
                                path: path.clone(),
                                content: String::new(),
                                size: 0,
                                truncated: false,
                            };
                            let mut send_lock = send_shared.lock().await;
                            let _ = Self::send_message(&mut *send_lock, &response).await;
                            continue;
                        }

                        let response = match crate::vfs::read_file(&path_buf, max_size).await {
                            Ok(content) => {
                                let size = content.len();
                                NetworkMessage::FileContent {
                                    path: path.clone(),
                                    content,
                                    size,
                                    truncated: false,
                                }
                            }
                            Err(e) => {
                                // Return error as FileContent with empty content
                                tracing::warn!("ReadFile failed: {}", e);
                                NetworkMessage::FileContent {
                                    path: path.clone(),
                                    content: String::new(),
                                    size: 0,
                                    truncated: false,
                                }
                            }
                        };

                        let mut send_lock = send_shared.lock().await;
                        let _ = Self::send_message(&mut *send_lock, &response).await;
                    }
                    // ===== Multi-Session Support - Phase 04 =====
                    NetworkMessage::Session(session_msg) => {
                        if !authenticated {
                            tracing::warn!("Session message received before authentication from {}", peer_addr);
                            break;
                        }

                        tracing::info!("Session message: {:?}", std::mem::discriminant(&session_msg));

                        match session_msg {
                            SessionMessage::CreateSession { project_path, session_id } => {
                                tracing::info!("CreateSession: project={}, session={}", project_path, session_id);

                                // Validate project path exists
                                let path_buf = PathBuf::from(&project_path);
                                if !path_buf.exists() {
                                    let error_msg = format!("Project path not found: {}", project_path);
                                    tracing::warn!("{}", error_msg);
                                    let mut send_lock = send_shared.lock().await;
                                    let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                        TerminalEvent::Error { message: error_msg },
                                    )).await;
                                    break;
                                }

                                // Build terminal config
                                let mut config = comacode_core::terminal::TerminalConfig::default();
                                if let Some((rows, cols)) = pending_resize {
                                    config.rows = rows;
                                    config.cols = cols;
                                    config.env.push(("COLUMNS".to_string(), cols.to_string()));
                                    config.env.push(("LINES".to_string(), rows.to_string()));
                                }

                                // Create UUID session
                                match session_mgr.create_session_with_uuid(
                                    session_id.clone(),
                                    config,
                                    &project_path,
                                ).await {
                                    Ok(()) => {
                                        // Send SessionCreated event
                                        let mut send_lock = send_shared.lock().await;
                                        let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                            TerminalEvent::session_created(session_id.clone()),
                                        )).await;

                                        tracing::info!("Session {} created for project {}", session_id, project_path);
                                    }
                                    Err(e) => {
                                        tracing::error!("Failed to create session {}: {}", session_id, e);
                                        let mut send_lock = send_shared.lock().await;
                                        let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                            TerminalEvent::Error { message: format!("Failed to create session: {}", e) },
                                        )).await;
                                    }
                                }
                            }
                            SessionMessage::CheckSession { session_id } => {
                                tracing::info!("CheckSession: {}", session_id);

                                let exists = session_mgr.session_exists(&session_id).await;
                                let event = if exists {
                                    TerminalEvent::session_reattach(session_id.clone())
                                } else {
                                    TerminalEvent::session_not_found(session_id.clone())
                                };

                                let mut send_lock = send_shared.lock().await;
                                let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(event)).await;
                            }
                            SessionMessage::SwitchSession { session_id } => {
                                tracing::info!("SwitchSession: {}", session_id);

                                // Check if session exists
                                if !session_mgr.session_exists(&session_id).await {
                                    let mut send_lock = send_shared.lock().await;
                                    let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                        TerminalEvent::session_not_found(session_id.clone()),
                                    )).await;
                                    break;
                                }

                                // Phase 05: Stop pump task for previous session
                                if let Some(ref old_session_id) = active_session_id {
                                    tracing::info!("Stopping pump for previous session: {}", old_session_id);
                                    session_mgr.stop_pump_for_session(old_session_id).await;
                                }

                                // Get history buffer
                                let history = session_mgr.get_history(&session_id).await;

                                // Send history if available
                                if !history.is_empty() {
                                    let mut send_lock = send_shared.lock().await;
                                    let _ = Self::send_message(&mut *send_lock, &NetworkMessage::SessionHistory {
                                        session_id: session_id.clone(),
                                        lines: history,
                                    }).await;
                                }

                                // Update active session
                                active_session_id = Some(session_id.clone());

                                // Phase 05: Start TaggedOutput pump for new active session
                                if let Some(output_rx) = session_mgr.take_output_rx_for_session(&session_id).await {
                                    let history_tx = session_mgr.get_history_sender(&session_id).await;
                                    let session_key = session_id.clone();
                                    let send_clone = send_shared.clone();

                                    let pump_handle = tokio::spawn(async move {
                                        let mut send_lock = send_clone.lock().await;
                                        if let Err(e) = pump_pty_to_quic_tagged(
                                            // Convert Receiver to AsyncRead
                                            {
                                                let stream = tokio_stream::wrappers::ReceiverStream::new(output_rx)
                                                    .map(Ok::<_, std::io::Error>);
                                                tokio_util::io::StreamReader::new(stream)
                                            },
                                            &mut *send_lock,
                                            session_key.clone(),
                                            history_tx,
                                        ).await {
                                            tracing::error!("TaggedOutput pump error for session {}: {}", session_key, e);
                                        }
                                        tracing::debug!("TaggedOutput pump completed for session {}", session_key);
                                    });

                                    // Store pump handle
                                    session_mgr.set_pump_handle_for_session(&session_id, pump_handle).await;
                                    tracing::info!("TaggedOutput pump started for session {}", session_id);
                                } else {
                                    tracing::warn!("No PTY output receiver available for session {} (pump already started?)", session_id);
                                }

                                // Send SessionSwitched event
                                let mut send_lock = send_shared.lock().await;
                                let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                    TerminalEvent::session_switched(session_id.clone()),
                                )).await;

                                tracing::info!("Switched to active session: {}", session_id);
                            }
                            SessionMessage::CloseSession { session_id } => {
                                tracing::info!("CloseSession: {}", session_id);

                                match session_mgr.close_session(&session_id).await {
                                    Ok(()) => {
                                        // Send SessionClosed event
                                        let mut send_lock = send_shared.lock().await;
                                        let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                            TerminalEvent::session_closed(session_id.clone()),
                                        )).await;

                                        // Clear active session if it was the closed one
                                        if active_session_id.as_ref() == Some(&session_id) {
                                            active_session_id = None;
                                        }

                                        tracing::info!("Session {} closed", session_id);
                                    }
                                    Err(e) => {
                                        tracing::error!("Failed to close session {}: {}", session_id, e);
                                        let mut send_lock = send_shared.lock().await;
                                        let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                            TerminalEvent::Error { message: format!("Failed to close session: {}", e) },
                                        )).await;
                                    }
                                }
                            }
                            SessionMessage::ListSessions => {
                                tracing::info!("ListSessions requested");

                                let sessions = session_mgr.list_uuid_sessions().await;
                                let response_text = format!("Active sessions:\n{}", sessions.join("\n"));

                                let mut send_lock = send_shared.lock().await;
                                let _ = Self::send_message(&mut *send_lock, &NetworkMessage::Event(
                                    TerminalEvent::Output { data: response_text.into_bytes() },
                                )).await;
                            }
                        }
                    }
                    _ => {
                        tracing::warn!("Unhandled message type");
                    }
                }
            }
        }

        // Cleanup session on disconnect
        if let Some(id) = session_id {
            let _ = session_mgr.cleanup_session(id).await;
        }

        // Wait for PTY pump task to complete
        if let Some(task) = pty_task {
            let _ = tokio::time::timeout(Duration::from_secs(2), task).await;
        }

        Ok(())
    }

    /// Spawn session with terminal configuration
    ///
    /// Shared helper for Input and Command message handlers.
    /// Creates PTY session, applies resize, spawns output pump task.
    async fn spawn_session_with_config(
        session_mgr: &Arc<SessionManager>,
        pending_resize: Option<(u16, u16)>,
        pty_task: &mut Option<tokio::task::JoinHandle<()>>,
        session_id: &mut Option<u64>,
        send_shared: &Arc<Mutex<quinn::SendStream>>,
        initial_data: &[u8],
    ) -> Result<()> {
        let mut config = comacode_core::terminal::TerminalConfig::default();

        // Apply terminal size from earlier Resize message
        if let Some((rows, cols)) = pending_resize {
            config.rows = rows;
            config.cols = cols;
            // Env vars: Zsh reads COLUMNS/LINES before querying PTY driver
            config.env.push(("COLUMNS".to_string(), cols.to_string()));
            config.env.push(("LINES".to_string(), rows.to_string()));
            // Hide % marker if Zsh thinks line is incomplete
            config.env.push(("PROMPT_EOL_MARK".to_string(), "".to_string()));
        }

        match session_mgr.create_session(config).await {
            Ok(id) => {
                *session_id = Some(id);
                tracing::info!("Created session {} for connection", id);

                // Resize PTY to match terminal size
                // This syncs the PTY driver with env vars
                if let Some((rows, cols)) = pending_resize {
                    tracing::info!("Resize PTY: {}x{}", rows, cols);
                    let _ = session_mgr.resize_session(id, rows, cols).await;
                }

                // Spawn PTY->QUIC pump task
                if let Some(pty_reader) = session_mgr.get_pty_reader(id).await {
                    let send_clone = send_shared.clone();
                    *pty_task = Some(tokio::spawn(async move {
                        let mut send_lock = send_clone.lock().await;
                        if let Err(e) = pump_pty_to_quic(pty_reader, &mut *send_lock).await {
                            tracing::error!("PTY->QUIC pump error: {}", e);
                        }
                        tracing::debug!("PTY->QUIC pump completed");
                    }));
                    tracing::info!("PTY->QUIC pump task spawned for session {}", id);
                } else {
                    tracing::warn!("Failed to get PTY reader for session {}", id);
                }

                // Write initial data if non-empty
                if !initial_data.is_empty() {
                    let _ = session_mgr.write_to_session(id, initial_data).await;
                }

                Ok(())
            }
            Err(e) => {
                tracing::error!("Failed to create session: {}", e);
                Err(e)
            }
        }
    }

    /// Send message to stream
    async fn send_message(
        send: &mut quinn::SendStream,
        msg: &NetworkMessage,
    ) -> Result<()> {
        let encoded = MessageCodec::encode(msg)?;
        send.write_all(&encoded).await?;
        Ok(())
    }

    /// Try to decode a message from buffer
    ///
    /// Returns Some((message, remaining_bytes)) if successful
    /// Returns None if buffer is incomplete
    fn try_decode_message(buf: &[u8]) -> Option<(NetworkMessage, &[u8])> {
        if buf.len() < 4 {
            return None;
        }

        let len = u32::from_be_bytes([buf[0], buf[1], buf[2], buf[3]]) as usize;

        // Validate size (prevent DoS)
        if len > 16 * 1024 * 1024 {
            tracing::error!("Message too large: {} bytes", len);
            return None;
        }

        if buf.len() < 4 + len {
            // Incomplete message
            return None;
        }

        let msg_buf = &buf[..4 + len];
        let remaining = &buf[4 + len..];

        match MessageCodec::decode(msg_buf) {
            Ok(msg) => Some((msg, remaining)),
            Err(e) => {
                tracing::error!("Failed to decode message: {}", e);
                // Skip this message and continue
                Some((NetworkMessage::Close, remaining))
            }
        }
    }

    /// Get session manager reference
    #[allow(dead_code)]
    pub fn session_manager(&self) -> Arc<SessionManager> {
        Arc::clone(&self.session_mgr)
    }

    /// Shutdown server
    #[allow(dead_code)]
    pub async fn shutdown(self) -> Result<()> {
        if let Some(tx) = self.shutdown_tx {
            let _ = tx.send(());
        }
        self.endpoint.close(0u32.into(), b"Server shutdown");
        Ok(())
    }
}

/// Generate self-signed TLS certificate with keypair
fn generate_cert_with_keypair() -> Result<(CertificateDer<'static>, KeyPair)> {
    use rcgen;

    // Simple self-signed certificate generation
    let cert = rcgen::generate_simple_self_signed(vec!["Comacode".to_string()])
        .context("Failed to generate certificate")?;

    Ok((
        CertificateDer::from(cert.cert.der().to_vec()),
        cert.key_pair,
    ))
}

================
File: hostagent/src/ratelimit.rs
================
//! Rate limiting and IP banning for Phase E03 Security Hardening
//!
//! # RateLimiterStore
//!
//! Uses governor crate's Keyed state for per-IP rate limiting.
//! Tracks auth failures separately to ban repeat offenders.
//!
//! ## Architecture
//!
//! - **Keyed RateLimiter**: Governor automatically manages IP  bucket map
//! - **Auth Failures**: Separate HashMap tracks failed auth attempts
//! - **Ban List**: HashSet of permanently banned IPs
//!
//! ## Keyed vs NotKeyed (Phase E03 Fix)
//!
//! **Before (Wrong)**: HashMap<IpAddr, RateLimiter<NotKeyed, ...>>
//! - Manual map management
//! - No automatic cleanup
//! - Need RwLock for map access
//!
//! **After (Correct)**: RateLimiter<IpAddr, Keyed<IpAddr>, ...>
//! - Governor manages IP  bucket automatically
//! - Automatic GC of old buckets
//! - Direct check_key() API

use comacode_core::CoreError;
use governor::{
    clock::DefaultClock,
    state::keyed::DefaultKeyedStateStore,
    Quota, RateLimiter,
};
use std::collections::{HashMap, HashSet};
use std::net::IpAddr;
use std::sync::Arc;
use tokio::sync::RwLock;
use nonzero_ext::nonzero;

/// Rate limit: 5 connection attempts per minute
const RATE_LIMIT: u32 = 5;

/// Auth failures before permanent ban
const AUTH_FAIL_THRESHOLD: u32 = 3;

/// Rate limiting and IP banning store
///
/// Uses governor's keyed rate limiter for per-IP connection tracking.
/// Tracks auth failures separately to ban after repeated failed attempts.
#[derive(Clone)]
#[allow(dead_code)]
pub struct RateLimiterStore {
    /// Governor keyed limiter - auto-manages per-IP buckets
    limiter: Arc<RateLimiter<IpAddr, DefaultKeyedStateStore<IpAddr>, DefaultClock>>,
    /// Auth failure tracker - separate from rate limit
    auth_failures: Arc<RwLock<HashMap<IpAddr, u32>>>,
    /// Permanently banned IPs
    banned_ips: Arc<RwLock<HashSet<IpAddr>>>,
}

#[allow(dead_code)]
impl RateLimiterStore {
    /// Create new rate limiter store
    pub fn new() -> Self {
        let quota = Quota::per_minute(nonzero!(RATE_LIMIT));
        Self {
            limiter: Arc::new(RateLimiter::keyed(quota)),
            auth_failures: Arc::new(RwLock::new(HashMap::new())),
            banned_ips: Arc::new(RwLock::new(HashSet::new())),
        }
    }

    /// Check if IP is banned
    pub async fn is_banned(&self, ip: IpAddr) -> bool {
        self.banned_ips.read().await.contains(&ip)
    }

    /// Ban IP address permanently
    pub async fn ban_ip(&self, ip: IpAddr) {
        self.banned_ips.write().await.insert(ip);
        tracing::warn!("Banned IP: {} (auth failures)", ip);
    }

    /// Check rate limit for IP
    ///
    /// Returns error if:
    /// - IP is banned
    /// - Rate limit exceeded
    pub async fn check(&self, ip: IpAddr) -> Result<(), CoreError> {
        // Check ban list first
        if self.is_banned(ip).await {
            return Err(CoreError::IpBanned { ip });
        }

        // Check rate limit - governor creates bucket automatically
        self.limiter.check_key(&ip)
            .map_err(|_| CoreError::RateLimitExceeded)
    }

    /// Record authentication failure
    ///
    /// Tracks failed auth attempts and bans IP after threshold.
    /// This is separate from rate limiting to prevent brute force token attacks.
    ///
    /// # Security Rationale
    ///
    /// Without this, attacker could:
    /// - Connect  rate_limit_check  send_hello  WRONG_TOKEN  disconnect
    /// - Repeat infinitely (rate limit only counts connections, not auth attempts)
    ///
    /// With this, attacker gets banned after 3 failed token attempts.
    pub async fn record_auth_failure(&self, ip: IpAddr) -> Result<(), CoreError> {
        let mut failures = self.auth_failures.write().await;
        let count = failures.entry(ip).or_insert(0);
        *count += 1;

        tracing::warn!("Auth failure count for {}: {}", ip, count);

        if *count >= AUTH_FAIL_THRESHOLD {
            drop(failures);
            self.ban_ip(ip).await;
            Err(CoreError::IpBanned { ip })
        } else {
            Ok(())
        }
    }

    /// Reset auth failure counter (call on successful auth)
    pub async fn reset_auth_failures(&self, ip: IpAddr) {
        self.auth_failures.write().await.remove(&ip);
    }

    /// Get current auth failure count for IP
    pub async fn auth_failure_count(&self, ip: IpAddr) -> u32 {
        self.auth_failures.read().await.get(&ip).copied().unwrap_or(0)
    }

    /// Get count of banned IPs
    pub async fn banned_count(&self) -> usize {
        self.banned_ips.read().await.len()
    }

    /// Cleanup old auth failure entries
    ///
    /// TODO: Implement TTL-based cleanup (Phase 05)
    /// For now, entries persist until restart
    pub async fn cleanup_auth_failures(&self) {
        // Future: Remove entries older than X minutes
    }
}

impl Default for RateLimiterStore {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{Ipv4Addr, Ipv6Addr};

    fn test_ip_v4() -> IpAddr {
        IpAddr::V4(Ipv4Addr::new(192, 168, 1, 1))
    }

    fn test_ip_v6() -> IpAddr {
        IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1))
    }

    #[tokio::test]
    async fn test_rate_limiter_new() {
        let store = RateLimiterStore::new();
        assert_eq!(store.banned_count().await, 0);
        assert!(!store.is_banned(test_ip_v4()).await);
    }

    #[tokio::test]
    async fn test_check_rate_limit_under_limit() {
        let store = RateLimiterStore::new();
        let ip = test_ip_v4();

        // Should allow 5 requests
        for _ in 0..5 {
            assert!(store.check(ip).await.is_ok());
        }
    }

    #[tokio::test]
    async fn test_check_rate_limit_exceeded() {
        let store = RateLimiterStore::new();
        let ip = test_ip_v4();

        // Exhaust rate limit (5 attempts)
        for _ in 0..5 {
            let _ = store.check(ip).await;
        }

        // Next request should fail
        let result = store.check(ip).await;
        assert!(matches!(result, Err(CoreError::RateLimitExceeded)));
    }

    #[tokio::test]
    async fn test_ban_ip() {
        let store = RateLimiterStore::new();
        let ip = test_ip_v4();

        assert!(!store.is_banned(ip).await);
        store.ban_ip(ip).await;
        assert!(store.is_banned(ip).await);

        // Banned IP should fail check
        let result = store.check(ip).await;
        assert!(matches!(result, Err(CoreError::IpBanned { .. })));
    }

    #[tokio::test]
    async fn test_auth_failure_tracking() {
        let store = RateLimiterStore::new();
        let ip = test_ip_v4();

        assert_eq!(store.auth_failure_count(ip).await, 0);

        // First failure
        let result = store.record_auth_failure(ip).await;
        assert!(result.is_ok());
        assert_eq!(store.auth_failure_count(ip).await, 1);

        // Second failure
        let result = store.record_auth_failure(ip).await;
        assert!(result.is_ok());
        assert_eq!(store.auth_failure_count(ip).await, 2);

        // Third failure - should ban
        let result = store.record_auth_failure(ip).await;
        assert!(matches!(result, Err(CoreError::IpBanned { .. })));
        assert!(store.is_banned(ip).await);
    }

    #[tokio::test]
    async fn test_reset_auth_failures() {
        let store = RateLimiterStore::new();
        let ip = test_ip_v4();

        store.record_auth_failure(ip).await.unwrap();
        assert_eq!(store.auth_failure_count(ip).await, 1);

        store.reset_auth_failures(ip).await;
        assert_eq!(store.auth_failure_count(ip).await, 0);
    }

    #[tokio::test]
    async fn test_multiple_ips_tracked_separately() {
        let store = RateLimiterStore::new();
        let ip1 = test_ip_v4();
        let ip2 = test_ip_v6();

        store.record_auth_failure(ip1).await.unwrap();
        assert_eq!(store.auth_failure_count(ip1).await, 1);
        assert_eq!(store.auth_failure_count(ip2).await, 0);

        store.record_auth_failure(ip2).await.unwrap();
        assert_eq!(store.auth_failure_count(ip1).await, 1);
        assert_eq!(store.auth_failure_count(ip2).await, 1);
    }

    #[tokio::test]
    async fn test_clone_store() {
        let store1 = RateLimiterStore::new();
        let ip = test_ip_v4();
        let store2 = store1.clone();

        store1.ban_ip(ip).await;
        assert!(store2.is_banned(ip).await);
    }
}

================
File: hostagent/src/session.rs
================
//! Session management for multiple PTY instances
//!
//! Manages lifecycle of PTY sessions with automatic cleanup.
//! Phase 04: Extended to support UUID-based sessions with history buffers.
//! Phase 05: Added PTY pump lifecycle management with TaggedOutput support.

use anyhow::{Context, Result};
use bytes::Bytes;
use crate::pty::PtySession;
use comacode_core::terminal::TerminalConfig;
use std::collections::{HashMap, VecDeque};
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use tokio::io::AsyncReadExt;
use tokio::sync::{mpsc, Mutex};
use tokio_stream::StreamExt;
use tokio_stream::wrappers::ReceiverStream;
use tokio_util::io::StreamReader;

/// Session data with UUID key (Phase 04/05)
pub struct SessionData {
    /// PTY session handle
    pub pty_session: Arc<Mutex<PtySession>>,
    /// History buffer (last 100 lines) for inactive sessions
    pub history: VecDeque<String>,
    /// History channel receiver (for pump task to push lines)
    history_rx: tokio::sync::mpsc::Receiver<String>,
    /// Terminal configuration
    pub config: TerminalConfig,
    /// Working directory (project path)
    pub working_dir: String,

    // Phase 05: PTY pump lifecycle management
    /// PTY output receiver (taken when spawning pump task)
    output_rx: Option<tokio::sync::mpsc::Receiver<Bytes>>,
    /// Pump task handle (for aborting on session switch)
    pump_handle: Option<tokio::task::JoinHandle<()>>,
    /// Abort handle for force-stopping pump task
    abort_handle: Option<tokio::task::AbortHandle>,
}

impl SessionData {
    /// Create new session data (Phase 05: with output_rx)
    pub fn new(
        pty_session: Arc<Mutex<PtySession>>,
        config: TerminalConfig,
        working_dir: String,
        history_rx: tokio::sync::mpsc::Receiver<String>,
        output_rx: tokio::sync::mpsc::Receiver<Bytes>,
    ) -> Self {
        Self {
            pty_session,
            history: VecDeque::with_capacity(100),
            history_rx,
            config,
            working_dir,
            output_rx: Some(output_rx),
            pump_handle: None,
            abort_handle: None,
        }
    }

    /// Take PTY output receiver (consumes the receiver, returns None on subsequent calls)
    pub fn take_output_rx(&mut self) -> Option<tokio::sync::mpsc::Receiver<Bytes>> {
        self.output_rx.take()
    }

    /// Set pump task handle
    pub fn set_pump_handle(&mut self, handle: tokio::task::JoinHandle<()>) {
        self.abort_handle = Some(handle.abort_handle());
        self.pump_handle = Some(handle);
    }

    /// Stop pump task if running
    pub async fn stop_pump(&mut self) {
        if let Some(handle) = self.pump_handle.take() {
            if !handle.is_finished() {
                handle.abort();
                // Wait for task to actually stop
                let _ = tokio::time::timeout(
                    tokio::time::Duration::from_secs(1),
                    handle
                ).await;
            }
        }
        self.abort_handle = None;
    }

    /// Check if pump task is running
    pub fn is_pump_running(&self) -> bool {
        if let Some(ref handle) = self.pump_handle {
            !handle.is_finished()
        } else {
            false
        }
    }

    /// Add line to history (max 100 lines)
    pub fn add_history_line(&mut self, line: String) {
        if self.history.len() >= 100 {
            self.history.pop_front();
        }
        self.history.push_back(line);
    }
}

/// Session manager for PTY instances
pub struct SessionManager {
    /// Active sessions (legacy u64 ID -> PTY)
    /// Phase 04: Kept for backward compatibility during transition
    sessions_legacy: Arc<Mutex<HashMap<u64, Arc<Mutex<PtySession>>>>>,
    /// Output receivers (legacy u64 ID -> Receiver)
    outputs_legacy: Arc<Mutex<HashMap<u64, mpsc::Receiver<Bytes>>>>,
    /// Next session ID (legacy)
    next_id: Arc<AtomicU64>,

    /// UUID-based sessions (Phase 04)
    sessions_uuid: Arc<Mutex<HashMap<String, SessionData>>>,

    /// History senders for pump tasks (Phase 04: P0 fix)
    /// Maps session_id -> history channel sender
    history_senders: Arc<Mutex<HashMap<String, tokio::sync::mpsc::Sender<String>>>>,
}

impl SessionManager {
    /// Create new session manager
    pub fn new() -> Self {
        Self {
            sessions_legacy: Default::default(),
            outputs_legacy: Default::default(),
            next_id: Arc::new(AtomicU64::new(1)),
            sessions_uuid: Default::default(),
            history_senders: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    // ===== Legacy u64-based API (backward compatibility) =====

    /// Create new PTY session (legacy)
    pub async fn create_session(&self, config: TerminalConfig) -> Result<u64> {
        let id = self.next_id.fetch_add(1, Ordering::SeqCst);
        let (session, output_rx) = PtySession::spawn(id, config)
            .with_context(|| format!("Failed to create PTY session {}", id))?;

        let mut sessions = self.sessions_legacy.lock().await;
        let mut outputs = self.outputs_legacy.lock().await;

        sessions.insert(id, session);
        outputs.insert(id, output_rx);

        tracing::info!("Created PTY session {}", id);
        Ok(id)
    }

    /// Get session by ID (legacy)
    #[allow(dead_code)]
    pub async fn get_session(&self, id: u64) -> Option<Arc<Mutex<PtySession>>> {
        let sessions = self.sessions_legacy.lock().await;
        sessions.get(&id).cloned()
    }

    /// Write to session (legacy)
    pub async fn write_to_session(&self, id: u64, data: &[u8]) -> Result<()> {
        let sessions = self.sessions_legacy.lock().await;
        if let Some(session) = sessions.get(&id) {
            let mut sess = session.lock().await;
            sess.write(data)
        } else {
            Err(anyhow::anyhow!("Session {} not found", id))
        }
    }

    /// Resize session (legacy)
    pub async fn resize_session(&self, id: u64, rows: u16, cols: u16) -> Result<()> {
        let sessions = self.sessions_legacy.lock().await;
        if let Some(session) = sessions.get(&id) {
            let mut sess = session.lock().await;
            sess.resize(rows, cols)
        } else {
            Err(anyhow::anyhow!("Session {} not found", id))
        }
    }

    /// Cleanup (remove) session (legacy)
    pub async fn cleanup_session(&self, id: u64) -> Result<()> {
        let mut sessions = self.sessions_legacy.lock().await;
        let mut outputs = self.outputs_legacy.lock().await;

        if let Some(session) = sessions.remove(&id) {
            tracing::info!("Cleaning up PTY session {}", id);
            let mut sess = session.lock().await;

            if let Err(e) = sess.kill() {
                tracing::warn!("Failed to kill session {} process: {}", id, e);
            }

            outputs.remove(&id);

            drop(sess);
            Ok(())
        } else {
            Err(anyhow::anyhow!("Session {} not found", id))
        }
    }

    /// Get all active session IDs (legacy)
    #[allow(dead_code)]
    pub async fn list_sessions(&self) -> Vec<u64> {
        let sessions = self.sessions_legacy.lock().await;
        sessions.keys().copied().collect()
    }

    /// Get session count (legacy)
    #[allow(dead_code)]
    pub async fn session_count(&self) -> usize {
        let sessions = self.sessions_legacy.lock().await;
        sessions.len()
    }

    /// Get PTY output as AsyncRead for QUIC forwarding (legacy)
    pub async fn get_pty_reader(&self, session_id: u64) -> Option<impl AsyncReadExt + Unpin + Send> {
        let mut outputs = self.outputs_legacy.lock().await;
        let rx = outputs.remove(&session_id)?;

        let stream = ReceiverStream::new(rx).map(Ok::<_, std::io::Error>);
        Some(StreamReader::new(stream))
    }

    // ===== UUID-based API (Phase 04: Multi-Session Support) =====

    /// Create session with UUID from mobile
    /// Phase 04: Project & Session Management
    /// Phase 05: Added output_rx for TaggedOutput pump support
    ///
    /// Creates PTY session and spawns background history capture task.
    pub async fn create_session_with_uuid(
        &self,
        session_id: String,
        config: TerminalConfig,
        working_dir: &str,
    ) -> Result<()> {
        // Spawn PTY with temporary u64 ID (internally)
        let temp_id = self.next_id.fetch_add(1, Ordering::SeqCst);

        // Build shell command with working directory
        let shell_cmd = format!("cd {} && claude", working_dir);
        let mut config_with_dir = config.clone();
        config_with_dir.shell = shell_cmd;

        let (session, output_rx) = PtySession::spawn(temp_id, config_with_dir.clone())
            .with_context(|| format!("Failed to create PTY session {}", session_id))?;

        // Create history channel (buffer 100 lines, non-blocking)
        let (history_tx, history_rx) = tokio::sync::mpsc::channel::<String>(100);

        let session_key = session_id.clone();
        let mut sessions = self.sessions_uuid.lock().await;
        let session_data = SessionData::new(
            session,
            config_with_dir,
            working_dir.to_string(),
            history_rx,
            output_rx,  // Phase 05: Pass output_rx for pump task
        );

        // Spawn background history capture task
        let sessions_arc = self.sessions_uuid.clone();
        tokio::spawn(async move {
            let mut history_rx = {
                // Get the history receiver from the session
                let mut sessions = sessions_arc.lock().await;
                if let Some(sd) = sessions.get_mut(&session_key) {
                    // Take the receiver and replace with a dummy one
                    let (_tx, new_rx) = tokio::sync::mpsc::channel::<String>(1);
                    std::mem::replace(&mut sd.history_rx, new_rx)
                } else {
                    return; // Session no longer exists
                }
            };

            // Capture history lines and populate buffer
            while let Some(line) = history_rx.recv().await {
                let mut sessions = sessions_arc.lock().await;
                if let Some(sd) = sessions.get_mut(&session_key) {
                    sd.add_history_line(line);
                }
            }
        });

        // Store history_tx for pump tasks to access
        let mut history_senders = self.history_senders.lock().await;
        history_senders.insert(session_id.clone(), history_tx);

        sessions.insert(session_id.clone(), session_data);
        tracing::info!("Created PTY session with UUID {}", session_id);
        Ok(())
    }

    /// Check if session exists (for re-attach logic)
    pub async fn session_exists(&self, session_id: &str) -> bool {
        let sessions = self.sessions_uuid.lock().await;
        sessions.contains_key(session_id)
    }

    /// Get history buffer for session
    pub async fn get_history(&self, session_id: &str) -> Vec<String> {
        let sessions = self.sessions_uuid.lock().await;
        sessions
            .get(session_id)
            .map(|s| s.history.iter().cloned().collect())
            .unwrap_or_default()
    }

    /// Add line to history (max 100 lines)
    #[allow(dead_code)]  // Phase 04: Used for history tracking
    pub async fn add_to_history(&self, session_id: &str, line: String) {
        let mut sessions = self.sessions_uuid.lock().await;
        if let Some(session) = sessions.get_mut(session_id) {
            session.add_history_line(line);
        }
    }

    /// Get PTY session by UUID for direct operations
    #[allow(dead_code)]  // Phase 04: API method for mobile bridge
    pub async fn get_uuid_session(&self, session_id: &str) -> Option<Arc<Mutex<PtySession>>> {
        let sessions = self.sessions_uuid.lock().await;
        sessions.get(session_id).map(|s| s.pty_session.clone())
    }

    /// Write to UUID session
    pub async fn write_to_uuid_session(&self, session_id: &str, data: &[u8]) -> Result<()> {
        let sessions = self.sessions_uuid.lock().await;
        if let Some(session_data) = sessions.get(session_id) {
            let mut sess = session_data.pty_session.lock().await;
            sess.write(data)
        } else {
            Err(anyhow::anyhow!("Session {} not found", session_id))
        }
    }

    /// Resize UUID session
    pub async fn resize_uuid_session(&self, session_id: &str, rows: u16, cols: u16) -> Result<()> {
        let sessions = self.sessions_uuid.lock().await;
        if let Some(session_data) = sessions.get(session_id) {
            let mut sess = session_data.pty_session.lock().await;
            sess.resize(rows, cols)
        } else {
            Err(anyhow::anyhow!("Session {} not found", session_id))
        }
    }

    /// Close UUID session
    /// Phase 05: Stop pump task before cleanup
    pub async fn close_session(&self, session_id: &str) -> Result<()> {
        let mut sessions = self.sessions_uuid.lock().await;

        if let Some(mut session_data) = sessions.remove(session_id) {
            tracing::info!("Closing PTY session {}", session_id);

            // Phase 05: Stop pump task first
            session_data.stop_pump().await;

            let mut sess = session_data.pty_session.lock().await;

            if let Err(e) = sess.kill() {
                tracing::warn!("Failed to kill session {} process: {}", session_id, e);
            }

            drop(sess);
            drop(session_data);

            // Clean up history sender
            let mut history_senders = self.history_senders.lock().await;
            history_senders.remove(session_id);

            Ok(())
        } else {
            Err(anyhow::anyhow!("Session {} not found", session_id))
        }
    }

    /// Get history sender for pump task (Phase 04: P0 fix)
    pub async fn get_history_sender(&self, session_id: &str) -> Option<tokio::sync::mpsc::Sender<String>> {
        let history_senders = self.history_senders.lock().await;
        history_senders.get(session_id).cloned()
    }

    /// List all UUID session IDs
    pub async fn list_uuid_sessions(&self) -> Vec<String> {
        let sessions = self.sessions_uuid.lock().await;
        sessions.keys().cloned().collect()
    }

    /// Get UUID session count
    #[allow(dead_code)]  // Phase 04: API method for mobile bridge
    pub async fn uuid_session_count(&self) -> usize {
        let sessions = self.sessions_uuid.lock().await;
        sessions.len()
    }

    // ===== Phase 05: Pump Lifecycle Management =====

    /// Take PTY output receiver for session (consumes the receiver)
    /// Returns None if receiver already taken or session not found
    pub async fn take_output_rx_for_session(&self, session_id: &str) -> Option<tokio::sync::mpsc::Receiver<Bytes>> {
        let mut sessions = self.sessions_uuid.lock().await;
        sessions.get_mut(session_id)?.take_output_rx()
    }

    /// Set pump task handle for session
    pub async fn set_pump_handle_for_session(&self, session_id: &str, handle: tokio::task::JoinHandle<()>) {
        let mut sessions = self.sessions_uuid.lock().await;
        if let Some(session_data) = sessions.get_mut(session_id) {
            session_data.set_pump_handle(handle);
        }
    }

    /// Stop pump task for session (if running)
    pub async fn stop_pump_for_session(&self, session_id: &str) {
        let mut sessions = self.sessions_uuid.lock().await;
        if let Some(session_data) = sessions.get_mut(session_id) {
            session_data.stop_pump().await;
        }
    }

    /// Check if pump task is running for session
    pub async fn is_pump_running_for_session(&self, session_id: &str) -> bool {
        let sessions = self.sessions_uuid.lock().await;
        sessions.get(session_id)
            .map(|sd| sd.is_pump_running())
            .unwrap_or(false)
    }

    // ===== Shared cleanup =====

    /// Cleanup task that periodically removes dead sessions
    pub fn spawn_cleanup_task(self: Arc<Self>) -> tokio::task::JoinHandle<()> {
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(30));
            loop {
                interval.tick().await;
                self.cleanup_dead_sessions().await;
            }
        })
    }

    /// Remove dead sessions (both legacy and UUID)
    async fn cleanup_dead_sessions(&self) {
        // Cleanup legacy sessions
        {
            let mut sessions = self.sessions_legacy.lock().await;
            let mut outputs = self.outputs_legacy.lock().await;
            let dead_ids: Vec<u64> = {
                let mut dead = Vec::new();
                for (id, session) in sessions.iter() {
                    let mut sess = session.lock().await;
                    if !sess.is_alive() {
                        dead.push(*id);
                    }
                }
                dead
            };

            for id in dead_ids {
                tracing::info!("Auto-cleaning dead legacy session {}", id);
                sessions.remove(&id);
                outputs.remove(&id);
            }
        }

        // Cleanup UUID sessions
        {
            let mut sessions = self.sessions_uuid.lock().await;
            let dead_ids: Vec<String> = {
                let mut dead = Vec::new();
                for (id, session_data) in sessions.iter() {
                    let mut sess = session_data.pty_session.lock().await;
                    if !sess.is_alive() {
                        dead.push(id.clone());
                    }
                }
                dead
            };

            for id in dead_ids {
                tracing::info!("Auto-cleaning dead UUID session {}", id);
                sessions.remove(&id);
            }
        }
    }
}

impl Default for SessionManager {
    fn default() -> Self {
        Self::new()
    }
}

================
File: hostagent/src/snapshot.rs
================
//! Snapshot buffer for terminal output resync
//!
//! Provides ring buffer for storing raw PTY output bytes.
//! Preserves ANSI codes (colors, cursor movement) for accurate terminal replay.

use std::collections::VecDeque;

/// Ring buffer for terminal output snapshot
///
/// # Why Raw Bytes?
/// - Terminal output contains ANSI codes (colors, cursor movement, etc.)
/// - Parsing into String  .lines() would break ANSI structure
/// - Client receives raw bytes  xterm.dart handles ANSI rendering
/// - Reconnection displays correct vim/htop UI instead of garbled text
#[allow(dead_code)]
pub struct SnapshotBuffer {
    buffer: VecDeque<u8>,
    max_bytes: usize,
}

#[allow(dead_code)]
impl SnapshotBuffer {
    /// Create new snapshot buffer
    ///
    /// # Arguments
    /// * `max_bytes` - Maximum buffer size (e.g., 1MB for several screenfuls)
    pub fn new(max_bytes: usize) -> Self {
        Self {
            buffer: VecDeque::with_capacity(max_bytes),
            max_bytes,
        }
    }

    /// Push raw PTY output into buffer
    ///
    /// Automatically evicts oldest bytes when buffer is full.
    pub fn push(&mut self, data: &[u8]) {
        for &byte in data {
            if self.buffer.len() >= self.max_bytes {
                self.buffer.pop_front(); // Remove oldest byte
            }
            self.buffer.push_back(byte);
        }
    }

    /// Get full snapshot for resync (raw bytes)
    ///
    /// Returns all buffered bytes for sending to client on reconnection.
    pub fn get_snapshot(&self) -> Vec<u8> {
        self.buffer.iter().cloned().collect()
    }

    /// Get current buffer size in bytes
    pub fn len(&self) -> usize {
        self.buffer.len()
    }

    /// Check if buffer is empty
    pub fn is_empty(&self) -> bool {
        self.buffer.is_empty()
    }

    /// Clear buffer
    pub fn clear(&mut self) {
        self.buffer.clear();
    }

    /// Get buffer capacity
    pub fn capacity(&self) -> usize {
        self.max_bytes
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_push_and_get_snapshot() {
        let mut buf = SnapshotBuffer::new(100);
        assert!(buf.is_empty());

        buf.push(b"hello");
        assert_eq!(buf.len(), 5);
        assert_eq!(buf.get_snapshot(), b"hello");

        buf.push(b" world");
        assert_eq!(buf.len(), 11);
        assert_eq!(buf.get_snapshot(), b"hello world");
    }

    #[test]
    fn test_buffer_eviction_when_full() {
        let mut buf = SnapshotBuffer::new(10);

        // Fill buffer
        buf.push(b"0123456789"); // 10 bytes
        assert_eq!(buf.len(), 10);

        // Add more - should evict oldest
        buf.push(b"AB");
        assert_eq!(buf.len(), 10);

        // Oldest bytes (0, 1) should be evicted
        let snapshot = buf.get_snapshot();
        assert_eq!(snapshot, b"23456789AB");
    }

    #[test]
    fn test_clear() {
        let mut buf = SnapshotBuffer::new(100);
        buf.push(b"data");
        assert_eq!(buf.len(), 4);

        buf.clear();
        assert!(buf.is_empty());
        assert_eq!(buf.len(), 0);
    }

    #[test]
    fn test_preserve_ansi_codes() {
        let mut buf = SnapshotBuffer::new(100);

        // Simulate terminal output with ANSI color codes
        let output = b"\x1b[31mRed text\x1b[0mNormal text";
        buf.push(output);

        assert_eq!(buf.get_snapshot(), output);
    }

    #[test]
    fn test_large_output_eviction() {
        let mut buf = SnapshotBuffer::new(20);

        // Push multiple chunks
        buf.push(b"AAAABBBB"); // 8 bytes
        buf.push(b"CCCCDDDD"); // 8 bytes (total 16)
        buf.push(b"EEEEFFFF"); // 8 bytes (total 24, evicts first 4)

        // Should only keep last 20 bytes
        assert_eq!(buf.len(), 20);
        let snapshot = buf.get_snapshot();
        // After pushing "AAAABBBB" + "CCCCDDDD" + "EEEEFFFF" (24 bytes),
        // the first 4 bytes "AAAA" are evicted, leaving:
        // "BBBB" + "CCCCDDDD" + "EEEEFFFF" = "BBBBCCCCDDDDEEEEFFFF"
        assert_eq!(snapshot, b"BBBBCCCCDDDDEEEEFFFF");
    }
}

================
File: hostagent/src/vfs_watcher.rs
================
//! File system watcher for VFS real-time sync
//!
//! Phase VFS-3: Monitor directory changes and push events to clients
//! Uses `notify` crate v7 for cross-platform file watching

use anyhow::{Context, Result};
use notify::{Event, EventKind, RecursiveMode, Watcher, EventHandler};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::Mutex;
use tracing::{debug, warn};

use comacode_core::types::FileEventType;

/// Watcher ID type
pub type WatcherId = String;

/// Event handler that forwards events to a callback
struct CallbackHandler {
    watcher_id: WatcherId,
    base_path: PathBuf,
    callback: Box<dyn Fn(WatcherEvent) + Send>,
}

impl CallbackHandler {
    fn new(watcher_id: WatcherId, base_path: PathBuf, callback: Box<dyn Fn(WatcherEvent) + Send>) -> Self {
        Self { watcher_id, base_path, callback }
    }

    fn process_event(&self, event: &Event) -> Option<WatcherEvent> {
        use EventKind::*;

        let event_type = match event.kind {
            Create(_) => FileEventType::Created,
            Modify(_) => FileEventType::Modified,
            Remove(_) => FileEventType::Deleted,
            _ => return None,
        };

        let path = event.paths.first()?;
        let relative_path = path
            .strip_prefix(&self.base_path)
            .ok()
            .and_then(|p| p.to_str())
            .unwrap_or(path.to_str().unwrap_or(""));

        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        Some(WatcherEvent {
            watcher_id: self.watcher_id.clone(),
            path: relative_path.to_string(),
            event_type,
            timestamp,
        })
    }
}

impl EventHandler for CallbackHandler {
    fn handle_event(&mut self, event: Result<Event, notify::Error>) {
        match event {
            Ok(event) => {
                debug!(" [Watcher] Event: {:?} at {:?}", event.kind, event.paths);
                if let Some(fe) = self.process_event(&event) {
                    (self.callback)(fe);
                }
            }
            Err(e) => {
                warn!(" [Watcher] Error: {:?}", e);
            }
        }
    }
}

/// Active watcher instance
struct ActiveWatcher {
    _watcher: notify::RecommendedWatcher,
    path: String,
}

/// Manager for file system watchers
///
/// Phase VFS-3: Handles directory watching
pub struct WatcherManager {
    watchers: Arc<Mutex<HashMap<String, ActiveWatcher>>>,
}

impl WatcherManager {
    /// Create new watcher manager
    pub fn new() -> Self {
        Self {
            watchers: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Start watching a directory
    ///
    /// Returns watcher_id for later cancellation
    pub async fn watch_directory(
        &self,
        watcher_id: String,
        path: &Path,
        on_event: impl Fn(WatcherEvent) + Send + 'static,
    ) -> Result<()> {
        let path = path.to_path_buf();

        // Verify directory exists
        if !path.exists() {
            return Err(anyhow::anyhow!("Path does not exist: {}", path.display()));
        }

        if !path.is_dir() {
            return Err(anyhow::anyhow!("Path is not a directory: {}", path.display()));
        }

        tracing::info!(" [Watcher] Starting watch: {} ({})", path.display(), watcher_id);

        // Create watcher with our handler
        let mut watcher = notify::recommended_watcher(CallbackHandler::new(
            watcher_id.clone(),
            path.clone(),
            Box::new(on_event),
        ))
            .context("Failed to create file watcher")?;

        watcher.watch(&path, RecursiveMode::NonRecursive)?;

        // Store active watcher
        self.watchers.lock().await.insert(
            watcher_id.clone(),
            ActiveWatcher {
                _watcher: watcher,
                path: path.to_string_lossy().to_string(),
            },
        );

        tracing::info!(" [Watcher] Watch started successfully: {}", watcher_id);
        Ok(())
    }

    /// Stop watching a directory
    pub async fn unwatch(&self, watcher_id: &str) -> Result<()> {
        tracing::info!(" [Watcher] Stopping watch: {}", watcher_id);

        let mut watchers = self.watchers.lock().await;
        if watchers.remove(watcher_id).is_some() {
            Ok(())
        } else {
            Err(anyhow::anyhow!("Watcher not found: {}", watcher_id))
        }
    }
}

impl Default for WatcherManager {
    fn default() -> Self {
        Self::new()
    }
}

/// File event produced by watcher
///
/// Public struct for callback
#[derive(Debug, Clone)]
pub struct WatcherEvent {
    pub watcher_id: String,
    pub path: String,
    pub event_type: FileEventType,
    pub timestamp: u64,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_watcher_manager_new() {
        let mgr = WatcherManager::new();
        let _ = &mgr.watchers;
    }
}

================
File: hostagent/src/vfs.rs
================
//! Virtual File System operations
//!
//! Provides directory reading, file listing, and path validation for VFS browsing.

use std::path::Path;
use tokio::fs;
use comacode_core::{types::DirEntry, CoreError};

/// VFS operation result
pub type VfsResult<T> = Result<T, VfsError>;

/// VFS-specific errors
#[derive(Debug)]
pub enum VfsError {
    IoError(String),
    PathNotFound(String),
    NotADirectory(String),
    PermissionDenied(String),
}

impl std::fmt::Display for VfsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VfsError::IoError(e) => write!(f, "I/O error: {}", e),
            VfsError::PathNotFound(p) => write!(f, "Path not found: {}", p),
            VfsError::NotADirectory(p) => write!(f, "Not a directory: {}", p),
            VfsError::PermissionDenied(p) => write!(f, "Permission denied: {}", p),
        }
    }
}

impl std::error::Error for VfsError {}

impl From<VfsError> for CoreError {
    fn from(err: VfsError) -> Self {
        match err {
            VfsError::PathNotFound(p) => CoreError::PathNotFound(p),
            VfsError::NotADirectory(p) => CoreError::NotADirectory(p),
            VfsError::PermissionDenied(p) => CoreError::PermissionDenied(p),
            VfsError::IoError(e) => CoreError::VfsIoError(e),
        }
    }
}

/// Read directory entries from given path
///
/// Returns sorted entries (directories first, then alphabetically by name).
/// Does NOT follow symlinks.
pub async fn read_directory(path: &Path) -> VfsResult<Vec<DirEntry>> {
    // Check if path exists
    if !path.exists() {
        return Err(VfsError::PathNotFound(path.display().to_string()));
    }

    // Check if path is a directory
    if !path.is_dir() {
        return Err(VfsError::NotADirectory(path.display().to_string()));
    }

    let mut entries = Vec::new();
    let mut dir = fs::read_dir(path)
        .await
        .map_err(|e| {
            // Permission denied -> specific error
            if e.kind() == std::io::ErrorKind::PermissionDenied {
                VfsError::PermissionDenied(path.display().to_string())
            } else {
                VfsError::IoError(e.to_string())
            }
        })?;

    while let Some(entry) = dir.next_entry().await
        .map_err(|e| VfsError::IoError(e.to_string()))?
    {
        let metadata = entry.metadata().await
            .map_err(|e| VfsError::IoError(e.to_string()))?;

        let modified = metadata.modified()
            .ok()
            .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
            .map(|d| d.as_secs());

        entries.push(DirEntry {
            name: entry.file_name().to_string_lossy().to_string(),
            path: entry.path().to_string_lossy().to_string(),
            is_dir: metadata.is_dir(),
            is_symlink: metadata.is_symlink(),
            size: Some(metadata.len()),
            modified,
            permissions: None, // Reserved for future
        });
    }

    // Sort: directories first, then by name
    entries.sort_by(|a, b| {
        match (a.is_dir, b.is_dir) {
            (true, false) => std::cmp::Ordering::Less,
            (false, true) => std::cmp::Ordering::Greater,
            _ => a.name.cmp(&b.name),
        }
    });

    Ok(entries)
}

/// Split entries into chunks for streaming
///
/// # Arguments
/// * `entries` - Full list of directory entries
/// * `chunk_size` - Target size per chunk (default: 150)
pub fn chunk_entries(entries: Vec<DirEntry>, chunk_size: usize) -> Vec<Vec<DirEntry>> {
    entries.chunks(chunk_size).map(|c: &[DirEntry]| c.to_vec()).collect()
}

/// Read file content with size limit
///
/// # Arguments
/// * `path` - Path to the file to read
/// * `max_size` - Maximum file size in bytes (default: 100KB)
///
/// Returns file content as String. For binary files, returns UTF-8 lossy decoded content.
pub async fn read_file(path: &Path, max_size: usize) -> VfsResult<String> {
    // Check if path exists
    if !path.exists() {
        return Err(VfsError::PathNotFound(path.display().to_string()));
    }

    // Check if path is a file (not directory)
    if path.is_dir() {
        return Err(VfsError::IoError(format!("Path is a directory: {}", path.display())));
    }

    // Get metadata to check file size
    let metadata = fs::metadata(path)
        .await
        .map_err(|e| {
            if e.kind() == std::io::ErrorKind::PermissionDenied {
                VfsError::PermissionDenied(path.display().to_string())
            } else {
                VfsError::IoError(e.to_string())
            }
        })?;

    // Check file size limit
    if metadata.len() > max_size as u64 {
        return Err(VfsError::IoError(format!(
            "File too large: {} bytes (max: {} bytes)",
            metadata.len(),
            max_size
        )));
    }

    // Read file content
    let content = fs::read(path)
        .await
        .map_err(|e| VfsError::IoError(e.to_string()))?;

    // Convert to string (lossy for binary files)
    Ok(String::from_utf8_lossy(&content).to_string())
}

/// Validate path for security
///
/// Uses canonicalize to resolve all symlinks and relative components.
/// Then checks if the resolved path is still within allowed bounds.
pub fn validate_path(path: &Path, allowed_base: &Path) -> VfsResult<()> {
    // Canonicalize resolves all "..", ".", symlinks
    let canonical = path.canonicalize()
        .map_err(|_| VfsError::PathNotFound(path.display().to_string()))?;

    let allowed_canonical = allowed_base.canonicalize()
        .unwrap_or_else(|_| allowed_base.to_path_buf());

    // Check if canonical path starts with allowed base
    if !canonical.starts_with(&allowed_canonical) {
        return Err(VfsError::PermissionDenied(
            "Path traversal not allowed".to_string()
        ));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_path_valid() {
        // Use /var/run which typically exists on Unix systems
        let base = Path::new("/var/run");
        // Test base path itself
        assert!(validate_path(Path::new("/var/run"), base).is_ok(),
            "Base path should be valid");
    }

    #[test]
    fn test_validate_path_traversal() {
        let base = Path::new("/tmp");
        // These should fail because they escape /tmp
        // Note: canonicalize will fail for non-existent paths, which is ok
        assert!(validate_path(Path::new("/tmp/../etc"), base).is_err());
        assert!(validate_path(Path::new("../etc"), base).is_err());
    }

    #[test]
    fn test_chunk_entries() {
        let entries = vec![
            DirEntry {
                name: "a".to_string(),
                path: "/a".to_string(),
                is_dir: false,
                is_symlink: false,
                size: Some(100),
                modified: None,
                permissions: None,
            };
            10
        ];

        let chunks = chunk_entries(entries, 3);
        assert_eq!(chunks.len(), 4); // 10 / 3 = 4 chunks
        assert_eq!(chunks[0].len(), 3);
        assert_eq!(chunks[3].len(), 1); // last chunk has 1
    }
}

================
File: hostagent/src/web_ui.rs
================
//! Web UI Module for Comacode Host Agent
//!
//! Level 2: Localhost Web Dashboard
//! - QR code pairing page (Catppuccin Mocha theme)
//! - Real-time connection status via SSE
//! - Browser auto-open on startup
//!
//! # SECURITY
//! Web server MUST bind to 127.0.0.1 only (loopback).
//! Never bind to 0.0.0.0 to prevent LAN access to auth tokens.

use anyhow::{Context, Result};
use axum::{
    extract::State,
    response::sse::{Event, Sse},
    response::Html,
};
use comacode_core::QrPayload;
use futures::Stream;
use qrcode_generator::QrCodeEcc;
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Mutex;
use tracing::{info, warn};

/// Web bind address - MUST be loopback only for security
const WEB_BIND_ADDR: &str = "127.0.0.1:3721";

/// Connection status for SSE broadcasting
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ConnectionStatus {
    Waiting,
    Connected { peer: String, session_id: u64 },
    Disconnected,
}

impl ConnectionStatus {
    fn class(&self) -> &'static str {
        match self {
            Self::Waiting => "waiting",
            Self::Connected { .. } => "connected",
            Self::Disconnected => "disconnected",
        }
    }

    fn message(&self) -> String {
        match self {
            Self::Waiting => "Waiting for connection...".to_string(),
            Self::Connected { peer, .. } => format!("Connected to {}", peer),
            Self::Disconnected => "Disconnected".to_string(),
        }
    }
}

/// State shared across web server
#[derive(Clone)]
pub struct WebState {
    status: Arc<Mutex<ConnectionStatus>>,
    qr_payload: Arc<Mutex<Option<QrPayload>>>,
}

impl WebState {
    pub fn new() -> Self {
        Self {
            status: Arc::new(Mutex::new(ConnectionStatus::Waiting)),
            qr_payload: Arc::new(Mutex::new(None)),
        }
    }

    pub async fn set_qr_payload(&self, payload: QrPayload) {
        *self.qr_payload.lock().await = Some(payload);
    }

    #[allow(dead_code)]
    pub async fn update_status(&self, status: ConnectionStatus) {
        *self.status.lock().await = status;
    }
}

/// QR code generator using SVG format
pub struct QrGenerator;

impl QrGenerator {
    /// Generate QR code as SVG with responsive viewBox
    ///
    /// Library auto-calculates QR version based on data length.
    /// Size parameter must be >= actual matrix dimension.
    /// CSS handles max-width: 400px on container.
    pub fn generate_svg(payload: &QrPayload) -> Result<String> {
        let json = payload.to_json()
            .map_err(|e| anyhow::anyhow!("Failed to serialize QR: {}", e))?;

        // Size 200 is safe for all QR versions (largest Version 40 is 177x177)
        // Library sets viewBox automatically based on actual matrix dimension
        qrcode_generator::to_svg_to_string(
            json.as_bytes(),
            QrCodeEcc::Low,
            200,
            None::<&str>,
        ).context("Failed to generate QR SVG")
    }
}

/// HTML template renderer with Catppuccin Mocha theme
pub struct HtmlTemplate;

impl HtmlTemplate {
    /// Render the full pairing page with QR and SSE
    pub fn render(qr_svg: &str, status: &ConnectionStatus) -> String {
        format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comacode Pairing</title>
    <style>
        :root {{
            --ctp-base: #1E1E2E;
            --ctp-surface: #313244;
            --ctp-primary: #CBA6F7;
            --ctp-text: #CDD6F4;
            --ctp-green: #A6E3A1;
            --ctp-red: #F38BA8;
            --ctp-yellow: #F9E2AF;
            --ctp-overlay: #45475A;
        }}
        body {{
            background-color: var(--ctp-base);
            color: var(--ctp-text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }}
        .container {{
            background-color: var(--ctp-surface);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }}
        h1 {{
            color: var(--ctp-primary);
            margin-bottom: 0.5rem;
            font-size: 1.8rem;
        }}
        .subtitle {{
            color: var(--ctp-text);
            opacity: 0.7;
            margin-bottom: 2rem;
            font-size: 0.9rem;
        }}
        .qr-container {{
            background-color: white;
            padding: 1rem;
            border-radius: 8px;
            display: block;
            margin: 0 auto 1.5rem;
            width: 100%;
            max-width: 400px;
        }}
        .qr-container svg {{
            display: block;
            margin: 0 auto;
        }}
        .status {{
            font-size: 1.1rem;
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            background-color: var(--ctp-overlay);
            transition: all 0.3s ease;
        }}
        .status.connected {{ color: var(--ctp-green); }}
        .status.waiting {{ color: var(--ctp-yellow); }}
        .status.disconnected {{ color: var(--ctp-red); }}
        .status.error {{ color: var(--ctp-red); }}
        .status.reconnect {{
            animation: pulse 1.5s infinite;
        }}
        @keyframes pulse {{
            0%, 100% {{ opacity: 1; }}
            50% {{ opacity: 0.5; }}
        }}
        .info {{
            font-size: 0.8rem;
            color: var(--ctp-text);
            opacity: 0.6;
            margin-top: 2rem;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Comacode Pairing</h1>
        <p class="subtitle">Scan with mobile app to connect</p>
        <div class="qr-container">{}</div>
        <div id="status" class="status {}">{}</div>
        <p class="info">Keep this window open while connected</p>
    </div>
    <script>
        const RECONNECT_DELAY = 1000; // Constant 1s for localhost
        let reconnectAttempts = 0;
        let evtSource = null;
        let reconnectTimeout = null;

        function connectSSE() {{
            // Clear any pending reconnect
            if (reconnectTimeout) {{
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }}

            evtSource = new EventSource('/api/status');

            evtSource.onopen = () => {{
                reconnectAttempts = 0;
                const statusEl = document.getElementById('status');
                statusEl.classList.remove('error', 'reconnect');
            }};

            evtSource.onmessage = (event) => {{
                const status = JSON.parse(event.data);
                const statusEl = document.getElementById('status');
                statusEl.textContent = status.message;
                statusEl.className = 'status ' + status.status;
            }};

            evtSource.onerror = () => {{
                evtSource.close();
                reconnectAttempts++;
                const statusEl = document.getElementById('status');

                if (reconnectAttempts > 3) {{
                    statusEl.textContent = 'Connection lost. Reconnecting...';
                    statusEl.classList.add('error', 'reconnect');
                }}

                // Constant 1s backoff - immediate for localhost UX
                reconnectTimeout = setTimeout(connectSSE, RECONNECT_DELAY);
            }};
        }}

        connectSSE();
    </script>
</body>
</html>"#,
            qr_svg,
            status.class(),
            status.message()
        )
    }
}

/// Main pairing page route handler
pub async fn pairing_page(State(state): State<WebState>) -> Result<Html<String>, String> {
    let payload = state.qr_payload.lock().await;
    let status = state.status.lock().await;

    match payload.as_ref() {
        Some(p) => {
            let qr_svg = QrGenerator::generate_svg(p)
                .map_err(|e| format!("QR generation failed: {}", e))?;
            let html = HtmlTemplate::render(&qr_svg, &status);
            Ok(Html(html))
        }
        None => Err("<html><body><h1>Not ready - please wait...</h1></body></html>".to_string()),
    }
}

/// SSE status stream handler
pub async fn status_stream(State(state): State<WebState>) -> Sse<impl Stream<Item = Result<Event, String>>> {
    let stream = async_stream::stream! {
        loop {{
            let status = state.status.lock().await.clone();
            let event = Event::default()
                .json_data(&status)
                .unwrap();
            yield Ok(event);
            tokio::time::sleep(Duration::from_secs(1)).await;
        }}
    };

    Sse::new(stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(30))
            .text("keepalive"),
    )
}

/// Web server for the pairing dashboard
pub struct WebServer {
    state: WebState,
}

impl WebServer {
    pub fn new() -> Self {
        Self {
            state: WebState::new(),
        }
    }

    /// Get the web state for external updates
    pub fn state(&self) -> WebState {
        self.state.clone()
    }

    /// Start the web server on loopback only
    ///
    /// # SECURITY
    /// - Only binds to 127.0.0.1 (loopback)
    /// - Auto-increments port if 3721 is taken
    /// - Returns the actual bound address
    pub async fn start(&self) -> Result<SocketAddr> {
        // SECURITY: Verify bind address is loopback
        let bind_addr: SocketAddr = WEB_BIND_ADDR.parse()
            .context("Invalid web bind address")?;

        assert!(bind_addr.ip().is_loopback(),
            "SECURITY: Web UI MUST bind to loopback only!");

        // Try ports 3721-3730 for fallback
        for port_offset in 0..10 {
            let port = 3721 + port_offset;
            let addr = SocketAddr::new(bind_addr.ip(), port);

            // Create Axum app
            let app = axum::Router::new()
                .route("/", axum::routing::get(pairing_page))
                .route("/api/status", axum::routing::get(status_stream))
                .with_state(self.state.clone());

            // Try to bind
            match tokio::net::TcpListener::bind(addr).await {
                Ok(listener) => {
                    info!("Web server listening on http://{}", addr);

                    // Spawn server task
                    tokio::spawn(async move {
                        axum::serve(
                            listener,
                            app.into_make_service(),
                        ).await.unwrap();
                    });

                    return Ok(addr);
                }
                Err(_e) => {
                    if port_offset == 0 {
                        warn!("Port {} in use, trying next port...", port);
                    }
                    continue;
                }
            }
        }

        Err(anyhow::anyhow!("No available ports for web server (tried 3721-3730)"))
    }

    /// Open browser to the web dashboard
    pub fn open_browser(url: &str) -> Result<()> {
        open::that(url)
            .context("Failed to open browser")
    }
}

impl Default for WebServer {
    fn default() -> Self {
        Self::new()
    }
}

================
File: hostagent/Cargo.toml
================
[package]
name = "hostagent"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true

[[bin]]
name = "hostagent"
path = "src/main.rs"

[dependencies]
# Core shared logic
comacode-core = { path = "../core" }
# Workspace dependencies
tokio = { workspace = true, features = ["sync", "full"] }
anyhow = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
# Terminal (not available on iOS)
portable-pty = { workspace = true, optional = true }
# Bytes for zero-copy
bytes = "1.8"
# QUIC networking
quinn = { workspace = true }
rustls = { version = "0.23", features = ["ring"] }
rcgen = "0.13"
# mDNS
mdns-sd = "0.11"
# CLI
clap = { version = "4.5", features = ["derive"] }
# Security (Phase E03)
governor = { workspace = true }
nonzero_ext = { workspace = true }
# Certificate & QR (Phase E04)
dirs = { workspace = true }
sha2 = { workspace = true }
# Web UI (Level 2)
axum = "0.7"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
qrcode-generator = "4.1"
open = "5.0"
serde = { workspace = true }
serde_json = { workspace = true }
async-stream = "0.3"
futures = "0.3"
# PTY Adapter (Phase 05.1)
tokio-stream = "0.1"
tokio-util = { version = "0.7", features = ["io"] }
# File watching (Phase VFS-3)
notify = "7.0"

[features]
default = ["pty"]
pty = ["portable-pty"]

================
File: mobile_bridge/src/api.rs
================
//! Flutter Rust Bridge API
//!
//! FFI-safe functions for Dart integration
//!
//! Phase 04: Added QUIC client support
//! Phase 04.1: Fixed UB - replaced static mut with once_cell::sync::OnceCell
//! Phase 04.2: Use RwLock<Option<>> for reconnect support
//! Phase VFS-1: Directory listing API
//! Phase VFS-3: File watcher API

use comacode_core::{NetworkMessage, MessageCodec};
use comacode_core::types::FileEventType;
use flutter_rust_bridge::frb;
use once_cell::sync::OnceCell;
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::quic_client::QuicClient;

// Re-export commonly used types for FRB
// These are both imported and re-exported for FRB generated code visibility
pub use comacode_core::{TerminalCommand, TerminalEvent, QrPayload};
pub use comacode_core::types::DirEntry;

/// CryptoProvider initializer (rustls 0.23+ requires runtime init)
///
/// Using OnceCell ensures ring crypto provider is installed exactly once
/// before any QUIC connection is attempted.
static CRYPTO_INIT: OnceCell<()> = OnceCell::new();

/// Initialize the CryptoProvider with ring backend
///
/// This must be called before any rustls operations.
/// Safe to call multiple times - OnceCell ensures it only runs once.
fn init_crypto_provider() {
    CRYPTO_INIT.get_or_init(|| {
        let _ = rustls::crypto::ring::default_provider().install_default();
    });
}

/// Global client instance (thread-safe, reconnectable)
///
/// Using OnceCell<RwLock<Option<>>> allows:
/// - Lazy initialization on first use
/// - Reconnection after failure
/// - Explicit disconnect and reconnect
/// - Thread-safe access in async context
static QUIC_CLIENT: OnceCell<tokio::sync::RwLock<Option<Arc<Mutex<QuicClient>>>>> = OnceCell::new();

/// Connect to remote host
///
/// This is the main FFI entry point for Flutter app.
/// Call this after scanning QR code to get connection parameters.
///
/// # Arguments
/// * `host` - Server IP address
/// * `port` - QUIC server port
/// * `auth_token` - Authentication token from QR scan
/// * `fingerprint` - Certificate fingerprint for TOFU verification
///
/// # Behavior
/// - If already connected: Returns error (call disconnect first)
/// - On success: Stores client for subsequent operations
#[frb]
pub async fn connect_to_host(
    host: String,
    port: u16,
    auth_token: String,
    fingerprint: String,
) -> Result<(), String> {
    // Initialize rustls CryptoProvider first (required for rustls 0.23+)
    init_crypto_provider();

    // Get or init the RwLock
    let lock = QUIC_CLIENT.get_or_init(|| tokio::sync::RwLock::new(None));

    // Check if already connected (read lock)
    {
        let client_guard = lock.read().await;
        if let Some(client_arc) = client_guard.as_ref() {
            let client = client_arc.lock().await;
            if client.is_connected().await {
                return Err(
                    "Already connected. Disconnect first to reconnect.".to_string()
                );
            }
        }
    }

    // Create new client
    let client = Arc::new(Mutex::new(QuicClient::new(fingerprint)));

    // Connect
    {
        let mut client_lock = client.lock().await;
        client_lock.connect(host, port, auth_token).await?;
    }

    // Store client (write lock)
    {
        let mut client_guard = lock.write().await;
        *client_guard = Some(client);
    }

    Ok(())
}

/// Receive next terminal event from server
///
/// Call this in a loop to stream terminal output.
/// Returns when a new event is available.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn receive_terminal_event() -> Result<TerminalEvent, String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.receive_event().await
}

/// Send command to remote terminal
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn send_terminal_command(command: String) -> Result<(), String> {
    tracing::info!(" [FRB] Sending command: '{}'", command);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    let result = client.send_command(command).await;
    match &result {
        Ok(()) => tracing::info!(" [FRB] Command sent successfully"),
        Err(e) => tracing::error!(" [FRB] Command send failed: {}", e),
    }
    result
}

/// Send raw input bytes to remote terminal (pure passthrough)
///
/// Phase 08: Send raw keystrokes directly to PTY without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
///
/// # Arguments
/// * `data` - Raw bytes from stdin (including control chars like 0x03 for Ctrl+C)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn send_raw_input(data: Vec<u8>) -> Result<(), String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.send_raw_input(data).await
}

/// Resize PTY (for screen rotation support)
///
/// Phase 06: Send resize event to update PTY size on server.
/// Call this when device orientation changes.
///
/// # Arguments
/// * `rows` - Number of rows (characters per column)
/// * `cols` - Number of columns (characters per row)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn resize_pty(rows: u16, cols: u16) -> Result<(), String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.resize_pty(rows, cols).await
}

/// Disconnect from host
///
/// Clears the client, allowing reconnect.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn disconnect_from_host() -> Result<(), String> {
    // Get and clear client (write lock)
    let client_arc = {
        let lock = QUIC_CLIENT.get_or_init(|| tokio::sync::RwLock::new(None));
        let mut client_guard = lock.write().await;
        client_guard.take()
            .ok_or_else(|| "Not connected".to_string())?
    };

    // Disconnect (outside lock to avoid deadlock)
    let mut client = client_arc.lock().await;
    client.disconnect().await
}

/// Check if connected
///
/// Returns false if client not initialized or disconnected.
#[frb]
pub async fn is_connected() -> bool {
    let lock = QUIC_CLIENT.get_or_init(|| tokio::sync::RwLock::new(None));
    let client_guard = lock.read().await;

    if let Some(client_arc) = client_guard.as_ref() {
        let client = client_arc.lock().await;
        client.is_connected().await
    } else {
        false
    }
}

/// Helper: Get client reference
///
/// Returns error if not connected.
async fn get_client() -> Result<Arc<Mutex<QuicClient>>, String> {
    let lock = QUIC_CLIENT.get_or_init(|| tokio::sync::RwLock::new(None));
    lock.read()
        .await
        .as_ref()
        .cloned()
        .ok_or_else(|| "Not connected. Call connect_to_host first.".to_string())
}

// ===== Existing encode/decode functions =====

/// Create a new terminal command
#[frb(sync)]
pub fn create_command(text: String) -> TerminalCommand {
    TerminalCommand::new(text)
}

/// Get command ID
#[frb(sync)]
pub fn get_command_id(cmd: &TerminalCommand) -> u64 {
    cmd.id
}

/// Get command text
#[frb(sync)]
pub fn get_command_text(cmd: &TerminalCommand) -> String {
    cmd.text.clone()
}

/// Get command timestamp
#[frb(sync)]
pub fn get_command_timestamp(cmd: &TerminalCommand) -> u64 {
    cmd.timestamp
}

/// Encode terminal command to bytes for network transmission
#[frb]
pub async fn encode_command(cmd: TerminalCommand) -> Result<Vec<u8>, String> {
    MessageCodec::encode(&NetworkMessage::Command(cmd))
        .map_err(|e| e.to_string())
}

/// Encode raw input bytes for network transmission (pure passthrough)
///
/// Phase 08: Encode raw keystrokes without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
#[frb]
pub async fn encode_input(data: Vec<u8>) -> Result<Vec<u8>, String> {
    MessageCodec::encode(&NetworkMessage::Input { data })
        .map_err(|e| e.to_string())
}

/// Encode ping message
#[frb]
pub async fn encode_ping() -> Result<Vec<u8>, String> {
    MessageCodec::encode(&NetworkMessage::ping())
        .map_err(|e| e.to_string())
}

/// Encode resize message
#[frb]
pub async fn encode_resize(rows: u16, cols: u16) -> Result<Vec<u8>, String> {
    MessageCodec::encode(&NetworkMessage::resize(rows, cols))
        .map_err(|e| e.to_string())
}

/// Decode network message from bytes
#[frb]
pub async fn decode_message(data: Vec<u8>) -> Result<String, String> {
    let msg = MessageCodec::decode(&data)
        .map_err(|e| e.to_string())?;

    // Return debug representation for now
    // In production, you'd return a proper Dart-compatible type
    Ok(format!("{:?}", msg))
}

/// Terminal configuration for Flutter
#[frb(sync)]
pub struct TerminalConfig {
    pub rows: u16,
    pub cols: u16,
    pub shell: String,
}

impl Default for TerminalConfig {
    fn default() -> Self {
        Self {
            rows: 24,
            cols: 80,
            shell: "/bin/bash".to_string(),
        }
    }
}

/// Create terminal config with custom size
#[frb(sync)]
pub fn create_terminal_config(rows: u16, cols: u16) -> TerminalConfig {
    TerminalConfig {
        rows,
        cols,
        ..Default::default()
    }
}

// ===== QR Payload functions =====

/// Parse QR payload JSON string
#[frb]
pub fn parse_qr_payload(json: String) -> Result<QrPayload, String> {
    QrPayload::from_json(&json).map_err(|e| e.to_string())
}

/// Get QR payload fields
#[frb(sync)]
pub fn get_qr_ip(payload: &QrPayload) -> String {
    payload.ip.clone()
}

#[frb(sync)]
pub fn get_qr_port(payload: &QrPayload) -> u16 {
    payload.port
}

#[frb(sync)]
pub fn get_qr_fingerprint(payload: &QrPayload) -> String {
    payload.fingerprint.clone()
}

#[frb(sync)]
pub fn get_qr_token(payload: &QrPayload) -> String {
    payload.token.clone()
}

#[frb(sync)]
pub fn get_qr_protocol_version(payload: &QrPayload) -> u32 {
    payload.protocol_version
}

// ===== Terminal Event functions =====

/// Create output event from bytes
#[frb(sync)]
pub fn event_output(data: Vec<u8>) -> TerminalEvent {
    TerminalEvent::output(data)
}

/// Create output event from string
#[frb(sync)]
pub fn event_output_str(s: String) -> TerminalEvent {
    TerminalEvent::output_str(&s)
}

/// Get event data (for Output events)
#[frb(sync)]
pub fn get_event_data(event: &TerminalEvent) -> Vec<u8> {
    match event {
        TerminalEvent::Output { data } => data.clone(),
        _ => Vec::new(),
    }
}

/// Get event error message (for Error events)
#[frb(sync)]
pub fn get_event_error_message(event: &TerminalEvent) -> String {
    match event {
        TerminalEvent::Error { message } => message.clone(),
        _ => String::new(),
    }
}

/// Get event exit code (for Exit events)
#[frb(sync)]
pub fn get_event_exit_code(event: &TerminalEvent) -> i32 {
    match event {
        TerminalEvent::Exit { code } => *code,
        _ => -1,
    }
}

/// Check if event is Output
#[frb(sync)]
pub fn is_event_output(event: &TerminalEvent) -> bool {
    matches!(event, TerminalEvent::Output { .. })
}

/// Check if event is Error
#[frb(sync)]
pub fn is_event_error(event: &TerminalEvent) -> bool {
    matches!(event, TerminalEvent::Error { .. })
}

/// Check if event is Exit
#[frb(sync)]
pub fn is_event_exit(event: &TerminalEvent) -> bool {
    matches!(event, TerminalEvent::Exit { .. })
}

// ===== VFS (Virtual File System) Functions - Phase 1 =====

/// Request directory listing from server
///
/// Sends ListDir message. Server responds with multiple DirChunk messages.
/// Call receive_dir_chunk() in a loop to receive all chunks.
///
/// # Arguments
/// * `path` - Absolute path to list (e.g., "/tmp", "/home/user")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn request_list_dir(path: String) -> Result<(), String> {
    tracing::info!(" [FRB] request_list_dir: {}", path);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.request_list_dir(path).await
}

/// Receive next directory chunk from server (NON-BLOCKING)
///
/// Returns a chunk with entries. Call repeatedly until has_more is false.
/// Returns None if no chunks available yet (server still processing).
///
/// # Returns
/// * `Some((chunk_index, entries, has_more))` - Chunk received
/// * `None` - No chunks available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn receive_dir_chunk() -> Result<Option<(u32, Vec<DirEntry>, bool)>, String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.receive_dir_chunk().await
}

// ===== VFS Directory Listing =====

/// List directory entries using Future API
///
/// Phase VFS-Fix: Refactored from Stream to Future for reliability.
/// Stream API had race condition where onDone fired before onData.
/// Future API is deterministic - data is returned when complete.
///
/// # Arguments
/// * `path` - Directory path to list
///
/// # Returns
/// * `Ok(Vec<DirEntry>)` - All entries in directory
/// * `Err(String)` - Error message
#[frb]
pub async fn list_directory(path: String) -> Result<Vec<DirEntry>, String> {
    use std::time::Duration;

    tracing::info!(" [list_directory] STARTING for path '{}'", path);

    // Get client
    let client_arc = get_client().await.map_err(|e| e.to_string())?;
    let client = client_arc.lock().await;

    // Request listing
    tracing::info!(" [list_directory] Sending request for '{}'", path);
    client.request_list_dir(path.clone()).await?;
    tracing::info!(" [list_directory] Request sent, now polling...");

    // Collect all chunks
    let mut all_entries = Vec::new();
    let mut attempts = 0;
    const MAX_ATTEMPTS: usize = 150; // 3 seconds at 20ms
    const POLL_INTERVAL: Duration = Duration::from_millis(20);
    let mut chunk_count = 0;

    loop {
        tokio::time::sleep(POLL_INTERVAL).await;

        let chunk_result = client.receive_dir_chunk().await?;
        match chunk_result {
            Some((index, entries, has_more)) => {
                chunk_count += 1;
                tracing::info!(
                    " [list_directory] Chunk {}: {} entries, has_more={}, total_so_far={}",
                    index,
                    entries.len(),
                    has_more,
                    all_entries.len() + entries.len()
                );
                all_entries.extend(entries);
                if !has_more {
                    tracing::info!(" [list_directory] Last chunk received (has_more=false)");
                    break;
                }
                attempts = 0; // Reset on success
            }
            None => {
                attempts += 1;
                if attempts >= MAX_ATTEMPTS {
                    tracing::warn!(" [list_directory] TIMEOUT after {} attempts (3 seconds), chunks={}, entries={}",
                        MAX_ATTEMPTS, chunk_count, all_entries.len());
                    break; // Timeout
                }
                // Log every 25 attempts (500ms)
                if attempts % 25 == 0 {
                    tracing::debug!(" [list_directory] Still waiting... {}/{} attempts", attempts, MAX_ATTEMPTS);
                }
            }
        }
    }

    tracing::info!(" [list_directory] DONE: path='{}', chunks={}, entries={}",
        path, chunk_count, all_entries.len());
    Ok(all_entries)
}

/// Stream directory entries (DEPRECATED - for FRB codegen compatibility)
///
/// This function exists only for compatibility with generated code.
/// Use `list_directory()` instead (Future API, no race condition).
///
/// Phase VFS-Fix: Added delay after sink.add() to ensure Dart processes data.
pub fn stream_list_dir(
    path: String,
    sink: crate::frb_generated::StreamSink<Vec<DirEntry>>,
) -> Result<(), String> {
    use std::thread;
    use std::time::Duration;

    let path_clone = path.clone();

    // Spawn thread to convert Future  StreamSink
    thread::spawn(move || {
        let rt = match tokio::runtime::Runtime::new() {
            Ok(r) => r,
            Err(e) => {
                tracing::error!("Failed to create tokio runtime: {}", e);
                return;
            }
        };

        let result = rt.block_on(async {
            list_directory(path_clone).await
        });

        match result {
            Ok(entries) => {
                tracing::info!(" [stream_list_dir] Sending {} entries", entries.len());
                match sink.add(entries) {
                    Ok(_) => {
                        // CRITICAL: Keep thread alive so Dart event loop processes onData
                        // Stream closes when this thread ends, so we must wait
                        tracing::info!(" [stream_list_dir] Data sent, waiting for Dart to process...");
                        thread::sleep(Duration::from_millis(300));
                        tracing::info!(" [stream_list_dir] Done waiting");
                    }
                    Err(_) => {
                        tracing::warn!(" [stream_list_dir] Stream closed by Dart");
                    }
                }
            }
            Err(e) => {
                tracing::error!(" [stream_list_dir] Error: {}", e);
                let _ = sink.add_error(e);
                thread::sleep(Duration::from_millis(300));
            }
        }
    });

    Ok(())
}

// ===== DirEntry helper functions for Dart =====

/// Get entry name
#[frb(sync)]
pub fn get_dir_entry_name(entry: &DirEntry) -> String {
    entry.name.clone()
}

/// Get entry path
#[frb(sync)]
pub fn get_dir_entry_path(entry: &DirEntry) -> String {
    entry.path.clone()
}

/// Check if entry is a directory
#[frb(sync)]
pub fn is_dir_entry_dir(entry: &DirEntry) -> bool {
    entry.is_dir
}

/// Check if entry is a symlink
#[frb(sync)]
pub fn is_dir_entry_symlink(entry: &DirEntry) -> bool {
    entry.is_symlink
}

/// Get entry size (bytes)
#[frb(sync)]
pub fn get_dir_entry_size(entry: &DirEntry) -> Option<u64> {
    entry.size
}

/// Get entry modified timestamp (Unix epoch seconds)
#[frb(sync)]
pub fn get_dir_entry_modified(entry: &DirEntry) -> Option<u64> {
    entry.modified
}

/// Get entry permissions string
#[frb(sync)]
pub fn get_dir_entry_permissions(entry: &DirEntry) -> Option<String> {
    entry.permissions.clone()
}

// ===== VFS File Watcher Functions - Phase 3 =====

/// Request server to watch a directory for changes
///
/// Server will push FileEvent messages when files are created/modified/deleted.
/// Call receive_file_event() in a loop to receive watcher events.
///
/// # Arguments
/// * `path` - Absolute path to watch (e.g., "/tmp", "/home/user/project")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn request_watch_dir(path: String) -> Result<(), String> {
    tracing::info!(" [FRB] request_watch_dir: {}", path);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.request_watch_dir(path).await
}

/// Request server to stop watching a directory
///
/// # Arguments
/// * `watcher_id` - ID of the watcher to stop (returned in WatchStarted event)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn request_unwatch_dir(watcher_id: String) -> Result<(), String> {
    tracing::info!(" [FRB] request_unwatch_dir: {}", watcher_id);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.request_unwatch_dir(watcher_id).await
}

/// File watcher event data (for Dart)
#[derive(Debug, Clone)]
#[frb(sync)]
pub struct FileWatcherEventData {
    /// Event type: "file", "started", or "error"
    pub event_type: String,
    /// Watcher ID (for started/error events)
    pub watcher_id: String,
    /// File path (for file events)
    pub path: String,
    /// File event type: "created", "modified", "deleted", "renamed"
    pub file_event_type: String,
    /// Old name (for rename events only)
    pub old_name: String,
    /// Event timestamp (Unix epoch seconds)
    pub timestamp: u64,
    /// Error message (for error events only)
    pub error: String,
}

impl Default for FileWatcherEventData {
    fn default() -> Self {
        Self {
            event_type: String::new(),
            watcher_id: String::new(),
            path: String::new(),
            file_event_type: String::new(),
            old_name: String::new(),
            timestamp: 0,
            error: String::new(),
        }
    }
}

/// Receive next file watcher event from server (NON-BLOCKING)
///
/// Returns watcher events (FileEvent, WatchStarted, WatchError).
/// Call repeatedly in a loop to process all events.
/// Returns None if no events available yet.
///
/// # Returns
/// * `Some(FileWatcherEventData)` - Event received
/// * `None` - No events available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn receive_file_event() -> Result<Option<FileWatcherEventData>, String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;

    match client.receive_file_event().await? {
        Some(event) => {
            let data = match event {
                crate::quic_client::FileWatcherEventData::FileEvent(e) => FileWatcherEventData {
                    event_type: "file".to_string(),
                    watcher_id: e.watcher_id,
                    path: e.path,
                    file_event_type: match e.event_type {
                        FileEventType::Created => "created".to_string(),
                        FileEventType::Modified => "modified".to_string(),
                        FileEventType::Deleted => "deleted".to_string(),
                        FileEventType::Renamed { ref old_name } => {
                            format!("renamed:{}", old_name)
                        }
                    },
                    old_name: match &e.event_type {
                        FileEventType::Renamed { old_name } => old_name.clone(),
                        _ => String::new(),
                    },
                    timestamp: e.timestamp,
                    error: String::new(),
                },
                crate::quic_client::FileWatcherEventData::Started(e) => FileWatcherEventData {
                    event_type: "started".to_string(),
                    watcher_id: e.watcher_id,
                    ..Default::default()
                },
                crate::quic_client::FileWatcherEventData::Error(e) => FileWatcherEventData {
                    event_type: "error".to_string(),
                    watcher_id: e.watcher_id,
                    error: e.error,
                    ..Default::default()
                },
            };
            Ok(Some(data))
        }
        None => Ok(None),
    }
}

/// Get file event buffer length (for monitoring)
///
/// Returns number of buffered events waiting to be processed.
#[frb]
pub async fn file_event_buffer_len() -> Result<usize, String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    Ok(client.file_event_buffer_len().await)
}

// ===== VFS File Reading Functions - Phase 2 =====

/// Request server to read a file
///
/// Server responds with file content. Call receive_file_content() to get the result.
///
/// # Arguments
/// * `path` - Absolute path to file (e.g., "/tmp/file.txt", "~/Documents/file.md")
/// * `max_size` - Maximum file size in bytes (default: 100KB = 102400)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn request_read_file(path: String, max_size: usize) -> Result<(), String> {
    tracing::info!(" [FRB] request_read_file: {} (max_size: {})", path, max_size);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.request_read_file(path, max_size).await
}

/// File content data (for Dart)
#[derive(Debug, Clone)]
#[frb(sync)]
pub struct FileContentData {
    /// File path
    pub path: String,
    /// File content (UTF-8 string)
    pub content: String,
    /// Content size in bytes
    pub size: usize,
    /// True if file was truncated due to size limit
    pub truncated: bool,
}

impl Default for FileContentData {
    fn default() -> Self {
        Self {
            path: String::new(),
            content: String::new(),
            size: 0,
            truncated: false,
        }
    }
}

/// Receive next file content from server (NON-BLOCKING)
///
/// Returns file content received from server.
/// Call repeatedly in a loop to process all responses.
/// Returns None if no content available yet.
///
/// # Returns
/// * `Some(FileContentData)` - File content received
/// * `None` - No content available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn receive_file_content() -> Result<Option<FileContentData>, String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;

    match client.receive_file_content().await? {
        Some((path, content, size, truncated)) => Ok(Some(FileContentData {
            path,
            content,
            size,
            truncated,
        })),
        None => Ok(None),
    }
}

/// Get file content buffer length (for monitoring)
///
/// Returns number of buffered file contents waiting to be processed.
#[frb]
pub async fn file_content_buffer_len() -> Result<usize, String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    Ok(client.file_content_buffer_len().await)
}

// ===== Multi-Session Management - Phase 04 =====

/// Create a new PTY session with UUID
///
/// Sends CreateSession message to server. Server creates PTY in project directory.
///
/// # Arguments
/// * `project_path` - Absolute path to project directory
/// * `session_id` - UUID string for the session
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn create_session(project_path: String, session_id: String) -> Result<(), String> {
    tracing::info!(" [FRB] create_session: {} at {}", session_id, project_path);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.create_session(project_path, session_id).await
}

/// Check if session exists on server (for re-attach on app restart)
///
/// Sends CheckSession message. Server responds with SessionReAttach or SessionNotFound event.
///
/// # Arguments
/// * `session_id` - UUID string to check
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn check_session(session_id: String) -> Result<(), String> {
    tracing::info!(" [FRB] check_session: {}", session_id);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.check_session(session_id).await
}

/// Switch active session
///
/// Sends SwitchSession message. Server responds with SessionHistory and SessionSwitched event.
/// Only the active session's output is pumped to the client.
///
/// # Arguments
/// * `session_id` - UUID string to switch to
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn switch_session(session_id: String) -> Result<(), String> {
    tracing::info!(" [FRB] switch_session: {}", session_id);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.switch_session(session_id).await
}

/// Close a session
///
/// Sends CloseSession message. Server responds with SessionClosed event.
///
/// # Arguments
/// * `session_id` - UUID string to close
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn close_session(session_id: String) -> Result<(), String> {
    tracing::info!(" [FRB] close_session: {}", session_id);
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.close_session(session_id).await
}

/// List all active sessions
///
/// Sends ListSessions message. Server responds with text list via Output event.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn list_sessions() -> Result<(), String> {
    tracing::info!(" [FRB] list_sessions");
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;
    client.list_sessions().await
}

/// Session history data (for Dart)
#[derive(Debug, Clone)]
#[frb(sync)]
pub struct SessionHistoryData {
    /// Session ID
    pub session_id: String,
    /// History lines (max 100)
    pub lines: Vec<String>,
}

/// Receive session history from server (NON-BLOCKING)
///
/// Returns history buffer for inactive session after switch.
/// Call repeatedly until None is returned.
///
/// # Returns
/// * `Some(SessionHistoryData)` - History received
/// * `None` - No history available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
#[frb]
pub async fn receive_session_history() -> Result<Option<SessionHistoryData>, String> {
    let client_arc = get_client().await?;
    let client = client_arc.lock().await;

    match client.receive_session_history().await? {
        Some((session_id, lines)) => Ok(Some(SessionHistoryData { session_id, lines })),
        None => Ok(None),
    }
}

/// Get active session ID
///
/// Returns the UUID of the currently active session, or None if no session is active.
#[frb]
pub async fn get_active_session_id() -> Option<String> {
    let lock = QUIC_CLIENT.get_or_init(|| tokio::sync::RwLock::new(None));
    let client_guard = lock.read().await;

    if let Some(client_arc) = client_guard.as_ref() {
        let client = client_arc.lock().await;
        client.get_active_session_id().await
    } else {
        None
    }
}

// ===== Vibe Coding Session API =====
//
// Phase 02: Multi-PTY Session support
// These functions allow Flutter to manage multiple PTY sessions

/// Session command for Vibe Coding
///
/// Phase 02: Multi-session management
#[frb]
pub enum SessionCommand {
    /// Create new session
    Create { project_path: String, project_name: String },
    /// Switch active session
    Switch { session_id: String },
    /// Close session
    Close { session_id: String },
    /// List all sessions
    List,
}

/// Session data for Flutter
///
/// Phase 02: Session metadata
#[frb]
pub struct SessionData {
    pub id: String,
    pub project_name: String,
    pub project_path: String,
    pub status: String,
}

/// Execute session command
///
/// Phase 02: Entry point for session management
/// Note: This is a placeholder - actual multi-PTY requires backend session manager
#[frb]
pub async fn session_command(cmd: SessionCommand) -> Result<Vec<SessionData>, String> {
    match cmd {
        SessionCommand::List => {
            // Return empty list for now - Flutter manages sessions locally
            Ok(vec![])
        }
        SessionCommand::Create { project_path, project_name } => {
            // Placeholder - Flutter creates session locally
            tracing::info!("Session create request: {} at {}", project_name, project_path);
            Ok(vec![])
        }
        SessionCommand::Switch { session_id } => {
            tracing::info!("Session switch request: {}", session_id);
            Ok(vec![])
        }
        SessionCommand::Close { session_id } => {
            tracing::info!("Session close request: {}", session_id);
            Ok(vec![])
        }
    }
}

/// Unified Vibe input
///
/// Phase 02: Support for different input types
#[frb]
pub enum VibeInput {
    /// Plain text prompt
    Text { prompt: String },
    /// Special key (arrows, Ctrl+C, etc)
    Key { key_code: String },
    /// Raw bytes
    Raw { data: Vec<u8> },
}

/// Send input to specific session
///
/// Phase 02: Send input to a session
#[frb]
pub async fn send_vibe_input(_session_id: String, input: VibeInput) -> Result<(), String> {
    match input {
        VibeInput::Text { prompt } => {
            send_terminal_command(prompt).await
        }
        VibeInput::Key { key_code } => {
            // Convert key code to terminal escape sequence
            let seq = match key_code.as_str() {
                "ArrowUp" => "\x1b[A",
                "ArrowDown" => "\x1b[B",
                "Enter" => "\r",
                "CtrlC" => "\x03",
                _ => "",
            };
            send_terminal_command(seq.to_string()).await
        }
        VibeInput::Raw { data } => {
            // Send raw bytes
            let text = String::from_utf8_lossy(&data);
            send_terminal_command(text.into_owned()).await
        }
    }
}

// ===== Test functions =====

/// Simple add function for testing FFI
#[frb(sync)]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// Greeting function for testing FFI
#[frb(sync)]
pub fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}

================
File: mobile_bridge/src/bridge.rs
================
//! Mobile bridge output streaming
//!
//! Handles PTY output forwarding from Rust to Flutter UI via channel-based architecture.
//! Similar to hostagent but optimized for mobile use case.

use bytes::Bytes;
use comacode_core::OutputStream;
use flutter_rust_bridge::frb;
use std::sync::Arc;
use tokio::sync::Mutex;

/// Output stream handler for mobile terminal UI
///
/// Manages channel-based streaming of PTY output to Flutter.
pub struct MobileTerminalStream {
    /// Output stream for PTY data
    output_stream: OutputStream,
    /// Receiver for consuming PTY output
    _rx: tokio::sync::mpsc::Receiver<Bytes>,
}

impl MobileTerminalStream {
    /// Create new mobile terminal stream
    pub fn new(capacity: usize) -> Self {
        let (output_stream, rx) = OutputStream::new(capacity);
        Self {
            output_stream,
            _rx: rx,
        }
    }

    /// Send PTY output data to Flutter UI
    pub async fn send_output(&self, data: Bytes) -> Result<(), String> {
        self.output_stream
            .send(data)
            .await
            .map_err(|e| format!("Failed to send output: {}", e))
    }

    /// Get output stream sender for external use
    pub fn sender(&self) -> tokio::sync::mpsc::Sender<Bytes> {
        self.output_stream.sender()
    }

    /// Check buffer capacity for backpressure monitoring
    pub fn remaining_capacity(&self) -> usize {
        self.output_stream.remaining()
    }
}

/// Shared mobile terminal stream manager
pub struct MobileStreamManager {
    streams: Arc<Mutex<std::collections::HashMap<u64, Arc<MobileTerminalStream>>>>,
}

impl MobileStreamManager {
    /// Create new stream manager
    pub fn new() -> Self {
        Self {
            streams: Arc::new(Mutex::new(std::collections::HashMap::new())),
        }
    }

    /// Register new terminal session
    pub async fn register_session(&self, session_id: u64) -> Arc<MobileTerminalStream> {
        let stream = Arc::new(MobileTerminalStream::new(1024));
        let mut streams = self.streams.lock().await;
        streams.insert(session_id, stream.clone());
        stream
    }

    /// Get stream for session
    pub async fn get_stream(&self, session_id: u64) -> Option<Arc<MobileTerminalStream>> {
        let streams = self.streams.lock().await;
        streams.get(&session_id).cloned()
    }

    /// Unregister session
    pub async fn unregister_session(&self, session_id: u64) {
        let mut streams = self.streams.lock().await;
        streams.remove(&session_id);
    }
}

impl Default for MobileStreamManager {
    fn default() -> Self {
        Self::new()
    }
}

// Flutter-friendly FFI functions

/// Create output stream for a terminal session
#[frb]
pub async fn create_output_stream(session_id: u64) -> String {
    // For now, return session ID as confirmation
    // In production, this would return a stream handle
    format!("Stream created for session {}", session_id)
}

/// Send terminal output data (from PTY) to stream
#[frb]
pub async fn send_terminal_output(session_id: u64, data: Vec<u8>) -> Result<(), String> {
    // For MVP, just log the data
    // In production, this would send to the actual stream
    tracing::trace!(
        "Terminal output for session {}: {} bytes",
        session_id,
        data.len()
    );
    Ok(())
}

/// Get current buffer capacity for backpressure monitoring
#[frb]
pub async fn get_buffer_capacity(_session_id: u64) -> usize {
    // For MVP, return default capacity
    // In production, this would query actual stream
    1024
}

/// Get remaining buffer slots
#[frb]
pub async fn get_remaining_capacity(_session_id: u64) -> usize {
    // For MVP, return full capacity
    // In production, this would query actual stream
    1024
}

================
File: mobile_bridge/src/frb_generated.rs
================
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1828486424;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__add_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_a = <i32>::sse_decode(&mut deserializer);
            let api_b = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::add(api_a, api_b))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__connect_to_host_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "connect_to_host",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_host = <String>::sse_decode(&mut deserializer);
            let api_port = <u16>::sse_decode(&mut deserializer);
            let api_auth_token = <String>::sse_decode(&mut deserializer);
            let api_fingerprint = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::connect_to_host(
                            api_host,
                            api_port,
                            api_auth_token,
                            api_fingerprint,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__create_command_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_command",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_text = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::create_command(api_text))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__create_terminal_config_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_terminal_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_rows = <u16>::sse_decode(&mut deserializer);
            let api_cols = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::create_terminal_config(api_rows, api_cols))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__decode_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::decode_message(api_data).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__disconnect_from_host_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "disconnect_from_host",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::disconnect_from_host().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__encode_command_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_command",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cmd = <TerminalCommand>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::encode_command(api_cmd).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__encode_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::encode_input(api_data).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__encode_ping_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_ping",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::encode_ping().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__encode_resize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encode_resize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_rows = <u16>::sse_decode(&mut deserializer);
            let api_cols = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::encode_resize(api_rows, api_cols).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__event_output_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "event_output",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::event_output(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__event_output_str_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "event_output_str",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_s = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::event_output_str(api_s))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__file_event_buffer_len_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "file_event_buffer_len",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::file_event_buffer_len().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__file_watcher_event_data_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "file_watcher_event_data_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::FileWatcherEventData::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__get_command_id_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_command_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cmd = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_cmd_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_cmd, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_cmd_guard = Some(api_cmd.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_cmd_guard = api_cmd_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::get_command_id(&*api_cmd_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_command_text_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_command_text",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cmd = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_cmd_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_cmd, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_cmd_guard = Some(api_cmd.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_cmd_guard = api_cmd_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::get_command_text(&*api_cmd_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_command_timestamp_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_command_timestamp",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_cmd = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_cmd_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_cmd, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_cmd_guard = Some(api_cmd.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_cmd_guard = api_cmd_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_command_timestamp(&*api_cmd_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_dir_entry_modified_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_dir_entry_modified",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entry = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_entry_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_entry, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_entry_guard = Some(api_entry.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_entry_guard = api_entry_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_dir_entry_modified(&*api_entry_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_dir_entry_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_dir_entry_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entry = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_entry_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_entry, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_entry_guard = Some(api_entry.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_entry_guard = api_entry_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_dir_entry_name(&*api_entry_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_dir_entry_path_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_dir_entry_path",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entry = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_entry_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_entry, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_entry_guard = Some(api_entry.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_entry_guard = api_entry_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_dir_entry_path(&*api_entry_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_dir_entry_permissions_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_dir_entry_permissions",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entry = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_entry_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_entry, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_entry_guard = Some(api_entry.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_entry_guard = api_entry_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_dir_entry_permissions(&*api_entry_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_dir_entry_size_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_dir_entry_size",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entry = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_entry_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_entry, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_entry_guard = Some(api_entry.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_entry_guard = api_entry_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_dir_entry_size(&*api_entry_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_event_data_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_event_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_event_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_event, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_event_guard = Some(api_event.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_event_guard = api_event_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::get_event_data(&*api_event_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_event_error_message_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_event_error_message",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_event_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_event, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_event_guard = Some(api_event.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_event_guard = api_event_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_event_error_message(&*api_event_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_event_exit_code_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_event_exit_code",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_event_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_event, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_event_guard = Some(api_event.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_event_guard = api_event_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_event_exit_code(&*api_event_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_qr_fingerprint_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_qr_fingerprint",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_payload_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_payload,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_payload_guard = Some(api_payload.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_payload_guard = api_payload_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_qr_fingerprint(&*api_payload_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_qr_ip_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_qr_ip",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_payload_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_payload,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_payload_guard = Some(api_payload.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_payload_guard = api_payload_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::get_qr_ip(&*api_payload_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_qr_port_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_qr_port",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_payload_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_payload,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_payload_guard = Some(api_payload.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_payload_guard = api_payload_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::get_qr_port(&*api_payload_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_qr_protocol_version_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_qr_protocol_version",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_payload_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_payload,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_payload_guard = Some(api_payload.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_payload_guard = api_payload_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::get_qr_protocol_version(&*api_payload_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__get_qr_token_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_qr_token",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_payload = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_payload_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_payload,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_payload_guard = Some(api_payload.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_payload_guard = api_payload_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::get_qr_token(&*api_payload_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::greet(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_connected_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_connected",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(crate::api::is_connected().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__is_dir_entry_dir_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_dir_entry_dir",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entry = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_entry_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_entry, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_entry_guard = Some(api_entry.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_entry_guard = api_entry_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::is_dir_entry_dir(&*api_entry_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_dir_entry_symlink_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_dir_entry_symlink",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_entry = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_entry_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_entry, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_entry_guard = Some(api_entry.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_entry_guard = api_entry_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::is_dir_entry_symlink(&*api_entry_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_event_error_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_event_error",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_event_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_event, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_event_guard = Some(api_event.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_event_guard = api_event_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::is_event_error(&*api_event_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_event_exit_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_event_exit",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_event_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_event, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_event_guard = Some(api_event.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_event_guard = api_event_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::is_event_exit(&*api_event_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__is_event_output_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_event_output",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_event_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_event, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_event_guard = Some(api_event.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_event_guard = api_event_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::is_event_output(&*api_event_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__parse_qr_payload_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_qr_payload",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::parse_qr_payload(api_json)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__receive_dir_chunk_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "receive_dir_chunk",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::receive_dir_chunk().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__receive_file_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "receive_file_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::receive_file_event().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__receive_terminal_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "receive_terminal_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::receive_terminal_event().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__request_list_dir_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "request_list_dir",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::request_list_dir(api_path).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__request_unwatch_dir_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "request_unwatch_dir",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_watcher_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::request_unwatch_dir(api_watcher_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__request_watch_dir_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "request_watch_dir",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::request_watch_dir(api_path).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__resize_pty_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "resize_pty",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_rows = <u16>::sse_decode(&mut deserializer);
            let api_cols = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::resize_pty(api_rows, api_cols).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__send_raw_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_raw_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::send_raw_input(api_data).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__send_terminal_command_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_terminal_command",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_command = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::send_terminal_command(api_command).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__stream_list_dir_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "stream_list_dir", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
let api_sink = <StreamSink<Vec<DirEntry>,flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse::<_, String>((move ||  {
                         let output_ok = crate::api::stream_list_dir(api_path, api_sink)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__terminal_config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "terminal_config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::TerminalConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for DirEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for QrPayload {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TerminalCommand {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TerminalEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for StreamSink<Vec<DirEntry>, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::FileWatcherEventData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_eventType = <String>::sse_decode(deserializer);
        let mut var_watcherId = <String>::sse_decode(deserializer);
        let mut var_path = <String>::sse_decode(deserializer);
        let mut var_fileEventType = <String>::sse_decode(deserializer);
        let mut var_oldName = <String>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        let mut var_error = <String>::sse_decode(deserializer);
        return crate::api::FileWatcherEventData {
            event_type: var_eventType,
            watcher_id: var_watcherId,
            path: var_path,
            file_event_type: var_fileEventType,
            old_name: var_oldName,
            timestamp: var_timestamp,
            error: var_error,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<DirEntry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<DirEntry>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::FileWatcherEventData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::FileWatcherEventData>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<(u32, Vec<DirEntry>, bool)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(u32, Vec<DirEntry>, bool)>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for (u32, Vec<DirEntry>, bool) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u32>::sse_decode(deserializer);
        let mut var_field1 = <Vec<DirEntry>>::sse_decode(deserializer);
        let mut var_field2 = <bool>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for crate::api::TerminalConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rows = <u16>::sse_decode(deserializer);
        let mut var_cols = <u16>::sse_decode(deserializer);
        let mut var_shell = <String>::sse_decode(deserializer);
        return crate::api::TerminalConfig {
            rows: var_rows,
            cols: var_cols,
            shell: var_shell,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        2 => wire__crate__api__connect_to_host_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__decode_message_impl(port, ptr, rust_vec_len, data_len),
        6 => wire__crate__api__disconnect_from_host_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__api__encode_command_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__encode_input_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__encode_ping_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__encode_resize_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__file_event_buffer_len_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__file_watcher_event_data_default_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        32 => wire__crate__api__is_connected_impl(port, ptr, rust_vec_len, data_len),
        38 => wire__crate__api__parse_qr_payload_impl(port, ptr, rust_vec_len, data_len),
        39 => wire__crate__api__receive_dir_chunk_impl(port, ptr, rust_vec_len, data_len),
        40 => wire__crate__api__receive_file_event_impl(port, ptr, rust_vec_len, data_len),
        41 => wire__crate__api__receive_terminal_event_impl(port, ptr, rust_vec_len, data_len),
        42 => wire__crate__api__request_list_dir_impl(port, ptr, rust_vec_len, data_len),
        43 => wire__crate__api__request_unwatch_dir_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__request_watch_dir_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__resize_pty_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__send_raw_input_impl(port, ptr, rust_vec_len, data_len),
        47 => wire__crate__api__send_terminal_command_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__stream_list_dir_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__terminal_config_default_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__add_impl(ptr, rust_vec_len, data_len),
        3 => wire__crate__api__create_command_impl(ptr, rust_vec_len, data_len),
        4 => wire__crate__api__create_terminal_config_impl(ptr, rust_vec_len, data_len),
        11 => wire__crate__api__event_output_impl(ptr, rust_vec_len, data_len),
        12 => wire__crate__api__event_output_str_impl(ptr, rust_vec_len, data_len),
        15 => wire__crate__api__get_command_id_impl(ptr, rust_vec_len, data_len),
        16 => wire__crate__api__get_command_text_impl(ptr, rust_vec_len, data_len),
        17 => wire__crate__api__get_command_timestamp_impl(ptr, rust_vec_len, data_len),
        18 => wire__crate__api__get_dir_entry_modified_impl(ptr, rust_vec_len, data_len),
        19 => wire__crate__api__get_dir_entry_name_impl(ptr, rust_vec_len, data_len),
        20 => wire__crate__api__get_dir_entry_path_impl(ptr, rust_vec_len, data_len),
        21 => wire__crate__api__get_dir_entry_permissions_impl(ptr, rust_vec_len, data_len),
        22 => wire__crate__api__get_dir_entry_size_impl(ptr, rust_vec_len, data_len),
        23 => wire__crate__api__get_event_data_impl(ptr, rust_vec_len, data_len),
        24 => wire__crate__api__get_event_error_message_impl(ptr, rust_vec_len, data_len),
        25 => wire__crate__api__get_event_exit_code_impl(ptr, rust_vec_len, data_len),
        26 => wire__crate__api__get_qr_fingerprint_impl(ptr, rust_vec_len, data_len),
        27 => wire__crate__api__get_qr_ip_impl(ptr, rust_vec_len, data_len),
        28 => wire__crate__api__get_qr_port_impl(ptr, rust_vec_len, data_len),
        29 => wire__crate__api__get_qr_protocol_version_impl(ptr, rust_vec_len, data_len),
        30 => wire__crate__api__get_qr_token_impl(ptr, rust_vec_len, data_len),
        31 => wire__crate__api__greet_impl(ptr, rust_vec_len, data_len),
        33 => wire__crate__api__is_dir_entry_dir_impl(ptr, rust_vec_len, data_len),
        34 => wire__crate__api__is_dir_entry_symlink_impl(ptr, rust_vec_len, data_len),
        35 => wire__crate__api__is_event_error_impl(ptr, rust_vec_len, data_len),
        36 => wire__crate__api__is_event_exit_impl(ptr, rust_vec_len, data_len),
        37 => wire__crate__api__is_event_output_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<DirEntry> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<DirEntry> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<DirEntry>> for DirEntry {
    fn into_into_dart(self) -> FrbWrapper<DirEntry> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<QrPayload> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<QrPayload> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<QrPayload>> for QrPayload {
    fn into_into_dart(self) -> FrbWrapper<QrPayload> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TerminalCommand> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TerminalCommand> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TerminalCommand>> for TerminalCommand {
    fn into_into_dart(self) -> FrbWrapper<TerminalCommand> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TerminalEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TerminalEvent> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TerminalEvent>> for TerminalEvent {
    fn into_into_dart(self) -> FrbWrapper<TerminalEvent> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::FileWatcherEventData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.event_type.into_into_dart().into_dart(),
            self.watcher_id.into_into_dart().into_dart(),
            self.path.into_into_dart().into_dart(),
            self.file_event_type.into_into_dart().into_dart(),
            self.old_name.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::FileWatcherEventData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::FileWatcherEventData>
    for crate::api::FileWatcherEventData
{
    fn into_into_dart(self) -> crate::api::FileWatcherEventData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::TerminalConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.rows.into_into_dart().into_dart(),
            self.cols.into_into_dart().into_dart(),
            self.shell.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::TerminalConfig {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::TerminalConfig> for crate::api::TerminalConfig {
    fn into_into_dart(self) -> crate::api::TerminalConfig {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for DirEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for QrPayload {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for TerminalCommand {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for TerminalEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for StreamSink<Vec<DirEntry>, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::FileWatcherEventData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.event_type, serializer);
        <String>::sse_encode(self.watcher_id, serializer);
        <String>::sse_encode(self.path, serializer);
        <String>::sse_encode(self.file_event_type, serializer);
        <String>::sse_encode(self.old_name, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
        <String>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<DirEntry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <DirEntry>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::FileWatcherEventData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::FileWatcherEventData>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<(u32, Vec<DirEntry>, bool)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(u32, Vec<DirEntry>, bool)>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for (u32, Vec<DirEntry>, bool) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.0, serializer);
        <Vec<DirEntry>>::sse_encode(self.1, serializer);
        <bool>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for crate::api::TerminalConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.rows, serializer);
        <u16>::sse_encode(self.cols, serializer);
        <String>::sse_encode(self.shell, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_comacode_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDirEntry(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPayload(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalCommand(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTerminalEvent(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;

================
File: mobile_bridge/src/lib.rs
================
mod frb_generated; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */
/// Flutter Rust Bridge for Comacode Mobile

pub mod api;
pub mod bridge;
pub mod quic_client;

pub use quic_client::QuicClient;

// Flutter Rust Bridge generated code will be added here after generation
// flutter_rust_bridge::frb_generated!();

================
File: mobile_bridge/src/quic_client.rs
================
//! QUIC client for Flutter bridge
//!
//! Phase 04: Mobile App - QUIC client with TOFU verification
//! Phase 09: Background receive task - non-blocking event polling
//! Phase VFS-1: Directory listing with DirChunk support
//!
//! ## Implementation Notes
//!
//! Uses Quinn 0.11 + Rustls 0.23 with custom TOFU (Trust On First Use) certificate verifier.
//! The fingerprint is normalized (case-insensitive, separator-agnostic) before comparison.
//!
//! **Background Receive Task:** To prevent blocking Dart isolate's event loop,
//! receive operations run in a background Tokio task. Events are buffered in
//! Arc<Mutex<Vec>> and receive_event() polls from this buffer (non-blocking).

use comacode_core::{TerminalEvent, AuthToken};
use comacode_core::types::DirEntry;
use comacode_core::protocol::MessageCodec;
use comacode_core::types::{NetworkMessage, TerminalCommand, FileEventType, SessionMessage, TaggedOutput};
use quinn::{Endpoint, Connection, SendStream};
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::task::JoinHandle;
use tracing::{info, error, debug, warn};

// Rustls imports for custom certificate verification
use rustls::client::danger::{HandshakeSignatureValid, ServerCertVerified, ServerCertVerifier};
use rustls::crypto::{verify_tls12_signature, verify_tls13_signature};
use rustls::DigitallySignedStruct;
use rustls_pki_types::{CertificateDer, ServerName, UnixTime};

// SHA256 for fingerprint calculation
use sha2::{Digest, Sha256};

/// Custom certificate verifier for TOFU (Trust On First Use)
///
/// This verifier:
/// 1. Calculates SHA256 fingerprint of the server certificate
/// 2. Normalizes both expected and actual fingerprints (case-insensitive, no separators)
/// 3. Compares them for authentication
///
/// This eliminates the need for a CA infrastructure while providing
/// protection against MitM attacks.
#[derive(Debug)]
struct TofuVerifier {
    expected_fingerprint: String,
}

impl TofuVerifier {
    fn new(fingerprint: String) -> Self {
        Self {
            expected_fingerprint: fingerprint,
        }
    }

    /// Normalize fingerprint for comparison
    ///
    /// Handles various formats: "AA:BB:CC", "aa:bb:cc", "AABBCC", "aa-bb-cc"
    /// All become: "AABBCC" (uppercase, no separators)
    fn normalize_fingerprint(fp: &str) -> String {
        fp.chars()
            .filter(|c| c.is_alphanumeric()) // Remove ':', '-', spaces
            .map(|c| c.to_ascii_uppercase()) // Uppercase
            .collect()
    }

    /// Calculate SHA256 fingerprint from certificate
    ///
    /// Returns format: "AA:BB:CC:DD..." (human readable)
    fn calculate_fingerprint(&self, cert: &CertificateDer) -> String {
        let mut hasher = Sha256::new();
        hasher.update(cert.as_ref());
        let result = hasher.finalize();

        result
            .iter()
            .map(|b| format!("{:02X}", b))
            .collect::<Vec<String>>()
            .join(":")
    }
}

impl ServerCertVerifier for TofuVerifier {
    fn verify_server_cert(
        &self,
        end_entity: &CertificateDer<'_>,
        _intermediates: &[CertificateDer<'_>],
        _server_name: &ServerName<'_>,
        _ocsp_response: &[u8],
        _now: UnixTime,
    ) -> Result<ServerCertVerified, rustls::Error> {
        // Normalize both fingerprints before comparison
        let actual_clean = Self::normalize_fingerprint(&self.calculate_fingerprint(end_entity));
        let expected_clean = Self::normalize_fingerprint(&self.expected_fingerprint);

        debug!("Verifying cert - Match: {}", actual_clean == expected_clean);

        if actual_clean == expected_clean {
            Ok(ServerCertVerified::assertion())
        } else {
            // Log only partial fingerprint (first 4 and last 4 chars) for debugging
            let expected_prefix = &expected_clean[..4.min(expected_clean.len())];
            let expected_suffix = if expected_clean.len() > 4 {
                &expected_clean[expected_clean.len()-4..]
            } else {
                ""
            };
            let actual_prefix = &actual_clean[..4.min(actual_clean.len())];
            let actual_suffix = if actual_clean.len() > 4 {
                &actual_clean[actual_clean.len()-4..]
            } else {
                ""
            };

            error!(
                "Fingerprint mismatch! Expected: {}...{}, Got: {}...{}",
                expected_prefix, expected_suffix, actual_prefix, actual_suffix
            );
            Err(rustls::Error::General("Fingerprint mismatch".to_string()))
        }
    }

    // Delegate TLS 1.2 signature verification to ring provider
    fn verify_tls12_signature(
        &self,
        message: &[u8],
        cert: &CertificateDer<'_>,
        dss: &DigitallySignedStruct,
    ) -> Result<HandshakeSignatureValid, rustls::Error> {
        verify_tls12_signature(
            message,
            cert,
            dss,
            &rustls::crypto::ring::default_provider().signature_verification_algorithms,
        )
    }

    // Delegate TLS 1.3 signature verification to ring provider
    fn verify_tls13_signature(
        &self,
        message: &[u8],
        cert: &CertificateDer<'_>,
        dss: &DigitallySignedStruct,
    ) -> Result<HandshakeSignatureValid, rustls::Error> {
        verify_tls13_signature(
            message,
            cert,
            dss,
            &rustls::crypto::ring::default_provider().signature_verification_algorithms,
        )
    }

    fn supported_verify_schemes(&self) -> Vec<rustls::SignatureScheme> {
        rustls::crypto::ring::default_provider()
            .signature_verification_algorithms
            .supported_schemes()
    }
}

/// QUIC client for Flutter bridge
///
/// Uses TOFU (Trust On First Use) with fingerprint-based certificate verification.
pub struct QuicClient {
    /// QUIC endpoint for client connections
    endpoint: Endpoint,
    /// Active QUIC connection (if any)
    connection: Option<Connection>,
    /// Expected server fingerprint for TOFU verification
    server_fingerprint: String,
    /// QUIC send stream for commands
    send_stream: Option<Arc<Mutex<SendStream>>>,
    /// Background task for receiving terminal events
    recv_task: Option<JoinHandle<()>>,
    /// Event buffer for background receive task
    /// Events from server are pushed here by background task
    event_buffer: Arc<Mutex<Vec<TerminalEvent>>>,
    /// DirChunk buffer for VFS directory listing
    dir_chunk_buffer: Arc<Mutex<Vec<NetworkMessage>>>,
    /// File event buffer for VFS file watcher (Phase VFS-3)
    file_event_buffer: Arc<Mutex<Vec<NetworkMessage>>>,
    /// File content buffer for VFS file reading (Phase VFS-2)
    file_content_buffer: Arc<Mutex<Vec<NetworkMessage>>>,
    /// Session history buffer for multi-session support (Phase 04)
    /// Stores SessionHistory messages for inactive sessions
    session_history_buffer: Arc<Mutex<Vec<NetworkMessage>>>,
    /// Active session ID (Phase 04)
    active_session_id: Arc<Mutex<Option<String>>>,
}

impl QuicClient {
    /// Create new QUIC client with fingerprint for TOFU verification
    pub fn new(server_fingerprint: String) -> Self {
        // Create client endpoint bound to random port
        let endpoint = Endpoint::client("0.0.0.0:0".parse().unwrap())
            .expect("Failed to create QUIC client endpoint");

        Self {
            endpoint,
            connection: None,
            server_fingerprint,
            send_stream: None,
            recv_task: None,
            event_buffer: Arc::new(Mutex::new(Vec::new())),
            dir_chunk_buffer: Arc::new(Mutex::new(Vec::new())),
            file_event_buffer: Arc::new(Mutex::new(Vec::new())),
            file_content_buffer: Arc::new(Mutex::new(Vec::new())),
            session_history_buffer: Arc::new(Mutex::new(Vec::new())),
            active_session_id: Arc::new(Mutex::new(None)),
        }
    }

    /// Connect to remote host using QUIC with TOFU verification
    ///
    /// # Arguments
    /// * `host` - Server IP address or hostname
    /// * `port` - QUIC server port
    /// * `auth_token` - Authentication token (validated but not used in this phase)
    pub async fn connect(
        &mut self,
        host: String,
        port: u16,
        auth_token: String,
    ) -> Result<(), String> {
        // Validate inputs
        if host.is_empty() {
            return Err("Host cannot be empty".to_string());
        }
        if port == 0 {
            return Err("Port cannot be 0".to_string());
        }

        // Validate auth token format
        let token = AuthToken::from_hex(&auth_token)
            .map_err(|e| format!("Invalid auth token: {}", e))?;

        info!("Connecting to {}:{} with TOFU fingerprint verification...", host, port);

        // Step 1: Setup Rustls config with TOFU verifier
        let verifier = Arc::new(TofuVerifier::new(self.server_fingerprint.clone()));

        let rustls_config = rustls::ClientConfig::builder()
            .dangerous()
            .with_custom_certificate_verifier(verifier)
            .with_no_client_auth();

        // Step 2: Wrap into Quinn config using configure_client (Phase 05.1)
        let quic_crypto = quinn::crypto::rustls::QuicClientConfig::try_from(rustls_config)
            .map_err(|e| format!("Failed to create QUIC crypto config: {}", e))?;

        let client_config = comacode_core::transport::configure_client(Arc::new(quic_crypto));

        // Step 3: Connect to server
        let addr = format!("{}:{}", host, port)
            .parse::<std::net::SocketAddr>()
            .map_err(|e| format!("Invalid address: {}", e))?;

        // SNI string - not critical for TOFU but required by TLS
        let connecting = self
            .endpoint
            .connect_with(client_config, addr, "comacode-host")
            .map_err(|e| format!("Failed to initiate connection: {}", e))?;

        let connection = connecting.await.map_err(|e| format!("Connection failed: {}", e))?;

        info!("QUIC connection established to {}:{}", host, port);

        // Step 4: Open bidirectional stream (Phase 05.1)
        let (mut send, mut recv) = connection.open_bi().await
            .map_err(|e| format!("Failed to open stream: {}", e))?;

        // Step 5: Send Hello message with auth token
        let hello_msg = NetworkMessage::hello(Some(token));
        let encoded = MessageCodec::encode(&hello_msg)
            .map_err(|e| format!("Failed to encode hello: {}", e))?;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send hello: {}", e))?;

        // Step 6: Receive Hello ACK
        let mut read_buf = vec![0u8; 1024];
        let n = recv.read(&mut read_buf).await
            .map_err(|e| format!("Failed to read hello response: {}", e))?
            .ok_or_else(|| format!("Connection closed while waiting for hello"))?;

        if n == 0 {
            return Err("Server closed connection".to_string());
        }

        let response = MessageCodec::decode(&read_buf[..n])
            .map_err(|e| format!("Failed to decode hello response: {}", e))?;

        match response {
            NetworkMessage::Hello { .. } => {
                info!("Handshake successful");
            }
            _ => {
                return Err("Unexpected response from server".to_string());
            }
        }

        // Step 7: Store streams for subsequent operations
        let send_shared = Arc::new(Mutex::new(send));
        let recv_shared = Arc::new(Mutex::new(recv));

        self.send_stream = Some(send_shared.clone());

        // Step 8: Spawn background receive task (Phase 09)
        // This reads from QUIC stream continuously in background
        // and pushes events to event_buffer. receive_event() polls from buffer.
        let event_buffer = self.event_buffer.clone();
        let dir_chunk_buffer = self.dir_chunk_buffer.clone();
        let file_event_buffer = self.file_event_buffer.clone();
        let file_content_buffer = self.file_content_buffer.clone();
        let session_history_buffer = self.session_history_buffer.clone();
        let active_session_id = self.active_session_id.clone();
        let recv_task = tokio::spawn(async move {
            info!(" [RECV_TASK] Background receive task started");
            let mut recv = recv_shared.lock().await;
            let mut read_buf = vec![0u8; 8192];

            loop {
                // Read from stream (blocking is OK in background task)
                match recv.read(&mut read_buf).await {
                    Ok(Some(n)) => {
                        if n > 0 {
                            // Decode and push to buffer
                            match MessageCodec::decode(&read_buf[..n]) {
                                Ok(NetworkMessage::Event(event)) => {
                                    info!(" [RECV_TASK] Received event, buffering");
                                    let mut buffer = event_buffer.lock().await;
                                    buffer.push(event);
                                }
                                // VFS Phase 1: Buffer DirChunk messages
                                // Cap at 100 chunks to prevent OOM (~15MB max)
                                Ok(NetworkMessage::DirChunk { ref entries, ref has_more, .. }) => {
                                    let mut buffer = dir_chunk_buffer.lock().await;
                                    if buffer.len() < 100 {
                                        info!(" [RECV_TASK] Received DirChunk, buffering ({}/100)", buffer.len() + 1);
                                        buffer.push(NetworkMessage::DirChunk {
                                            chunk_index: 0,
                                            total_chunks: 0,
                                            entries: entries.clone(),
                                            has_more: *has_more,
                                        });
                                    } else {
                                        warn!(" [RECV_TASK] DirChunk buffer full (100), dropping chunk");
                                    }
                                }
                                // VFS Phase 3: Buffer file watcher events
                                // Cap at 1000 events to prevent OOM (~500KB max)
                                Ok(msg @ NetworkMessage::FileEvent { .. })
                                | Ok(msg @ NetworkMessage::WatchStarted { .. })
                                | Ok(msg @ NetworkMessage::WatchError { .. }) => {
                                    let mut buffer = file_event_buffer.lock().await;
                                    if buffer.len() < 1000 {
                                        info!(" [RECV_TASK] Received file watcher event, buffering ({}/1000)", buffer.len() + 1);
                                        buffer.push(msg);
                                    } else {
                                        warn!(" [RECV_TASK] File event buffer full (1000), dropping event");
                                    }
                                }
                                // VFS Phase 2: Buffer FileContent messages
                                // Cap at 10 files to prevent OOM (~10MB max)
                                Ok(msg @ NetworkMessage::FileContent { .. }) => {
                                    let mut buffer = file_content_buffer.lock().await;
                                    if buffer.len() < 10 {
                                        info!(" [RECV_TASK] Received FileContent, buffering ({}/10)", buffer.len() + 1);
                                        buffer.push(msg);
                                    } else {
                                        warn!(" [RECV_TASK] FileContent buffer full (10), dropping response");
                                    }
                                }
                                // Phase 04: Multi-session support
                                // Buffer SessionHistory messages
                                Ok(msg @ NetworkMessage::SessionHistory { .. }) => {
                                    let mut buffer = session_history_buffer.lock().await;
                                    if buffer.len() < 100 {
                                        info!(" [RECV_TASK] Received SessionHistory, buffering ({}/100)", buffer.len() + 1);
                                        buffer.push(msg);
                                    } else {
                                        warn!(" [RECV_TASK] SessionHistory buffer full (100), dropping message");
                                    }
                                }
                                // Phase 04: Handle TaggedOutput
                                // Only forward to event buffer if from active session
                                Ok(NetworkMessage::TaggedOutput(TaggedOutput { session_id, data })) => {
                                    let current_active = active_session_id.lock().await;
                                    if current_active.as_ref() == Some(&session_id) {
                                        info!(" [RECV_TASK] Received TaggedOutput from active session {}, buffering", session_id);
                                        drop(current_active); // Release lock before pushing
                                        let mut buffer = event_buffer.lock().await;
                                        buffer.push(TerminalEvent::Output { data });
                                    } else {
                                        info!(" [RECV_TASK] Received TaggedOutput from inactive session {}, ignoring", session_id);
                                    }
                                }
                                Ok(msg) => {
                                    debug!(" [RECV_TASK] Received non-event message: {:?}", std::mem::discriminant(&msg));
                                }
                                Err(e) => {
                                    warn!(" [RECV_TASK] Failed to decode message: {}", e);
                                }
                            }
                        } else {
                            info!(" [RECV_TASK] Connection closed (EOF)");
                            break;
                        }
                    }
                    Ok(None) => {
                        info!(" [RECV_TASK] Connection closed (None)");
                        break;
                    }
                    Err(e) => {
                        error!(" [RECV_TASK] Read error: {}", e);
                        break;
                    }
                }
            }
            info!(" [RECV_TASK] Background receive task ended");
        });

        self.recv_task = Some(recv_task);
        self.connection = Some(connection);
        Ok(())
    }

    /// Receive next terminal event from server (NON-BLOCKING)
    ///
    /// Phase 09: Polls from event buffer populated by background task.
    /// Returns immediately if no events available (empty event).
    pub async fn receive_event(&self) -> Result<TerminalEvent, String> {
        let mut buffer = self.event_buffer.lock().await;

        if buffer.is_empty() {
            // No events available - return empty immediately (non-blocking)
            Ok(TerminalEvent::output_str(""))
        } else {
            // Pop first event from buffer
            Ok(buffer.remove(0))
        }
    }

    /// Send command to remote terminal
    ///
    /// Phase 05.1: Sends command via QUIC stream
    pub async fn send_command(&self, command: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] send_command called: '{}'", command);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| {
                error!(" [QUIC_CLIENT] No send_stream - not connected");
                "Not connected".to_string()
            })?;

        let cmd_msg = NetworkMessage::Command(TerminalCommand::new(command));
        let encoded = MessageCodec::encode(&cmd_msg)
            .map_err(|e| {
                error!(" [QUIC_CLIENT] Encode failed: {}", e);
                format!("Failed to encode command: {}", e)
            })?;

        info!(" [QUIC_CLIENT] Sending {} bytes", encoded.len());

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| {
                error!(" [QUIC_CLIENT] write_all failed: {}", e);
                format!("Failed to send command: {}", e)
            })?;

        info!(" [QUIC_CLIENT] Command sent successfully");
        Ok(())
    }

    /// Send raw input bytes to remote terminal (pure passthrough)
    ///
    /// Phase 08: Send raw keystrokes directly to PTY without String conversion.
    /// Use this for proper Ctrl+C, backspace, and other control characters.
    pub async fn send_raw_input(&self, data: Vec<u8>) -> Result<(), String> {
        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let input_msg = NetworkMessage::Input { data };
        let encoded = MessageCodec::encode(&input_msg)
            .map_err(|e| format!("Failed to encode input: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send input: {}", e))?;

        debug!("Sent raw input via QUIC");
        Ok(())
    }

    /// Resize PTY (for screen rotation support)
    ///
    /// Phase 05.1: Send resize event via QUIC to update PTY size on server
    pub async fn resize_pty(&self, rows: u16, cols: u16) -> Result<(), String> {
        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let resize_msg = NetworkMessage::Resize { rows, cols };
        let encoded = MessageCodec::encode(&resize_msg)
            .map_err(|e| format!("Failed to encode resize: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send resize: {}", e))?;

        debug!("Sent resize {}x{} via QUIC", rows, cols);
        Ok(())
    }

    // ===== VFS Methods - Phase 1 =====

    /// Request directory listing from server
    ///
    /// Sends ListDir message. Server responds with multiple DirChunk messages.
    /// Call receive_dir_chunk() to receive chunks until has_more == false.
    pub async fn request_list_dir(&self, path: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] request_list_dir: {}", path);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let list_dir_msg = NetworkMessage::ListDir {
            path,
            depth: None,  // Reserved for future
        };
        let encoded = MessageCodec::encode(&list_dir_msg)
            .map_err(|e| format!("Failed to encode ListDir: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send ListDir: {}", e))?;

        info!(" [QUIC_CLIENT] ListDir request sent");
        Ok(())
    }

    /// Receive next directory chunk from server (NON-BLOCKING)
    ///
    /// Returns (chunk_index, entries, has_more) tuple.
    /// Returns None if no chunks available yet.
    /// Call repeatedly until has_more == false.
    ///
    /// **Security**: Buffer capped at 100 chunks to prevent OOM.
    pub async fn receive_dir_chunk(&self) -> Result<Option<(u32, Vec<DirEntry>, bool)>, String> {
        let mut buffer = self.dir_chunk_buffer.lock().await;

        // Find first DirChunk message
        let pos = buffer.iter().position(|m| matches!(m, NetworkMessage::DirChunk { .. }));

        match pos {
            Some(idx) => {
                let msg = buffer.remove(idx);
                if let NetworkMessage::DirChunk { chunk_index, entries, has_more, .. } = msg {
                    info!(" [QUIC_CLIENT] Received DirChunk {}/? with {} entries, has_more={}",
                        chunk_index, entries.len(), has_more);
                    Ok(Some((chunk_index, entries, has_more)))
                } else {
                    unreachable!() // We checked above
                }
            }
            None => Ok(None),  // No chunks available
        }
    }

    /// Get dir chunk buffer length (for monitoring)
    pub async fn dir_chunk_buffer_len(&self) -> usize {
        self.dir_chunk_buffer.lock().await.len()
    }

    /// Disconnect from server
    pub async fn disconnect(&mut self) -> Result<(), String> {
        // Abort background receive task
        if let Some(task) = self.recv_task.take() {
            task.abort();
            info!(" [QUIC_CLIENT] Background receive task aborted");
        }

        if let Some(conn) = &self.connection {
            conn.close(0u32.into(), b"Client disconnect");
        }
        self.connection = None;
        self.send_stream = None;

        // Clear buffers
        let mut buffer = self.event_buffer.lock().await;
        buffer.clear();
        let mut dir_buffer = self.dir_chunk_buffer.lock().await;
        dir_buffer.clear();
        let mut file_buffer = self.file_event_buffer.lock().await;
        file_buffer.clear();
        let mut file_content_buffer = self.file_content_buffer.lock().await;
        file_content_buffer.clear();

        Ok(())
    }

    /// Check if connected
    pub async fn is_connected(&self) -> bool {
        match &self.connection {
            Some(conn) => conn.close_reason().is_none(),
            None => false,
        }
    }

    // ===== VFS Watcher Methods - Phase 3 =====

    /// Request server to watch a directory for changes
    ///
    /// Server will push FileEvent messages when files are created/modified/deleted.
    /// Call receive_file_event() to receive watcher events.
    pub async fn request_watch_dir(&self, path: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] request_watch_dir: {}", path);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let watch_msg = NetworkMessage::WatchDir { path };
        let encoded = MessageCodec::encode(&watch_msg)
            .map_err(|e| format!("Failed to encode WatchDir: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send WatchDir: {}", e))?;

        info!(" [QUIC_CLIENT] WatchDir request sent");
        Ok(())
    }

    /// Request server to stop watching a directory
    pub async fn request_unwatch_dir(&self, watcher_id: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] request_unwatch_dir: {}", watcher_id);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let unwatch_msg = NetworkMessage::UnwatchDir { watcher_id };
        let encoded = MessageCodec::encode(&unwatch_msg)
            .map_err(|e| format!("Failed to encode UnwatchDir: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send UnwatchDir: {}", e))?;

        info!(" [QUIC_CLIENT] UnwatchDir request sent");
        Ok(())
    }

    /// Receive next file watcher event from server (NON-BLOCKING)
    ///
    /// Returns Ok(Some(event)) if event available, Ok(None) if buffer empty.
    ///
    /// **Security**: Buffer capped at 1000 events to prevent OOM.
    pub async fn receive_file_event(&self) -> Result<Option<FileWatcherEventData>, String> {
        let mut buffer = self.file_event_buffer.lock().await;

        let pos = buffer.iter().position(|m| matches!(
            m,
            NetworkMessage::FileEvent { .. }
                | NetworkMessage::WatchStarted { .. }
                | NetworkMessage::WatchError { .. }
        ));

        match pos {
            Some(idx) => {
                let msg = buffer.remove(idx);
                Ok(Some(match msg {
                    NetworkMessage::FileEvent { watcher_id, path, event_type, timestamp } => {
                        FileWatcherEventData::FileEvent(FileWatcherEvent {
                            watcher_id,
                            path,
                            event_type,
                            timestamp,
                        })
                    }
                    NetworkMessage::WatchStarted { watcher_id } => {
                        FileWatcherEventData::Started(WatcherStartedEvent { watcher_id })
                    }
                    NetworkMessage::WatchError { watcher_id, error } => {
                        FileWatcherEventData::Error(WatcherErrorEvent { watcher_id, error })
                    }
                    _ => unreachable!(),
                }))
            }
            None => Ok(None),
        }
    }

    /// Get file event buffer length (for monitoring)
    pub async fn file_event_buffer_len(&self) -> usize {
        self.file_event_buffer.lock().await.len()
    }

    // ===== VFS File Reading Methods - Phase 2 =====

    /// Request server to read a file
    ///
    /// Server responds with FileContent message.
    /// Call receive_file_content() to receive the file content.
    pub async fn request_read_file(&self, path: String, max_size: usize) -> Result<(), String> {
        info!(" [QUIC_CLIENT] request_read_file: {} (max_size: {})", path, max_size);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let read_file_msg = NetworkMessage::ReadFile { path, max_size };
        let encoded = MessageCodec::encode(&read_file_msg)
            .map_err(|e| format!("Failed to encode ReadFile: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send ReadFile: {}", e))?;

        info!(" [QUIC_CLIENT] ReadFile request sent");
        Ok(())
    }

    /// Receive file content from server (NON-BLOCKING)
    ///
    /// Returns (path, content, size, truncated) tuple.
    /// Returns None if no file content available yet.
    pub async fn receive_file_content(&self) -> Result<Option<(String, String, usize, bool)>, String> {
        let mut buffer = self.file_content_buffer.lock().await;

        // Find first FileContent message
        let pos = buffer.iter().position(|m| matches!(m, NetworkMessage::FileContent { .. }));

        match pos {
            Some(idx) => {
                let msg = buffer.remove(idx);
                if let NetworkMessage::FileContent { path, content, size, truncated } = msg {
                    info!(" [QUIC_CLIENT] Received FileContent: {} bytes, truncated={}", size, truncated);
                    Ok(Some((path, content, size, truncated)))
                } else {
                    unreachable!() // We checked above
                }
            }
            None => Ok(None),  // No file content available
        }
    }

    /// Get file content buffer length (for monitoring)
    pub async fn file_content_buffer_len(&self) -> usize {
        self.file_content_buffer.lock().await.len()
    }

    // ===== Multi-Session Management - Phase 04 =====

    /// Create a new PTY session with UUID
    ///
    /// Sends CreateSession message to server. Server responds with SessionCreated event.
    ///
    /// # Arguments
    /// * `project_path` - Absolute path to project directory
    /// * `session_id` - UUID string for the session (from Flutter)
    pub async fn create_session(&self, project_path: String, session_id: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] create_session: {} at {}", session_id, project_path);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let session_msg = SessionMessage::CreateSession { project_path, session_id };
        let msg = NetworkMessage::Session(session_msg);
        let encoded = MessageCodec::encode(&msg)
            .map_err(|e| format!("Failed to encode CreateSession: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send CreateSession: {}", e))?;

        info!(" [QUIC_CLIENT] CreateSession request sent");
        Ok(())
    }

    /// Check if session exists on server (for re-attach)
    ///
    /// Sends CheckSession message. Server responds with SessionReAttach or SessionNotFound.
    ///
    /// # Arguments
    /// * `session_id` - UUID string to check
    pub async fn check_session(&self, session_id: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] check_session: {}", session_id);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let session_msg = SessionMessage::CheckSession { session_id };
        let msg = NetworkMessage::Session(session_msg);
        let encoded = MessageCodec::encode(&msg)
            .map_err(|e| format!("Failed to encode CheckSession: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send CheckSession: {}", e))?;

        info!(" [QUIC_CLIENT] CheckSession request sent");
        Ok(())
    }

    /// Switch active session
    ///
    /// Sends SwitchSession message. Server responds with SessionHistory (if available)
    /// and SessionSwitched event. Only active session's output is pumped.
    ///
    /// # Arguments
    /// * `session_id` - UUID string to switch to
    pub async fn switch_session(&self, session_id: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] switch_session: {}", session_id);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let session_msg = SessionMessage::SwitchSession { session_id: session_id.clone() };
        let msg = NetworkMessage::Session(session_msg);
        let encoded = MessageCodec::encode(&msg)
            .map_err(|e| format!("Failed to encode SwitchSession: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send SwitchSession: {}", e))?;

        // Update local active session ID
        let mut active_id = self.active_session_id.lock().await;
        *active_id = Some(session_id);
        drop(active_id);

        info!(" [QUIC_CLIENT] SwitchSession request sent");
        Ok(())
    }

    /// Close a session
    ///
    /// Sends CloseSession message. Server responds with SessionClosed event.
    ///
    /// # Arguments
    /// * `session_id` - UUID string to close
    pub async fn close_session(&self, session_id: String) -> Result<(), String> {
        info!(" [QUIC_CLIENT] close_session: {}", session_id);

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let session_msg = SessionMessage::CloseSession { session_id: session_id.clone() };
        let msg = NetworkMessage::Session(session_msg);
        let encoded = MessageCodec::encode(&msg)
            .map_err(|e| format!("Failed to encode CloseSession: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send CloseSession: {}", e))?;

        // Clear local active session ID if it was the closed one
        let mut active_id = self.active_session_id.lock().await;
        if active_id.as_ref() == Some(&session_id) {
            *active_id = None;
        }

        info!(" [QUIC_CLIENT] CloseSession request sent");
        Ok(())
    }

    /// List all active sessions
    ///
    /// Sends ListSessions message. Server responds with text list.
    pub async fn list_sessions(&self) -> Result<(), String> {
        info!(" [QUIC_CLIENT] list_sessions");

        let send_stream = self.send_stream.as_ref()
            .ok_or_else(|| "Not connected".to_string())?;

        let session_msg = SessionMessage::ListSessions;
        let msg = NetworkMessage::Session(session_msg);
        let encoded = MessageCodec::encode(&msg)
            .map_err(|e| format!("Failed to encode ListSessions: {}", e))?;

        let mut send = send_stream.lock().await;
        send.write_all(&encoded).await
            .map_err(|e| format!("Failed to send ListSessions: {}", e))?;

        info!(" [QUIC_CLIENT] ListSessions request sent");
        Ok(())
    }

    /// Receive session history from server (NON-BLOCKING)
    ///
    /// Returns Ok(Some((session_id, lines))) if history available.
    /// Returns Ok(None) if no history available yet.
    ///
    /// Called after SwitchSession to receive history buffer for inactive session.
    pub async fn receive_session_history(&self) -> Result<Option<(String, Vec<String>)>, String> {
        let mut buffer = self.session_history_buffer.lock().await;

        // Find first SessionHistory message
        let pos = buffer.iter().position(|m| matches!(m, NetworkMessage::SessionHistory { .. }));

        match pos {
            Some(idx) => {
                let msg = buffer.remove(idx);
                if let NetworkMessage::SessionHistory { session_id, lines } = msg {
                    info!(" [QUIC_CLIENT] Received SessionHistory: {} lines", lines.len());
                    Ok(Some((session_id, lines)))
                } else {
                    unreachable!()
                }
            }
            None => Ok(None),
        }
    }

    /// Get active session ID
    pub async fn get_active_session_id(&self) -> Option<String> {
        self.active_session_id.lock().await.clone()
    }

    /// Set active session ID locally (for sync with server)
    pub async fn set_active_session_id(&self, session_id: String) {
        let mut active_id = self.active_session_id.lock().await;
        *active_id = Some(session_id);
    }
}

/// File watcher event (for FFI)
#[derive(Debug, Clone)]
pub struct FileWatcherEvent {
    pub watcher_id: String,
    pub path: String,
    pub event_type: FileEventType,
    pub timestamp: u64,
}

/// Watcher started event (for FFI)
#[derive(Debug, Clone)]
pub struct WatcherStartedEvent {
    pub watcher_id: String,
}

/// Watcher error event (for FFI)
#[derive(Debug, Clone)]
pub struct WatcherErrorEvent {
    pub watcher_id: String,
    pub error: String,
}

/// File watcher event data enum
///
/// Moved outside impl block for public visibility
#[derive(Debug, Clone)]
pub enum FileWatcherEventData {
    FileEvent(FileWatcherEvent),
    Started(WatcherStartedEvent),
    Error(WatcherErrorEvent),
}

#[cfg(test)]
mod tests {
    use super::*;

    // Test fingerprint normalization
    #[test]
    fn test_normalize_fingerprint() {
        // Various input formats should normalize to same output
        assert_eq!(TofuVerifier::normalize_fingerprint("AA:BB:CC"), "AABBCC");
        assert_eq!(TofuVerifier::normalize_fingerprint("aa:bb:cc"), "AABBCC");
        assert_eq!(TofuVerifier::normalize_fingerprint("aabbcc"), "AABBCC");
        assert_eq!(TofuVerifier::normalize_fingerprint("aa-bb-cc"), "AABBCC");
        assert_eq!(TofuVerifier::normalize_fingerprint("AA BB CC"), "AABBCC");
        assert_eq!(TofuVerifier::normalize_fingerprint("Aa:Bb-Cc"), "AABBCC");
    }

    // Test fingerprint calculation with known input
    #[test]
    fn test_fingerprint_calculation() {
        let verifier = TofuVerifier::new("AA:BB:CC".to_string());

        // Create a dummy certificate (1 byte)
        let cert = CertificateDer::from(vec![0x42u8]);

        // SHA256 of [0x42] = "9F03A...C6F" (specific hash)
        let fingerprint = verifier.calculate_fingerprint(&cert);

        // Should be 32 bytes = 64 hex chars = 95 chars with colons
        assert!(fingerprint.len() == 95); // "XX:XX:..." format
        assert!(fingerprint.chars().filter(|c| *c == ':').count() == 31);
    }

    #[test]
    fn test_quic_client_creation() {
        // Note: QuicClient::new() requires tokio runtime for Endpoint creation
        // We test the fingerprint field is set correctly when creating client with valid runtime
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            let client = QuicClient::new("AA:BB:CC".to_string());
            assert_eq!(client.server_fingerprint, "AA:BB:CC");
            assert!(client.connection.is_none());
        });
    }

    #[tokio::test]
    async fn test_quic_client_not_connected_initially() {
        let client = QuicClient::new("AA:BB:CC".to_string());
        assert!(!client.is_connected().await);
    }

    #[tokio::test]
    async fn test_quic_client_invalid_host() {
        let mut client = QuicClient::new("AA:BB:CC".to_string());
        let token = AuthToken::generate();
        let result = client.connect("".to_string(), 8443, token.to_hex()).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Host cannot be empty"));
    }

    #[tokio::test]
    async fn test_quic_client_invalid_port() {
        let mut client = QuicClient::new("AA:BB:CC".to_string());
        let token = AuthToken::generate();
        let result = client.connect("127.0.0.1".to_string(), 0, token.to_hex()).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Port cannot be 0"));
    }

    #[tokio::test]
    async fn test_quic_client_invalid_token() {
        let mut client = QuicClient::new("AA:BB:CC".to_string());
        let result = client.connect("127.0.0.1".to_string(), 8443, "invalid".to_string()).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Invalid auth token"));
    }
}

================
File: mobile_bridge/Cargo.toml
================
[package]
name = "mobile_bridge"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
repository.workspace = true

[lib]
name = "mobile_bridge"
crate-type = ["staticlib", "cdylib"]

[dependencies]
# Core shared logic
comacode-core = { path = "../core" }
# FFI bridge
flutter_rust_bridge = "=2.11.1"
# Workspace dependencies
anyhow = { workspace = true }
tracing = { workspace = true }
# Serialization
serde = { workspace = true }
postcard = { workspace = true }
# Async (optional for mobile)
tokio = { workspace = true, features = ["rt-multi-thread", "macros", "sync"] }
# Bytes for zero-copy
bytes = "1.8"
# QUIC networking (Phase 04)
quinn = { workspace = true }
rustls = { workspace = true, features = ["ring"] }
rustls-pki-types = "1.0"
# Crypto for fingerprint verification
sha2 = { workspace = true }
# Thread-safe global static (fix UB from static mut)
once_cell = "1.19"

================
File: .gitignore
================
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/
/coverage/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release





================================================================
End of Codebase
================================================================
