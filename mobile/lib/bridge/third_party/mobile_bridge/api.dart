// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../api.dart';
import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Connect to remote host
///
/// This is the main FFI entry point for Flutter app.
/// Call this after scanning QR code to get connection parameters.
///
/// # Arguments
/// * `host` - Server IP address
/// * `port` - QUIC server port
/// * `auth_token` - Authentication token from QR scan
/// * `fingerprint` - Certificate fingerprint for TOFU verification
///
/// # Behavior
/// - If already connected: Returns error (call disconnect first)
/// - On success: Stores client for subsequent operations
Future<void> connectToHost({
  required String host,
  required int port,
  required String authToken,
  required String fingerprint,
}) => RustLib.instance.api.mobileBridgeApiConnectToHost(
  host: host,
  port: port,
  authToken: authToken,
  fingerprint: fingerprint,
);

/// Receive next terminal event from server
///
/// Call this in a loop to stream terminal output.
/// Returns when a new event is available.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<TerminalEvent> receiveTerminalEvent() =>
    RustLib.instance.api.mobileBridgeApiReceiveTerminalEvent();

/// Send command to remote terminal
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> sendTerminalCommand({required String command}) =>
    RustLib.instance.api.mobileBridgeApiSendTerminalCommand(command: command);

/// Send raw input bytes to remote terminal (pure passthrough)
///
/// Phase 08: Send raw keystrokes directly to PTY without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
///
/// # Arguments
/// * `data` - Raw bytes from stdin (including control chars like 0x03 for Ctrl+C)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> sendRawInput({required List<int> data}) =>
    RustLib.instance.api.mobileBridgeApiSendRawInput(data: data);

/// Resize PTY (for screen rotation support)
///
/// Phase 06: Send resize event to update PTY size on server.
/// Call this when device orientation changes.
///
/// # Arguments
/// * `rows` - Number of rows (characters per column)
/// * `cols` - Number of columns (characters per row)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> resizePty({required int rows, required int cols}) =>
    RustLib.instance.api.mobileBridgeApiResizePty(rows: rows, cols: cols);

/// Disconnect from host
///
/// Clears the client, allowing reconnect.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> disconnectFromHost() =>
    RustLib.instance.api.mobileBridgeApiDisconnectFromHost();

/// Check if connected
///
/// Returns false if client not initialized or disconnected.
Future<bool> isConnected() => RustLib.instance.api.mobileBridgeApiIsConnected();

/// Create a new terminal command
TerminalCommand createCommand({required String text}) =>
    RustLib.instance.api.mobileBridgeApiCreateCommand(text: text);

/// Get command ID
BigInt getCommandId({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiGetCommandId(cmd: cmd);

/// Get command text
String getCommandText({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiGetCommandText(cmd: cmd);

/// Get command timestamp
BigInt getCommandTimestamp({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiGetCommandTimestamp(cmd: cmd);

/// Encode terminal command to bytes for network transmission
Future<Uint8List> encodeCommand({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiEncodeCommand(cmd: cmd);

/// Encode raw input bytes for network transmission (pure passthrough)
///
/// Phase 08: Encode raw keystrokes without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
Future<Uint8List> encodeInput({required List<int> data}) =>
    RustLib.instance.api.mobileBridgeApiEncodeInput(data: data);

/// Encode ping message
Future<Uint8List> encodePing() =>
    RustLib.instance.api.mobileBridgeApiEncodePing();

/// Encode resize message
Future<Uint8List> encodeResize({required int rows, required int cols}) =>
    RustLib.instance.api.mobileBridgeApiEncodeResize(rows: rows, cols: cols);

/// Decode network message from bytes
Future<String> decodeMessage({required List<int> data}) =>
    RustLib.instance.api.mobileBridgeApiDecodeMessage(data: data);

/// Create terminal config with custom size
TerminalConfig createTerminalConfig({required int rows, required int cols}) =>
    RustLib.instance.api.mobileBridgeApiCreateTerminalConfig(
      rows: rows,
      cols: cols,
    );

/// Parse QR payload JSON string
Future<QrPayload> parseQrPayload({required String json}) =>
    RustLib.instance.api.mobileBridgeApiParseQrPayload(json: json);

/// Get QR payload fields
String getQrIp({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrIp(payload: payload);

int getQrPort({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrPort(payload: payload);

String getQrFingerprint({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrFingerprint(payload: payload);

String getQrToken({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrToken(payload: payload);

int getQrProtocolVersion({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrProtocolVersion(payload: payload);

/// Create output event from bytes
TerminalEvent eventOutput({required List<int> data}) =>
    RustLib.instance.api.mobileBridgeApiEventOutput(data: data);

/// Create output event from string
TerminalEvent eventOutputStr({required String s}) =>
    RustLib.instance.api.mobileBridgeApiEventOutputStr(s: s);

/// Get event data (for Output events)
Uint8List getEventData({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiGetEventData(event: event);

/// Get event error message (for Error events)
String getEventErrorMessage({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiGetEventErrorMessage(event: event);

/// Get event exit code (for Exit events)
int getEventExitCode({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiGetEventExitCode(event: event);

/// Check if event is Output
bool isEventOutput({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiIsEventOutput(event: event);

/// Check if event is Error
bool isEventError({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiIsEventError(event: event);

/// Check if event is Exit
bool isEventExit({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiIsEventExit(event: event);

/// Request directory listing from server
///
/// Sends ListDir message. Server responds with multiple DirChunk messages.
/// Call receive_dir_chunk() in a loop to receive all chunks.
///
/// # Arguments
/// * `path` - Absolute path to list (e.g., "/tmp", "/home/user")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestListDir({required String path}) =>
    RustLib.instance.api.mobileBridgeApiRequestListDir(path: path);

/// Receive next directory chunk from server (NON-BLOCKING)
///
/// Returns a chunk with entries. Call repeatedly until has_more is false.
/// Returns None if no chunks available yet (server still processing).
///
/// # Returns
/// * `Some((chunk_index, entries, has_more))` - Chunk received
/// * `None` - No chunks available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<(int, List<DirEntry>, bool)?> receiveDirChunk() =>
    RustLib.instance.api.mobileBridgeApiReceiveDirChunk();

/// Get entry name
String getDirEntryName({required DirEntry entry}) =>
    RustLib.instance.api.mobileBridgeApiGetDirEntryName(entry: entry);

/// Get entry path
String getDirEntryPath({required DirEntry entry}) =>
    RustLib.instance.api.mobileBridgeApiGetDirEntryPath(entry: entry);

/// Check if entry is a directory
bool isDirEntryDir({required DirEntry entry}) =>
    RustLib.instance.api.mobileBridgeApiIsDirEntryDir(entry: entry);

/// Check if entry is a symlink
bool isDirEntrySymlink({required DirEntry entry}) =>
    RustLib.instance.api.mobileBridgeApiIsDirEntrySymlink(entry: entry);

/// Get entry size (bytes)
BigInt? getDirEntrySize({required DirEntry entry}) =>
    RustLib.instance.api.mobileBridgeApiGetDirEntrySize(entry: entry);

/// Get entry modified timestamp (Unix epoch seconds)
BigInt? getDirEntryModified({required DirEntry entry}) =>
    RustLib.instance.api.mobileBridgeApiGetDirEntryModified(entry: entry);

/// Get entry permissions string
String? getDirEntryPermissions({required DirEntry entry}) =>
    RustLib.instance.api.mobileBridgeApiGetDirEntryPermissions(entry: entry);

/// Request server to watch a directory for changes
///
/// Server will push FileEvent messages when files are created/modified/deleted.
/// Call receive_file_event() in a loop to receive watcher events.
///
/// # Arguments
/// * `path` - Absolute path to watch (e.g., "/tmp", "/home/user/project")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestWatchDir({required String path}) =>
    RustLib.instance.api.mobileBridgeApiRequestWatchDir(path: path);

/// Request server to stop watching a directory
///
/// # Arguments
/// * `watcher_id` - ID of the watcher to stop (returned in WatchStarted event)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestUnwatchDir({required String watcherId}) =>
    RustLib.instance.api.mobileBridgeApiRequestUnwatchDir(watcherId: watcherId);

/// Receive next file watcher event from server (NON-BLOCKING)
///
/// Returns watcher events (FileEvent, WatchStarted, WatchError).
/// Call repeatedly in a loop to process all events.
/// Returns None if no events available yet.
///
/// # Returns
/// * `Some(FileWatcherEventData)` - Event received
/// * `None` - No events available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<FileWatcherEventData?> receiveFileEvent() =>
    RustLib.instance.api.mobileBridgeApiReceiveFileEvent();

/// Get file event buffer length (for monitoring)
///
/// Returns number of buffered events waiting to be processed.
Future<BigInt> fileEventBufferLen() =>
    RustLib.instance.api.mobileBridgeApiFileEventBufferLen();

/// Simple add function for testing FFI
int add({required int a, required int b}) =>
    RustLib.instance.api.mobileBridgeApiAdd(a: a, b: b);

/// Greeting function for testing FFI
String greet({required String name}) =>
    RustLib.instance.api.mobileBridgeApiGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>
abstract class DirEntry implements RustOpaqueInterface {}
