// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../api.dart';
import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Connect to remote host
///
/// This is the main FFI entry point for Flutter app.
/// Call this after scanning QR code to get connection parameters.
///
/// # Arguments
/// * `host` - Server IP address
/// * `port` - QUIC server port
/// * `auth_token` - Authentication token from QR scan
/// * `fingerprint` - Certificate fingerprint for TOFU verification
///
/// # Behavior
/// - First call: Initializes client and connects
/// - Subsequent calls: Returns error if already connected
Future<void> connectToHost({
  required String host,
  required int port,
  required String authToken,
  required String fingerprint,
}) => RustLib.instance.api.mobileBridgeApiConnectToHost(
  host: host,
  port: port,
  authToken: authToken,
  fingerprint: fingerprint,
);

/// Receive next terminal event from server
///
/// Call this in a loop to stream terminal output.
/// Returns when a new event is available.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<TerminalEvent> receiveTerminalEvent() =>
    RustLib.instance.api.mobileBridgeApiReceiveTerminalEvent();

/// Send command to remote terminal
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> sendTerminalCommand({required String command}) =>
    RustLib.instance.api.mobileBridgeApiSendTerminalCommand(command: command);

/// Resize PTY (for screen rotation support)
///
/// Phase 06: Send resize event to update PTY size on server.
/// Call this when device orientation changes.
///
/// # Arguments
/// * `rows` - Number of rows (characters per column)
/// * `cols` - Number of columns (characters per row)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> resizePty({required int rows, required int cols}) =>
    RustLib.instance.api.mobileBridgeApiResizePty(rows: rows, cols: cols);

/// Disconnect from host
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> disconnectFromHost() =>
    RustLib.instance.api.mobileBridgeApiDisconnectFromHost();

/// Check if connected
///
/// Returns false if client not initialized or disconnected.
Future<bool> isConnected() => RustLib.instance.api.mobileBridgeApiIsConnected();

/// Create a new terminal command
TerminalCommand createCommand({required String text}) =>
    RustLib.instance.api.mobileBridgeApiCreateCommand(text: text);

/// Get command ID
BigInt getCommandId({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiGetCommandId(cmd: cmd);

/// Get command text
String getCommandText({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiGetCommandText(cmd: cmd);

/// Get command timestamp
BigInt getCommandTimestamp({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiGetCommandTimestamp(cmd: cmd);

/// Encode terminal command to bytes for network transmission
Future<Uint8List> encodeCommand({required TerminalCommand cmd}) =>
    RustLib.instance.api.mobileBridgeApiEncodeCommand(cmd: cmd);

/// Encode ping message
Future<Uint8List> encodePing() =>
    RustLib.instance.api.mobileBridgeApiEncodePing();

/// Encode resize message
Future<Uint8List> encodeResize({required int rows, required int cols}) =>
    RustLib.instance.api.mobileBridgeApiEncodeResize(rows: rows, cols: cols);

/// Decode network message from bytes
Future<String> decodeMessage({required List<int> data}) =>
    RustLib.instance.api.mobileBridgeApiDecodeMessage(data: data);

/// Create terminal config with custom size
TerminalConfig createTerminalConfig({required int rows, required int cols}) =>
    RustLib.instance.api.mobileBridgeApiCreateTerminalConfig(
      rows: rows,
      cols: cols,
    );

/// Parse QR payload JSON string
Future<QrPayload> parseQrPayload({required String json}) =>
    RustLib.instance.api.mobileBridgeApiParseQrPayload(json: json);

/// Get QR payload fields
String getQrIp({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrIp(payload: payload);

int getQrPort({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrPort(payload: payload);

String getQrFingerprint({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrFingerprint(payload: payload);

String getQrToken({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrToken(payload: payload);

int getQrProtocolVersion({required QrPayload payload}) =>
    RustLib.instance.api.mobileBridgeApiGetQrProtocolVersion(payload: payload);

/// Create output event from bytes
TerminalEvent eventOutput({required List<int> data}) =>
    RustLib.instance.api.mobileBridgeApiEventOutput(data: data);

/// Create output event from string
TerminalEvent eventOutputStr({required String s}) =>
    RustLib.instance.api.mobileBridgeApiEventOutputStr(s: s);

/// Get event data (for Output events)
Uint8List getEventData({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiGetEventData(event: event);

/// Get event error message (for Error events)
String getEventErrorMessage({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiGetEventErrorMessage(event: event);

/// Get event exit code (for Exit events)
int getEventExitCode({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiGetEventExitCode(event: event);

/// Check if event is Output
bool isEventOutput({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiIsEventOutput(event: event);

/// Check if event is Error
bool isEventError({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiIsEventError(event: event);

/// Check if event is Exit
bool isEventExit({required TerminalEvent event}) =>
    RustLib.instance.api.mobileBridgeApiIsEventExit(event: event);

/// Simple add function for testing FFI
int add({required int a, required int b}) =>
    RustLib.instance.api.mobileBridgeApiAdd(a: a, b: b);

/// Greeting function for testing FFI
String greet({required String name}) =>
    RustLib.instance.api.mobileBridgeApiGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>
abstract class QrPayload implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>
abstract class TerminalCommand implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>
abstract class TerminalEvent implements RustOpaqueInterface {}
