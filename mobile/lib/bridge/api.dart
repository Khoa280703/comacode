// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `get_client`, `init_crypto_provider`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Connect to remote host
///
/// This is the main FFI entry point for Flutter app.
/// Call this after scanning QR code to get connection parameters.
///
/// # Arguments
/// * `host` - Server IP address
/// * `port` - QUIC server port
/// * `auth_token` - Authentication token from QR scan
/// * `fingerprint` - Certificate fingerprint for TOFU verification
///
/// # Behavior
/// - If already connected: Returns error (call disconnect first)
/// - On success: Stores client for subsequent operations
Future<void> connectToHost({
  required String host,
  required int port,
  required String authToken,
  required String fingerprint,
}) => RustLib.instance.api.crateApiConnectToHost(
  host: host,
  port: port,
  authToken: authToken,
  fingerprint: fingerprint,
);

/// Receive next terminal event from server
///
/// Call this in a loop to stream terminal output.
/// Returns when a new event is available.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<TerminalEvent> receiveTerminalEvent() =>
    RustLib.instance.api.crateApiReceiveTerminalEvent();

/// Send command to remote terminal
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> sendTerminalCommand({required String command}) =>
    RustLib.instance.api.crateApiSendTerminalCommand(command: command);

/// Send raw input bytes to remote terminal (pure passthrough)
///
/// Phase 08: Send raw keystrokes directly to PTY without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
///
/// # Arguments
/// * `data` - Raw bytes from stdin (including control chars like 0x03 for Ctrl+C)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> sendRawInput({required List<int> data}) =>
    RustLib.instance.api.crateApiSendRawInput(data: data);

/// Resize PTY (for screen rotation support)
///
/// Phase 06: Send resize event to update PTY size on server.
/// Call this when device orientation changes.
///
/// # Arguments
/// * `rows` - Number of rows (characters per column)
/// * `cols` - Number of columns (characters per row)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> resizePty({required int rows, required int cols}) =>
    RustLib.instance.api.crateApiResizePty(rows: rows, cols: cols);

/// Disconnect from host
///
/// Clears the client, allowing reconnect.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> disconnectFromHost() =>
    RustLib.instance.api.crateApiDisconnectFromHost();

/// Check if connected
///
/// Returns false if client not initialized or disconnected.
Future<bool> isConnected() => RustLib.instance.api.crateApiIsConnected();

/// Create a new terminal command
TerminalCommand createCommand({required String text}) =>
    RustLib.instance.api.crateApiCreateCommand(text: text);

/// Get command ID
BigInt getCommandId({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiGetCommandId(cmd: cmd);

/// Get command text
String getCommandText({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiGetCommandText(cmd: cmd);

/// Get command timestamp
BigInt getCommandTimestamp({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiGetCommandTimestamp(cmd: cmd);

/// Encode terminal command to bytes for network transmission
Future<Uint8List> encodeCommand({required TerminalCommand cmd}) =>
    RustLib.instance.api.crateApiEncodeCommand(cmd: cmd);

/// Encode raw input bytes for network transmission (pure passthrough)
///
/// Phase 08: Encode raw keystrokes without String conversion.
/// Use this for proper Ctrl+C, backspace, and other control characters.
Future<Uint8List> encodeInput({required List<int> data}) =>
    RustLib.instance.api.crateApiEncodeInput(data: data);

/// Encode ping message
Future<Uint8List> encodePing() => RustLib.instance.api.crateApiEncodePing();

/// Encode resize message
Future<Uint8List> encodeResize({required int rows, required int cols}) =>
    RustLib.instance.api.crateApiEncodeResize(rows: rows, cols: cols);

/// Decode network message from bytes
Future<String> decodeMessage({required List<int> data}) =>
    RustLib.instance.api.crateApiDecodeMessage(data: data);

/// Create terminal config with custom size
TerminalConfig createTerminalConfig({required int rows, required int cols}) =>
    RustLib.instance.api.crateApiCreateTerminalConfig(rows: rows, cols: cols);

/// Parse QR payload JSON string
Future<QrPayload> parseQrPayload({required String json}) =>
    RustLib.instance.api.crateApiParseQrPayload(json: json);

/// Get QR payload fields
String getQrIp({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrIp(payload: payload);

int getQrPort({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrPort(payload: payload);

String getQrFingerprint({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrFingerprint(payload: payload);

String getQrToken({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrToken(payload: payload);

int getQrProtocolVersion({required QrPayload payload}) =>
    RustLib.instance.api.crateApiGetQrProtocolVersion(payload: payload);

/// Create output event from bytes
TerminalEvent eventOutput({required List<int> data}) =>
    RustLib.instance.api.crateApiEventOutput(data: data);

/// Create output event from string
TerminalEvent eventOutputStr({required String s}) =>
    RustLib.instance.api.crateApiEventOutputStr(s: s);

/// Get event data (for Output events)
Uint8List getEventData({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiGetEventData(event: event);

/// Get event error message (for Error events)
String getEventErrorMessage({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiGetEventErrorMessage(event: event);

/// Get event exit code (for Exit events)
int getEventExitCode({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiGetEventExitCode(event: event);

/// Check if event is Output
bool isEventOutput({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiIsEventOutput(event: event);

/// Check if event is Error
bool isEventError({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiIsEventError(event: event);

/// Check if event is Exit
bool isEventExit({required TerminalEvent event}) =>
    RustLib.instance.api.crateApiIsEventExit(event: event);

/// Request directory listing from server
///
/// Sends ListDir message. Server responds with multiple DirChunk messages.
/// Call receive_dir_chunk() in a loop to receive all chunks.
///
/// # Arguments
/// * `path` - Absolute path to list (e.g., "/tmp", "/home/user")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestListDir({required String path}) =>
    RustLib.instance.api.crateApiRequestListDir(path: path);

/// Receive next directory chunk from server (NON-BLOCKING)
///
/// Returns a chunk with entries. Call repeatedly until has_more is false.
/// Returns None if no chunks available yet (server still processing).
///
/// # Returns
/// * `Some((chunk_index, entries, has_more))` - Chunk received
/// * `None` - No chunks available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<(int, List<DirEntry>, bool)?> receiveDirChunk() =>
    RustLib.instance.api.crateApiReceiveDirChunk();

/// List directory entries using Future API
///
/// Phase VFS-Fix: Refactored from Stream to Future for reliability.
/// Stream API had race condition where onDone fired before onData.
/// Future API is deterministic - data is returned when complete.
///
/// # Arguments
/// * `path` - Directory path to list
///
/// # Returns
/// * `Ok(Vec<DirEntry>)` - All entries in directory
/// * `Err(String)` - Error message
Future<List<DirEntry>> listDirectory({required String path}) =>
    RustLib.instance.api.crateApiListDirectory(path: path);

/// Stream directory entries (DEPRECATED - for FRB codegen compatibility)
///
/// This function exists only for compatibility with generated code.
/// Use `list_directory()` instead (Future API, no race condition).
///
/// Phase VFS-Fix: Added delay after sink.add() to ensure Dart processes data.
Stream<List<DirEntry>> streamListDir({required String path}) =>
    RustLib.instance.api.crateApiStreamListDir(path: path);

/// Get entry name
String getDirEntryName({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryName(entry: entry);

/// Get entry path
String getDirEntryPath({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryPath(entry: entry);

/// Check if entry is a directory
bool isDirEntryDir({required DirEntry entry}) =>
    RustLib.instance.api.crateApiIsDirEntryDir(entry: entry);

/// Check if entry is a symlink
bool isDirEntrySymlink({required DirEntry entry}) =>
    RustLib.instance.api.crateApiIsDirEntrySymlink(entry: entry);

/// Get entry size (bytes)
BigInt? getDirEntrySize({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntrySize(entry: entry);

/// Get entry modified timestamp (Unix epoch seconds)
BigInt? getDirEntryModified({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryModified(entry: entry);

/// Get entry permissions string
String? getDirEntryPermissions({required DirEntry entry}) =>
    RustLib.instance.api.crateApiGetDirEntryPermissions(entry: entry);

/// Request server to watch a directory for changes
///
/// Server will push FileEvent messages when files are created/modified/deleted.
/// Call receive_file_event() in a loop to receive watcher events.
///
/// # Arguments
/// * `path` - Absolute path to watch (e.g., "/tmp", "/home/user/project")
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestWatchDir({required String path}) =>
    RustLib.instance.api.crateApiRequestWatchDir(path: path);

/// Request server to stop watching a directory
///
/// # Arguments
/// * `watcher_id` - ID of the watcher to stop (returned in WatchStarted event)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestUnwatchDir({required String watcherId}) =>
    RustLib.instance.api.crateApiRequestUnwatchDir(watcherId: watcherId);

/// Receive next file watcher event from server (NON-BLOCKING)
///
/// Returns watcher events (FileEvent, WatchStarted, WatchError).
/// Call repeatedly in a loop to process all events.
/// Returns None if no events available yet.
///
/// # Returns
/// * `Some(FileWatcherEventData)` - Event received
/// * `None` - No events available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<FileWatcherEventData?> receiveFileEvent() =>
    RustLib.instance.api.crateApiReceiveFileEvent();

/// Get file event buffer length (for monitoring)
///
/// Returns number of buffered events waiting to be processed.
Future<BigInt> fileEventBufferLen() =>
    RustLib.instance.api.crateApiFileEventBufferLen();

/// Request server to read a file
///
/// Server responds with file content. Call receive_file_content() to get the result.
///
/// # Arguments
/// * `path` - Absolute path to file (e.g., "/tmp/file.txt", "~/Documents/file.md")
/// * `max_size` - Maximum file size in bytes (default: 100KB = 102400)
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> requestReadFile({required String path, required BigInt maxSize}) =>
    RustLib.instance.api.crateApiRequestReadFile(path: path, maxSize: maxSize);

/// Receive next file content from server (NON-BLOCKING)
///
/// Returns file content received from server.
/// Call repeatedly in a loop to process all responses.
/// Returns None if no content available yet.
///
/// # Returns
/// * `Some(FileContentData)` - File content received
/// * `None` - No content available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<FileContentData?> receiveFileContent() =>
    RustLib.instance.api.crateApiReceiveFileContent();

/// Get file content buffer length (for monitoring)
///
/// Returns number of buffered file contents waiting to be processed.
Future<BigInt> fileContentBufferLen() =>
    RustLib.instance.api.crateApiFileContentBufferLen();

/// Create a new PTY session with UUID
///
/// Sends CreateSession message to server. Server creates PTY in project directory.
///
/// # Arguments
/// * `project_path` - Absolute path to project directory
/// * `session_id` - UUID string for the session
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> createSession({
  required String projectPath,
  required String sessionId,
}) => RustLib.instance.api.crateApiCreateSession(
  projectPath: projectPath,
  sessionId: sessionId,
);

/// Check if session exists on server (for re-attach on app restart)
///
/// Sends CheckSession message. Server responds with SessionReAttach or SessionNotFound event.
///
/// # Arguments
/// * `session_id` - UUID string to check
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> checkSession({required String sessionId}) =>
    RustLib.instance.api.crateApiCheckSession(sessionId: sessionId);

/// Switch active session
///
/// Sends SwitchSession message. Server responds with SessionHistory and SessionSwitched event.
/// Only the active session's output is pumped to the client.
///
/// # Arguments
/// * `session_id` - UUID string to switch to
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> switchSession({required String sessionId}) =>
    RustLib.instance.api.crateApiSwitchSession(sessionId: sessionId);

/// Close a session
///
/// Sends CloseSession message. Server responds with SessionClosed event.
///
/// # Arguments
/// * `session_id` - UUID string to close
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> closeSession({required String sessionId}) =>
    RustLib.instance.api.crateApiCloseSession(sessionId: sessionId);

/// List all active sessions
///
/// Sends ListSessions message. Server responds with text list via Output event.
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<void> listSessions() => RustLib.instance.api.crateApiListSessions();

/// Receive session history from server (NON-BLOCKING)
///
/// Returns history buffer for inactive session after switch.
/// Call repeatedly until None is returned.
///
/// # Returns
/// * `Some(SessionHistoryData)` - History received
/// * `None` - No history available yet
///
/// # Errors
/// Returns "Not connected" if client not initialized.
Future<SessionHistoryData?> receiveSessionHistory() =>
    RustLib.instance.api.crateApiReceiveSessionHistory();

/// Get active session ID
///
/// Returns the UUID of the currently active session, or None if no session is active.
Future<String?> getActiveSessionId() =>
    RustLib.instance.api.crateApiGetActiveSessionId();

/// Execute session command
///
/// Phase 02: Entry point for session management
/// Note: This is a placeholder - actual multi-PTY requires backend session manager
Future<List<SessionData>> sessionCommand({required SessionCommand cmd}) =>
    RustLib.instance.api.crateApiSessionCommand(cmd: cmd);

/// Send input to specific session
///
/// Phase 02: Send input to a session
Future<void> sendVibeInput({
  required String sessionId,
  required VibeInput input,
}) => RustLib.instance.api.crateApiSendVibeInput(
  sessionId: sessionId,
  input: input,
);

/// Simple add function for testing FFI
int add({required int a, required int b}) =>
    RustLib.instance.api.crateApiAdd(a: a, b: b);

/// Greeting function for testing FFI
String greet({required String name}) =>
    RustLib.instance.api.crateApiGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DirEntry>>
abstract class DirEntry implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPayload>>
abstract class QrPayload implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalCommand>>
abstract class TerminalCommand implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TerminalEvent>>
abstract class TerminalEvent implements RustOpaqueInterface {}

/// File content data (for Dart)
class FileContentData {
  /// File path
  final String path;

  /// File content (UTF-8 string)
  final String content;

  /// Content size in bytes
  final BigInt size;

  /// True if file was truncated due to size limit
  final bool truncated;

  const FileContentData({
    required this.path,
    required this.content,
    required this.size,
    required this.truncated,
  });

  static Future<FileContentData> default_() =>
      RustLib.instance.api.crateApiFileContentDataDefault();

  @override
  int get hashCode =>
      path.hashCode ^ content.hashCode ^ size.hashCode ^ truncated.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileContentData &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          content == other.content &&
          size == other.size &&
          truncated == other.truncated;
}

/// File watcher event data (for Dart)
class FileWatcherEventData {
  /// Event type: "file", "started", or "error"
  final String eventType;

  /// Watcher ID (for started/error events)
  final String watcherId;

  /// File path (for file events)
  final String path;

  /// File event type: "created", "modified", "deleted", "renamed"
  final String fileEventType;

  /// Old name (for rename events only)
  final String oldName;

  /// Event timestamp (Unix epoch seconds)
  final BigInt timestamp;

  /// Error message (for error events only)
  final String error;

  const FileWatcherEventData({
    required this.eventType,
    required this.watcherId,
    required this.path,
    required this.fileEventType,
    required this.oldName,
    required this.timestamp,
    required this.error,
  });

  static Future<FileWatcherEventData> default_() =>
      RustLib.instance.api.crateApiFileWatcherEventDataDefault();

  @override
  int get hashCode =>
      eventType.hashCode ^
      watcherId.hashCode ^
      path.hashCode ^
      fileEventType.hashCode ^
      oldName.hashCode ^
      timestamp.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileWatcherEventData &&
          runtimeType == other.runtimeType &&
          eventType == other.eventType &&
          watcherId == other.watcherId &&
          path == other.path &&
          fileEventType == other.fileEventType &&
          oldName == other.oldName &&
          timestamp == other.timestamp &&
          error == other.error;
}

@freezed
sealed class SessionCommand with _$SessionCommand {
  const SessionCommand._();

  /// Create new session
  const factory SessionCommand.create({
    required String projectPath,
    required String projectName,
  }) = SessionCommand_Create;

  /// Switch active session
  const factory SessionCommand.switch_({required String sessionId}) =
      SessionCommand_Switch;

  /// Close session
  const factory SessionCommand.close({required String sessionId}) =
      SessionCommand_Close;

  /// List all sessions
  const factory SessionCommand.list() = SessionCommand_List;
}

/// Session data for Flutter
///
/// Phase 02: Session metadata
class SessionData {
  final String id;
  final String projectName;
  final String projectPath;
  final String status;

  const SessionData({
    required this.id,
    required this.projectName,
    required this.projectPath,
    required this.status,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      projectName.hashCode ^
      projectPath.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionData &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          projectName == other.projectName &&
          projectPath == other.projectPath &&
          status == other.status;
}

/// Session history data (for Dart)
class SessionHistoryData {
  /// Session ID
  final String sessionId;

  /// History lines (max 100)
  final List<String> lines;

  const SessionHistoryData({required this.sessionId, required this.lines});

  @override
  int get hashCode => sessionId.hashCode ^ lines.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionHistoryData &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          lines == other.lines;
}

/// Terminal configuration for Flutter
class TerminalConfig {
  final int rows;
  final int cols;
  final String shell;

  const TerminalConfig({
    required this.rows,
    required this.cols,
    required this.shell,
  });

  static Future<TerminalConfig> default_() =>
      RustLib.instance.api.crateApiTerminalConfigDefault();

  @override
  int get hashCode => rows.hashCode ^ cols.hashCode ^ shell.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TerminalConfig &&
          runtimeType == other.runtimeType &&
          rows == other.rows &&
          cols == other.cols &&
          shell == other.shell;
}

@freezed
sealed class VibeInput with _$VibeInput {
  const VibeInput._();

  /// Plain text prompt
  const factory VibeInput.text({required String prompt}) = VibeInput_Text;

  /// Special key (arrows, Ctrl+C, etc)
  const factory VibeInput.key({required String keyCode}) = VibeInput_Key;

  /// Raw bytes
  const factory VibeInput.raw({required Uint8List data}) = VibeInput_Raw;
}
